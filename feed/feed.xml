<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>Assistant to the Proof Assistant</title>
	<subtitle>Writings on computer stuff.</subtitle>
	<link href="https://johnbender.us/feed/feed.xml" rel="self"/>
	<link href="https://johnbender.us/"/>
	<updated>2014-06-22T00:00:00-07:00</updated>
	<id>https://johnbender.us/</id>
	<author>
		<name>John Bender</name>
		<email>johnbender@protonmail.com</email>
	</author>
	
	<entry>
		<title>Faster Javascript Through Category Theory</title>
		<link href="https://johnbender.us/posts/2012-02-09-faster-javascript-through-category-theory/"/>
		<updated>2012-02-09T00:00:00-08:00</updated>
		<id>https://johnbender.us/posts/2012-02-09-faster-javascript-through-category-theory/</id>
		<content type="html">&lt;p&gt;This post started out as a &lt;a href=&quot;https://gist.github.com/7242a7434195565b4a9d&quot;&gt;gist&lt;/a&gt; that I was using to work through what I&#39;ve learned about category theory by applying it to something I already know: JavaScript. The surprising result was a clearly defined set of JavaScript functions and jQuery helpers that could be optimized to reduce execution time.&lt;/p&gt;
&lt;p&gt;In the course of this post we&#39;ll define two categories: one for HTMLElements and the other for jQuery objects. We&#39;ll then construct a Functor that maps from the category of HTMLElements to the category of jQuery objects. At the end we&#39;ll see how jQuery plugin authors can help user&#39;s speed up their JavaScript.&lt;/p&gt;
&lt;h3 id=&quot;asumptions%2Frequirements&quot;&gt;Asumptions/Requirements &lt;a class=&quot;direct-link&quot; href=&quot;#asumptions%2Frequirements&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Some things to know before getting started:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; is treated as an implicit parameter to jQuery helper functions, later referred to as &lt;strong&gt;Jqry&lt;/strong&gt; morphisms.&lt;/li&gt;
&lt;li&gt;Type guarantees are made by the closure compiler JSDoc type annotations and custom &lt;code&gt;@sig&lt;/code&gt; type signature annotation. Don&#39;t worry if this is new to you -- it only adds a bit more rigor to the discussion.&lt;/li&gt;
&lt;li&gt;My examples do not constitute proofs but I&#39;m fairly confident that both categories and the functor satisfy their respective laws.&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;categories&quot;&gt;Categories &lt;a class=&quot;direct-link&quot; href=&quot;#categories&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If you&#39;re perfectly happy taking the category definitions at face value, feel free to skip ahead to the next section.&lt;/p&gt;
&lt;p&gt;A category consists of two things, a set of objects and a set of morphisms sometimes referred to as arrows that relate two of those objects. In layman&#39;s terms, a category is a consistent set of things (objects) and operations on those things (morphisms/arrows). The abstract nature of both is exactly what gives categories and category theory power, because you can define a wide range of systems in terms of a categories. A few examples, including the two defined later in the post, will help to build an intuition for the forms that objects and morphisms can take.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category&quot;&gt;Hask&lt;/a&gt; is the category where Haskell types are the objects and functions are the morphisms.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Category_of_sets&quot;&gt;Set&lt;/a&gt; is the category where objects are sets and the morphism are, again, functions between those sets.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Additionally each and every category must satisfy three laws.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Identity: The morphisms in a category must include an identity morphism. In terms of the category Set or Hask and those defined here, the identity morphism is just a function that return it&#39;s first and only argument.&lt;/li&gt;
&lt;li&gt;Composition: The composition of morphisms, which is itself a requirement, must be associative. For Hask, Set, and the following categories this is simply function composition (eg &lt;code&gt;.&lt;/code&gt; for Hask) and we&#39;ll explicitly define a composition function for &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;. Function application is always associative&lt;sup&gt;2&lt;/sup&gt; so for Hask, Set and the categories to follow this can be assumed.&lt;/li&gt;
&lt;li&gt;Closed Under Composition: When composing two morphisms in a category the result must also be in the set of morphisms in the category. For Hask this means that the output of composing two functions must be another function that takes a Haskell type and returns a Haskell type which is the criteria for the function being in the set of Hask&#39;s morphisms.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These laws are important for understanding the conclusions drawn from the rest of the post and we&#39;ll cover how both the &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt; categories satisfies each.&lt;/p&gt;
&lt;h3 id=&quot;html&quot;&gt;Html &lt;a class=&quot;direct-link&quot; href=&quot;#html&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The Category &lt;strong&gt;Html&lt;/strong&gt; is extremely simple and, if you&#39;re still interested in understanding categories more generally, it will help in building an intuition for them. The objects in &lt;strong&gt;Html&lt;/strong&gt; are the HTMLElements that you&#39;re familiar with from JavaScript (eg, HTMLDivElement, HTMLAnchorElement). The morphisms are JavaScript functions that opperate on those objects, and &lt;em&gt;only&lt;/em&gt; those objects.&lt;/p&gt;
&lt;p&gt;The next step is to make sure that &lt;strong&gt;Html&lt;/strong&gt; satisfies the three category laws:&lt;/p&gt;
&lt;p&gt;Identity:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {HTMLElement} -&amp;gt; {HTMLElement} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;id&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;
}
&lt;/pre&gt;
&lt;p&gt;Composition:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @typedef {function(HTMElement): HTMElement} */&lt;/span&gt;
html.morphism;

&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism}, {html.morphism} -&amp;gt; {html.morphism} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;compose&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;f&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;g&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f(g(a));
  };
}
&lt;/pre&gt;
&lt;p&gt;Sample use of &lt;code&gt;compose&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;elem&lt;/span&gt; = document.getElementById( &lt;span class=&quot;string&quot;&gt;&quot;example-anchor&quot;&lt;/span&gt; );
elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;
elem = compose( a, b )( elem );
elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The identity function is trivial and, as noted before, function composition is always associative. We know that the functions in &lt;strong&gt;Html&lt;/strong&gt; are closed under composition because of the type guarantees we&#39;ve placed on them. That is, all the functions accept as their only argument HTMLElements and return only HTMLElements so there&#39;s no way to compose two of them that doesn&#39;t also have the same type signature. Having met the three requirements for a category with &lt;strong&gt;Html&lt;/strong&gt; we can move on to the second, and more complex category &lt;strong&gt;Jqry&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;jqry&quot;&gt;Jqry &lt;a class=&quot;direct-link&quot; href=&quot;#jqry&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Jqry&lt;/strong&gt; is the category of &lt;code&gt;jQuery&lt;/code&gt; objects and functions from &lt;code&gt;jQuery&lt;/code&gt; objects to &lt;code&gt;jQuery&lt;/code&gt; objects.&lt;sup&gt;3&lt;/sup&gt; It&#39;s only slightly more complex than &lt;strong&gt;Html&lt;/strong&gt; because the reader must accept &lt;code&gt;this&lt;/code&gt; as an implicit parameter to the JavaScript functions that are the category&#39;s morphisms. Also, these morphisms must be defined on the &lt;code&gt;$.fn&lt;/code&gt; object to guarantee the value of &lt;code&gt;this&lt;/code&gt; is a &lt;code&gt;jQuery&lt;/code&gt; object. Otherwise the objects are simply jQuery objects as you know them from day to day use, ie the result of something like &lt;code&gt;$(&amp;quot;div&amp;quot;)&lt;/code&gt;, and the functions are JavaScript functions that retun jQuery objects.&lt;/p&gt;
&lt;p&gt;Identity:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @this {jQuery}
    @return {jQuery} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){ &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;return this&lt;/span&gt;&lt;/span&gt; };
&lt;/pre&gt;
&lt;p&gt;Sample use of &lt;code&gt;$.fn.id&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$elem&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );

assert($elem.id() == $elem); &lt;span class=&quot;comment&quot;&gt;// true
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;As you can see, the value of &lt;code&gt;this&lt;/code&gt;, and therefore the constraint that the morphisms must be defined on &lt;code&gt;$.fn&lt;/code&gt;, plays an important roll in the way that the functions behave in the &lt;strong&gt;Jqry&lt;/strong&gt; category. If it&#39;s unclear why that is, remember that &lt;code&gt;this&lt;/code&gt; is whatever object the method is invoked on using dot notation in JavaScript. Also recall that &lt;code&gt;$.fn == $.prototype&lt;/code&gt;, meaning when you call &lt;code&gt;$(&amp;quot;div&amp;quot;).foo()&lt;/code&gt; it finds &lt;code&gt;foo&lt;/code&gt; on the &lt;code&gt;$.fn&lt;/code&gt; by following the prototype chain.&lt;/p&gt;
&lt;p&gt;Composition:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @typedef {function(this:jQuery): jQuery} */&lt;/span&gt;
jqry.morphism;

&lt;span class=&quot;doc&quot;&gt;/** @sig {jqry.morphism}, {jqry.morphism} -&amp;gt; {jqry.morphism} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;compose&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;f&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;g&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
    &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;return f.apply(g.apply(this, arguments), arguments)&lt;/span&gt;&lt;/span&gt;
  };
};
&lt;/pre&gt;
&lt;p&gt;Defining composition is a bit more complex for &lt;strong&gt;Jqry&lt;/strong&gt; than it is for &lt;strong&gt;Html&lt;/strong&gt; if only because forcing the value that &lt;code&gt;this&lt;/code&gt; will represent in the composed functions takes more work than just passing in the values as parameters. The first function, &lt;code&gt;g&lt;/code&gt;, is invoked by forwarding the arguments and explicitly defining its &lt;code&gt;this&lt;/code&gt; value using the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; method common to all JavaScript functions. The value returned by applying &lt;code&gt;g&lt;/code&gt; is a jQuery object, as required by membership in the category &lt;strong&gt;Jqry&lt;/strong&gt;, which is used to explicitly define &lt;code&gt;this&lt;/code&gt; in the application of &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Sample use:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
    elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
  });
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
    elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
  });
};

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$elem&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );
$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.aAndB = $.compose( $.fn.a, $.fn.b );

$elem.aAndB().attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Please direct your attention to the fact that you could substitute the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; functions from the &lt;strong&gt;Html&lt;/strong&gt; &lt;code&gt;compose&lt;/code&gt; example here for the functions that are mapped using &lt;code&gt;this.map&lt;/code&gt; (&lt;code&gt;$.fn.map&lt;/code&gt;) over the set of elements in the jQuery object (represented by &lt;code&gt;this&lt;/code&gt;). This will be important when defining the Functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Again, we know that the morphisms of &lt;strong&gt;Jqry&lt;/strong&gt; are closed under composition because each accepts and returns only jQuery objects.&lt;/p&gt;
&lt;h3 id=&quot;%24()-%E2%88%89-functors&quot;&gt;$() ∉ Functors &lt;a class=&quot;direct-link&quot; href=&quot;#%24()-%E2%88%89-functors&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Functors are a &lt;em&gt;single&lt;/em&gt; morphism from one category to another. Another way to think about them is a an operation that can take either an object or a morphism from one category and translate it so that it exists or &amp;quot;works&amp;quot; in another category. This obvioulsy means that a given functor handles both morphisms and objects. Evaluating &lt;code&gt;$()&lt;/code&gt; as a functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;, shows that it translates the objects in the category &lt;strong&gt;Html&lt;/strong&gt; (HTMLElements) properly to the objects in &lt;strong&gt;Jqry&lt;/strong&gt; (instances of jQuery) but turns the morphisms (functions) into dom ready callbacks. So &lt;code&gt;$()&lt;/code&gt; is not, strictly speaking, a category theoretic functor.&lt;/p&gt;
&lt;p&gt;On the other hand it&#39;s quite easy to define a function that handles both objects functions properly. As I noted in a previos post and in an earlier in this post, &lt;code&gt;$.fn.map&lt;/code&gt; provides an easy way to change functions in &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;. So, this new functor just needs to check if it&#39;s operating on an object or a function from the &lt;strong&gt;Html&lt;/strong&gt; category and respond accordingly.&lt;/p&gt;
&lt;p&gt;For the Haskell fans out there (and ciaranm in ##categorytheory) it&#39;s better to define a seperate function to handle the translation of morphisms from one category to another in the spirit of &lt;code&gt;fmap&lt;/code&gt;, but since this is flexible ol&#39; JavaScript, it&#39;s possible to use type unions in the closure compiler type constraints, and I think it makes the mapping from theory to Javascript a bit easier to understand, I&#39;ve chosen to deal with both in a single function.&lt;/p&gt;
&lt;h3 id=&quot;functor-html--%3E-jqry&quot;&gt;Functor Html -&amp;gt; Jqry &lt;a class=&quot;direct-link&quot; href=&quot;#functor-html--%3E-jqry&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {HTMLElement | html.morphism} -&amp;gt; {jQuery | jqry.morphism} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;Functor&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a == &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ){
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(a);
    };
  } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
  }
};
&lt;/pre&gt;
&lt;p&gt;Sample use for objects:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;elem&lt;/span&gt;&lt;/span&gt; = document.getElementsById( &lt;span class=&quot;string&quot;&gt;&quot;example&quot;&lt;/span&gt; );
elem.nodeName;                        &lt;span class=&quot;comment&quot;&gt;// &quot;A&quot;
&lt;/span&gt;$.Functor( elem ).prop( &lt;span class=&quot;string&quot;&gt;&quot;nodeName&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;A&quot;
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Sample use for functions:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.myMorphism = $.Functor(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ){
  a.setAttribute(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;
});

$( &lt;span class=&quot;string&quot;&gt;&quot;#example&quot;&lt;/span&gt; ).attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; );              &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#example&quot;&lt;/span&gt; ).myMorphism().attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;In the first example it takes an HTMLElement, the objects onf &lt;strong&gt;Html&lt;/strong&gt;, and translates it into a jQuery object by using the &lt;code&gt;$()&lt;/code&gt; function. In the second example it takes a function from HTMLElements to HTMLElements, a morpishm in &lt;strong&gt;Html&lt;/strong&gt;, and translates it to a function from jQuery objects to jQuery objects.&lt;/p&gt;
&lt;p&gt;Having establish how the functor will operate it too has laws we must adhear to. First it must preserve identity:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; = document.getElementById( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );

assert($.Functor(id(a)) == id($.Functor(a)));

a;                 &lt;span class=&quot;comment&quot;&gt;// &amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/span&gt;
id(a);             &lt;span class=&quot;comment&quot;&gt;// &amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/span&gt;$.Functor(id(a));  &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;
$.Functor(a);      &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;$.Functor(a).id(); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Whether the identity function is applied before or after the Functor the result should be the same. As you can see the return value of the two expressions is idenitcal. The second law states the the Functor must preserve composition. Assuming a and b from the html compose example:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$elem&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );
assert($.Functor(compose(a, b)) == $.compose($.Functor(a), $.Functor(b)));

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;aAndB&lt;/span&gt; = compose(a, b);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.fstAB = $.Functor(aAndB);                       &lt;span class=&quot;comment&quot;&gt;// function() { this.map(aAndB); }
&lt;/span&gt;$elem.fstAB().attr(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;);                           &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr(&lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);                                   &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;
$elem = $( &lt;span class=&quot;string&quot;&gt;&quot;#second-example-anchor&quot;&lt;/span&gt; );
$.Functor(a);                                        &lt;span class=&quot;comment&quot;&gt;// function() { this.map(a) };
&lt;/span&gt;$.Functor(b);                                        &lt;span class=&quot;comment&quot;&gt;// function() { this.map(b) };
&lt;/span&gt;&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.sndAB = $.compose( $.Functor(a), $.Functor(b) );
$elem.sndAB().attr(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;);                           &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr(&lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);                                   &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;This means that composing the functions and then applying the Functor should create a function that behaves identically to a function created by composing two functions that have had the Functor applied already. Essentially, for all input values the output will be the same. We&#39;ll see in a second why that distinction is important.&lt;/p&gt;
&lt;p&gt;The assertion at the top will fail of course because the functions are not the same object. More importantly it would fail even if the functions were compared as strings, because they using different internal mechanisms. Ultimately though the functionality is the same and that&#39;s what we care about. In each case both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be allowed to alter each element in the jQuery object&#39;s set and apply the attribute values &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;While they have the same outcome, the underlying machinery is very different. &lt;code&gt;$.fn.fstAB&lt;/code&gt; is &lt;em&gt;one&lt;/em&gt; iteration over the set of HTMLElements in the jQuery set and &lt;code&gt;$.fn.sndAB&lt;/code&gt; is &lt;em&gt;two&lt;/em&gt;. That is &lt;code&gt;$.fn.sndAB&lt;/code&gt; is applying two seperate &lt;code&gt;$.fn&lt;/code&gt; methods which is equivelant to &lt;code&gt;$(&amp;quot;foo&amp;quot;).a().b()&lt;/code&gt;, where as &lt;code&gt;$.fn.fstAB&lt;/code&gt; is calling &lt;code&gt;$.fn.map&lt;/code&gt; only once and piping each element through two composed functions that operate on HTMLElements, &lt;code&gt;$(&amp;quot;foo&amp;quot;).map(aAndB)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt; They get the same results but &lt;code&gt;$.fn.sndAB&lt;/code&gt; requires twice as many iterations over the jQuery set!&lt;/p&gt;
&lt;p&gt;You might recognize the optimization as &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_fusion&quot;&gt;loop fusion&lt;/a&gt;. By ensuring that the functor satisfies the requsite laws we&#39;ve stumbled upon an interesting relationship. That is, any time we use n &amp;gt; 1 iterative &lt;code&gt;$.fn&lt;/code&gt; methods that exist in &lt;strong&gt;Jqry&lt;/strong&gt; it&#39;s possible to extract the pure HTMLElement-altering functions that &lt;em&gt;might&lt;/em&gt; underly them, compose those functions, and save n-1 full iterations in the process.&lt;/p&gt;
&lt;h3 id=&quot;loop-fusing-hipster&quot;&gt;Loop Fusing Hipster &lt;a class=&quot;direct-link&quot; href=&quot;#loop-fusing-hipster&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;It&#39;s clear that someone using &lt;code&gt;$(&amp;quot;foo&amp;quot;).a().b()&lt;/code&gt; could, entirely indepdendent of this rigmarole, arrive at the same conclusion that the loops underlying &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be unified to speed up execution and subsequently point out they&#39;ve been fusing loops since before it was cool. What&#39;s not clear is how to know in other cases when it&#39;s possible to extract the underlying functions from the &lt;code&gt;$.fn&lt;/code&gt; methods for composition. Because of the Functor laws we&#39;ve unambiguously defined a specific subset of functions -- the set of &lt;strong&gt;Html&lt;/strong&gt; morphisms with &lt;code&gt;$.fn.map&lt;/code&gt; applied -- that we &lt;em&gt;know&lt;/em&gt; can be fused and will produce the same result. Put differently:&lt;/p&gt;
&lt;p&gt;As long as the &lt;em&gt;n&lt;/em&gt; functions being mapped over the jQuery object&#39;s contents individually are all from HTMLElements to HTMLElements, we can compose them, map the resulting composed function over the jQuery object set &lt;em&gt;once&lt;/em&gt;, and be asured the resulting jQuery object will be the same.&lt;/p&gt;
&lt;h3 id=&quot;package-it-up&quot;&gt;Package it up &lt;a class=&quot;direct-link&quot; href=&quot;#package-it-up&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that we know which functions can be composed to save some execution time it would be nice to know how use this to improve jQuery plugins. One way is to get jQuery plugin authors provide the underlying DOM manipulation functions as attributes on the plugin methods. This would allow users to do the fusing when it makes sense. Lets use our two composition examples from the &lt;strong&gt;Jqry&lt;/strong&gt; category to see what this might look like.&lt;/p&gt;
&lt;p&gt;Plugin one:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;setFoo&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(setFoo);
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.a.pure = setFoo;
&lt;/pre&gt;
&lt;p&gt;Plugin two:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;setBaz&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(setBaz);
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.b.pure = setBaz;
&lt;/pre&gt;
&lt;p&gt;Now both the function from &lt;strong&gt;Html&lt;/strong&gt; and the function from &lt;strong&gt;Jqry&lt;/strong&gt; are available to the end user. Should they end up using them in serial it&#39;s trivial to fuse the two loops:&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;comment&quot;&gt;// two full iterations
&lt;/span&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;).a().b();

&lt;span class=&quot;comment&quot;&gt;// one full iteration
&lt;/span&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;).map(compose($.fn.a.pure, $.fn.b.pure));
&lt;/pre&gt;
&lt;p&gt;Obviously these two examples are tiny and could easily be consolidated by hand, but two plugins with more complex DOM manipulations would be much harder to classify as &amp;quot;fusable&amp;quot;. By puting the onus on the plugin developer it gives the end user a better guarantee that it&#39;s safe.&lt;/p&gt;
&lt;h3 id=&quot;did-you-make-it%3F&quot;&gt;Did you make it? &lt;a class=&quot;direct-link&quot; href=&quot;#did-you-make-it%3F&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;And there you have it. After defining a mathematical framework in which to view DOM alterations with jQuery and JavaScript we identified an important set of characteristics to use for speeding up our client side code. Maybe this isn&#39;t enough to get you interested, but for me it&#39;s an afirmation that, even this far from the its ivory towers, math has a role to play.&lt;/p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Thanks again to edwardk and xplat from #haskell-blah and ciaranm from ##categorytheory for reviewing my categories and providing feedback. I&#39;d also like to thank &lt;a href=&quot;http://twitter.com/keyist&quot;&gt;Tim Goh&lt;/a&gt; for taking the time to enhance my terrible writting.&lt;/li&gt;
&lt;li&gt;Function composition is always associative, even for impure functions. You&#39;ll have to google around a bit for a proof but this appears to be a &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;generally excepted truth&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;If you&#39;re interested in digging a bit further into this topic &lt;strong&gt;Jqry&lt;/strong&gt; is actually a monoidal category. Credit to both edwardk and xplat in #haskell-blah for pointing this out. As far as I can tell, the morphisms (&lt;code&gt;$.fn&lt;/code&gt; methods) are muplication as they map from jQuery to jQuery and the unit element is &lt;code&gt;[]&lt;/code&gt; since using it with &lt;code&gt;$()&lt;/code&gt; as the unit morphism yields an empty jQuery object.&lt;/li&gt;
&lt;li&gt;Haskellers will recognize this, and the ultimate conclusion that the rest of the post draws as a degenerate version of &lt;code&gt;(fmap a) . (fmap b) == fmap (a . b)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
	</entry>
	
	<entry>
		<title>A Natural Transformation in JavaScript</title>
		<link href="https://johnbender.us/posts/2012-03-22-a-natural-transformation-in-javascript/"/>
		<updated>2012-03-22T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2012-03-22-a-natural-transformation-in-javascript/</id>
		<content type="html">
Natural transformations are a foundational construct in category theory, so it seems fitting to follow up my &lt;a href=&quot;https://johnbender.us/2012/02/29/faster-javascript-through-category-theory/&quot;&gt;last post&lt;/a&gt; by describing one using the categories &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;. As a result this post assumes the reader has covered the material from the last post. Also, as much as I wish that I could claim a similarly exciting result this will remain mostly an exercise in clarifying what natural transformations are and how they behave. If it&#39;s any consolation I&#39;ve borrowed some very attractive TeX diagrams from Wikipedia to help illustrate.

&lt;h2&gt;Natural Transformations&lt;/h2&gt;

Natural transformations are actually fairly simple once you have an example you can comprehend. One way to describe them is - a set of morphisms&lt;sup&gt;1&lt;/sup&gt; that reconcile the way two functors from the same source to the same target categories alter morphisms of the source category&lt;sup&gt;2&lt;/sup&gt;. Unfortunately the written descriptions seems to fall short in aiding comprehension, but as promised there are pretty pictures:

&lt;div style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;https://johnbender.us/img/transform/equation.png&quot; alt=&quot;n sub x compose F applied to f is equal to G applied to f compose n sub y&quot;&gt;
&lt;/div&gt;

This equation is simple and captures the expected behavior of the natural transformation &lt;code&gt;N&lt;/code&gt; (used in place of &lt;code&gt;η&lt;/code&gt; hereafter). Namely, it must &quot;prepare&quot; input objects for a morphism transformed with &lt;code&gt;G&lt;/code&gt;, ie &lt;code&gt;G(f)&lt;/code&gt;, such that the result will be identical to that of &quot;repairing&quot; the output objects from a morphism transformed with &lt;code&gt;F&lt;/code&gt;, ie &lt;code&gt;F(f)&lt;/code&gt;. Again, this assumes that both &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; share that same source and target categories. Also it helps to remember that the input and output objects of &lt;code&gt;F(f)&lt;/code&gt; and &lt;code&gt;G(f)&lt;/code&gt; are in the target category, so if &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are both from categories &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;jQuery&lt;/strong&gt; we&#39;re just dealing with objects in &lt;strong&gt;Jqry&lt;/strong&gt;. If the notation is confusing recall that &lt;code&gt;○&lt;/code&gt; is the operator form of &lt;code&gt;$.compose&lt;/code&gt; and that &lt;code&gt;F(f)&lt;/code&gt; is that same as &lt;code&gt;$.Functor(f)&lt;/code&gt; from the previous post, both of which result in JavaScript functions/morphisms. While this equation gives us an understanding of how the transformation should function, it doesn&#39;t help with comprehending the transformations directionality and purpose.

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;https://johnbender.us/img/transform/diagram.png&quot; alt=&quot;diagram of composition&quot;&gt;
&lt;/div&gt;

Diagrams are used to clarify composition of morphisms, a (the?) key operation in category theory. This diagram represents the same concept as the equation but it makes the goal more obvious: from &lt;code&gt;F(X)&lt;/code&gt; whether you take the road to the east - &lt;code&gt;Ny ○ F(f)&lt;/code&gt; or the road to the south - &lt;code&gt;G(f) ○ Nx&lt;/code&gt; - the result has to be the same. Again, the purpose of the natural tranformation is get the results to look like &lt;code&gt;G(f)&lt;/code&gt; results whether the operation started with &lt;code&gt;F(f)&lt;/code&gt; or ended with &lt;code&gt;G(f)&lt;/code&gt;.

If, at this point, it&#39;s still unclear don&#39;t worry the JavaScript examples should help.

&lt;h2&gt;Two Functors&lt;/h2&gt;

Since natural transformations are defined for two functors we&#39;ll borrow the &lt;code&gt;$.Functor&lt;/code&gt; from the last post and then try to find another. As a quick refresher the &lt;code&gt;$.Functor&lt;/code&gt; functor maps from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt; using the &lt;code&gt;$.fn.map&lt;/code&gt; method. We&#39;ll rename it &lt;code&gt;F&lt;/code&gt; so that it&#39;s easier to reconcile with the diagram/equation.

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;F&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map( a );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

The new functor obviously has to be different, so let&#39;s tweek the way that it operates on the functions from &lt;strong&gt;Html&lt;/strong&gt;. In this case the function it returns only applys the &lt;code&gt;html.morphism&lt;/code&gt; to the first member of the jQuery object&#39;s set. Note that it retains the same operation on objects in &lt;strong&gt;Html&lt;/strong&gt;, the application of &lt;code&gt;$()&lt;/code&gt;.

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;G&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      a( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;[0] );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

An alternate implementation that forwards the arguments down to the &lt;code&gt;html.morphism&lt;/code&gt; is a bit more complex but much more useful&lt;sup&gt;3&lt;/sup&gt;:

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;G&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;args&lt;/span&gt; = [].slice.call(arguments);

      args.unshift( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;[0] );
      a.apply( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, args );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

At first this may seem like defining an alternate functor for the sake of it, but there are already methods in jQuery Core that behave in this fashion. For example a naive implementation of the &lt;code&gt;$.fn.css&lt;/code&gt; method using the argument-forwarding form of our new functor&lt;sup&gt;4&lt;/sup&gt;:

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.newCss = G(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;value&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;style&quot;&lt;/span&gt;,  key + &lt;span class=&quot;string&quot;&gt;&quot;: &quot;&lt;/span&gt; + value );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
});

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$foo&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$foo.newCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Now we&#39;ve got two functors that satisfy the basics needed to define a natural transformation. They both have the same source and target categories, &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt; respectively, but they are distinct in the way that they achieve the goal of translating the functions/morphisms from &lt;strong&gt;Html&lt;/strong&gt; into functions/morphisms in &lt;strong&gt;Jqry&lt;/strong&gt;. Now we just need to find a way to make results from &lt;code&gt;F&lt;/code&gt; look like results from &lt;code&gt;G&lt;/code&gt;.

&lt;h2&gt;Finding the Transformation&lt;/h2&gt;

Recall from the diagram that the natural transformation must produce the same result whether it&#39;s composed &quot;in front of&quot; a &lt;code&gt;$.fn&lt;/code&gt; method defined with &lt;code&gt;G&lt;/code&gt; or after a &lt;code&gt;$.fn&lt;/code&gt; method defined with &lt;code&gt;F&lt;/code&gt;. Lets look at an example of two methods built with &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; using the css function in the previous example to see if that points us in the right direction. For completeness&#39; sake we need to modify &lt;code&gt;F&lt;/code&gt; so that the function it returns accepts arguments:

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;F&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$this&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;,
          &lt;span class=&quot;variable-name&quot;&gt;args&lt;/span&gt; = [].slice.call(arguments);

      &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ) {
        args.unshift( elem );
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.apply( $this, args );
      });
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

Having squared that let&#39;s look at an example definition of two &lt;code&gt;$.fn&lt;/code&gt; methods using the Functors.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;alterCss&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;value&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;style&quot;&lt;/span&gt;,  key + &lt;span class=&quot;string&quot;&gt;&quot;: &quot;&lt;/span&gt; + value );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.mapCss = F(alterCss);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.oneCss = G(alterCss);

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$foo&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$foo.mapCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$bar&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;bar&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$bar.oneCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Here &lt;code&gt;$.fn.mapCss&lt;/code&gt; is equivelant to &lt;code&gt;F(f)&lt;/code&gt; and &lt;code&gt;$.fn.oneCss&lt;/code&gt; is equivelant to &lt;code&gt;G(f)&lt;/code&gt; in the equation and diagram. As you would expect the method created using &lt;code&gt;G&lt;/code&gt; only alters the first element in the jQuery object set where as the method created with &lt;code&gt;F&lt;/code&gt; alters all the elements. So our hypothetical natural transformation could simply reduce the jQuery object set to the first element in which case both results would be the same. The &lt;code&gt;$.fn.first&lt;/code&gt; method should serve. Borrowing the &lt;code&gt;$.compose&lt;/code&gt; function, again from the previous post, we can verify that it matches the equation.

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.FtoNy = $.compose( $.fn.first, F(alterCss) );
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.NxToG = $.compose( G(alterCss), $.fn.first );

$( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; ).FtoNy( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; ).NxToG( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

If you replace the application of &lt;code&gt;$.compose&lt;/code&gt; with the infix operator &lt;code&gt;○&lt;/code&gt; it looks just like the equation:

&lt;div style=&quot;text-align: center&quot;&gt;
  &lt;img src=&quot;https://johnbender.us/img/transform/equation.png&quot; alt=&quot;n sub x compose F applied to f is equal to G applied to f compose n sub y&quot;&gt;
&lt;/div&gt;

With the order reversed we can use the more idiomatic fluent invocation:

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.mapCss = F(alterCss);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.oneCss = G(alterCss);

$( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; ).mapCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ).first(); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; ).first().oneCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Let&#39;s alter the diagram to use the new method names:

&lt;div style=&quot;text-align: center&quot;&gt;
  &lt;img src=&quot;https://johnbender.us/img/transform/svg-methods.png&quot; alt=&quot;altered diagram&quot; title=&quot;svg-methods&quot; width=&quot;200&quot; height=&quot;162&quot; class=&quot;aligncenter size-full wp-image-1695&quot;&gt;
&lt;/div&gt;

As you can see the southerly route first limits the jQuery object set and then applys the method that only operates on the first object, whereas the easterly route first applys the method that opperates on all the functions in the jQuery object set and then limits the set to one result. Most of the time you&#39;ll want to head South to save yourself some execution time.

&lt;h2&gt;Naturally&lt;/h2&gt;

The result of our work is a trivial optimization that most users should be able spot, ie. they might be creating a method chain that invokes &lt;code&gt;$.fn.first&lt;/code&gt; too late. In any case, the fact that we can arrive at this conclusion by viewing the JavaScript through the lense of mathematics continues to astound me and it makes me wonder what interesting things I might find by examining Monoids and Cartesion Closed categories.

&lt;ol&gt;
&lt;li&gt;Thanks to Dan Peebles, otherwise known as &lt;a href=&quot;http://twitter.com/copumpkin&quot;&gt;copumpkin&lt;/a&gt;, for reviewing the introduction to natural transformations and suggesting this addition.&lt;/li&gt;
&lt;li&gt;This is far from rigorous. For a more concrete definition checkout the &lt;a href=&quot;http://en.wikipedia.org/wiki/Natural_transformation&quot;&gt;wikipedia page&lt;/a&gt; and &lt;a href=&quot;http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation&quot;&gt;haskell wiki page&lt;/a&gt; pages. My attempt to rephrase the definition comes from my experiences learning abstract concepts like this where I&#39;ve often been aided by many different renderings of the same idea.&lt;/li&gt;
&lt;li&gt;It&#39;s important to keep in mind that, as a result of forwarding the arguments, we&#39;ve technically changed the type signature of the &lt;strong&gt;Html&lt;/strong&gt; morphism from &lt;code&gt;HTMLElement -&amp;gt; HTMLElement&lt;/code&gt; to &lt;code&gt;HTMLElement, String, String -&amp;gt; HTMLElement&lt;/code&gt;. For the purposes of our discussion I thought it was usefull to pull an existing example from jQuery to illustrate how the second functor works. Also if the jQuery object is empty this will `unshift` undefined as the first argument. Again, clarity proved to be more important.&lt;/li&gt;
&lt;li&gt;This implementation omits even simple style persistence for the sake of focusing the reader on the subject matter.&lt;/li&gt;
&lt;/ol&gt;
</content>
	</entry>
	
	<entry>
		<title>Splitting jQuery in Two, A Proposal</title>
		<link href="https://johnbender.us/posts/2012-07-19-splitting-jquery-in-two-a-proposal/"/>
		<updated>2012-07-19T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2012-07-19-splitting-jquery-in-two-a-proposal/</id>
		<content type="html">&lt;p&gt;Previously I&#39;ve described applications of Category Theory in JavaScript and with jQuery. An earlier post, &lt;a href=&quot;https://johnbender.us/posts/2012-02-09-faster-javascript-through-category-theory/&quot;&gt;Faster JavaScript with Category Theory&lt;/a&gt;, identified a possible performance benefit where composition could be shown to hold for a Functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;. This post follows up with a more concrete look at that optimization and suggests an additional, farther reaching, implication for the two categories.&lt;/p&gt;
&lt;h2 id=&quot;quick-recap&quot;&gt;Quick Recap &lt;a class=&quot;direct-link&quot; href=&quot;#quick-recap&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Previously we defined the categories &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;, providing a concrete mathematical representation of DOM manipulations in raw form and their counterparts used inside the jQuery library.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Html&lt;/strong&gt; is the category of all DOM elements and JavaScript functions that manipulate them. It represents the basic building blocks of client side web applications that most web developers are familiar with, eg&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setFoo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;class&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code&gt;elem&lt;/code&gt; is any object implementing the &lt;code&gt;HTMLElement&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jqry&lt;/strong&gt; is the category of jQuery objects (sets of DOM elements) and jQuery methods, eg&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the jQuery &amp;quot;object-set&amp;quot; of divs selected from the DOM is an example object in &lt;strong&gt;Jqry&lt;/strong&gt; and &lt;code&gt;addClass&lt;/code&gt; is an example morphism.&lt;/p&gt;
&lt;p&gt;We also saw that defining a mapping (Functor) from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt; and proving that composition is preserved suggests a possible performance win in the form of loop fusion. The two components of the mapping turned out to be jQuery&#39;s dollar function and &lt;code&gt;$.map&lt;/code&gt; for objects and morphisms respectively. The important equivalence, preserving composition:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cmps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; g&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which is an equivalence of two approaches (one of which requires one less iteration to accomplish the same task). This, viewed in the light of &amp;quot;interesting results from math&amp;quot;, is relatively exciting but the performance implications warranted some further exploration, which takes us to the meat of this post.&lt;/p&gt;
&lt;h2 id=&quot;performance-reality&quot;&gt;Performance Reality &lt;a class=&quot;direct-link&quot; href=&quot;#performance-reality&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The most obvious and the least labor-intensive candidates for profiling loop fusion are jQuery methods that already rely on an &lt;em&gt;abstracted&lt;/em&gt; &lt;strong&gt;Html&lt;/strong&gt; morphism. They represent a real use case for that separation of functionality within the library.&lt;/p&gt;
&lt;p&gt;The one I chose was &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt;. It relies on &lt;code&gt;jQuery.removeAttr&lt;/code&gt; (note that this is not defined on the jQuery object prototype &lt;code&gt;jQuery.fn&lt;/code&gt;) for its DOM manipulations and uses the &lt;code&gt;jQuery.fn.each&lt;/code&gt; method to iterate over the set of elements.&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Current jQuery.fn.removeAttr implementation in jQuery Core&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;removeAttr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Testing a set of chained calls to &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; against a single loop with three inlined invocations of &lt;code&gt;jQuery.removeAttr&lt;/code&gt; &lt;a href=&quot;http://jsperf.com/remove-attr-composed-vs-chained-simple-methods/2&quot;&gt;yielded&lt;/a&gt; a fairly consistent 5-10 percent performance increase (blue bars). This was an &lt;a href=&quot;http://johnbender.github.com/presentation-faster-js/#24&quot;&gt;incentive&lt;/a&gt; of sorts that I used to keep people from running for the exits during my JQCON talk.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/alVRh.png&quot; alt=&quot;incentive&quot;&gt;&lt;/p&gt;
&lt;p&gt;Unfortunately this doesn&#39;t accurately represent the reality of most jQuery methods. The majority of the performance benefit appears to arise from the reduction in the number of function calls when a single loop with many invocations is used in place of multiple loop callbacks and function invocations. In the majority of jQuery methods the DOM alterations are actually inlined. That is, they don&#39;t live in an abstracted &lt;strong&gt;Html&lt;/strong&gt; morphism at all -- the DOM elements are manipulated inside the loop and then returned to the jQuery &amp;quot;object-set&amp;quot;.&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// More likely/performant version with inlined dom manipulation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;removeAttr&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; length &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; length&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		elem &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token comment&quot;&gt;// attr removal in jQuery.removeAttr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running a similar test but with an inlined implementation of &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; for the chained version resulted in a &lt;a href=&quot;http://jsperf.com/chained-sequence-or-composition-removeattr/2&quot;&gt;performance profile&lt;/a&gt; mostly indistinguishable from the manually fused alternative (blue and yellow bars in the graph below). While this might require more investigation it was fair to conclude that fusion isn&#39;t compelling enough to warrant further work. Luckily a fruitful conversation with some of the attendees at my talk gave me a few ideas that might ultimately provide more value in terms of library architecture and performance.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Qtq7Q.png&quot; alt=&quot;performance profile&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;even-my-presentation-had-side-effects&quot;&gt;Even My Presentation had Side Effects &lt;a class=&quot;direct-link&quot; href=&quot;#even-my-presentation-had-side-effects&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Most of the jQuery Core team was at the breakout session doing dramatic readings of bugs when I gave my presentation&lt;sup&gt;1&lt;/sup&gt; but there was a notable attendee in the front row, Yehuda Katz. He asked after my talk if the test methods were implemented using actual composition or simply invoked directly in serial (they were), alluding to the fact that the additional function call added with &lt;code&gt;cmps&lt;/code&gt; would negate the reduced loop iteration operations.&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;cmps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;f&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; g&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token comment&quot;&gt;// the closure creates an additional function call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we saw earlier, even when DOM manipulation is abstracted into a function and invoked directly it&#39;s likely in the best case to perform at/near parity with a jQuery method built on inlined DOM manipulation code. Consequently, adding the extra function wrapper and call to the execution path with &lt;code&gt;cmps&lt;/code&gt; may result in a slowdown (red bars in the previous graph).&lt;/p&gt;
&lt;p&gt;Yehuda subsequently also expressed interest in the idea of clearly separating the &lt;strong&gt;Html&lt;/strong&gt; morphisms from the &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that rely on them. That is, every jQuery method that manipulates the DOM has some form of an &lt;strong&gt;Html&lt;/strong&gt; morphism living inside it, be it inlined or abstracted into its own function (like &lt;code&gt;removeAttr&lt;/code&gt;). To illustrate we&#39;ll take a naive implementation of &lt;code&gt;jQuery.fn.addClass&lt;/code&gt; and separate the DOM manipulation out. First, the current norm as inlined functionality:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Jqry morphism&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;addClass&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token comment&quot;&gt;// !! Inlined DOM element manipulation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; oldClassVal &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;class&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; oldClassVal &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then, abstracted:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Jqry morphism&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;addClass&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token comment&quot;&gt;// !! Abstracted manipulation. Too expensive?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;		&lt;span class=&quot;token function&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Html morphism&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; oldClassVal &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;class&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	elem&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; oldClassVal &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;He rightly pointed out that from an architectural standpoint, this is a fairly compelling idea, so long as the extra function call doesn&#39;t affect performance too drastically. Taking &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; as the test subject again, I inlined the contents of &lt;code&gt;jQuery.removeAttr&lt;/code&gt; and compared it to the original. For small sets it appears that the extra function call is negligible&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6XOM0.png&quot; alt=&quot;extra function call&quot;&gt;&lt;/p&gt;
&lt;p&gt;Just to be sure, it&#39;s worth checking against larger jQuery object-sets. For large sets, as with loop fusion, the DOM manipulations outweigh something as fundamental as function invocation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/cTeMr.png&quot; alt=&quot;extra function call larger set&quot;&gt;&lt;/p&gt;
&lt;p&gt;You can see in both cases that the overhead of abstracting the DOM manipulation into a function is mostly tenable, the notable exception being smaller sets of elements in Opera. If that small additional overhead in the common case is acceptable it exposes some benefits that the library can provide to framework authors and performance-minded developers.&lt;/p&gt;
&lt;h2 id=&quot;architecture-benefits&quot;&gt;Architecture Benefits &lt;a class=&quot;direct-link&quot; href=&quot;#architecture-benefits&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Clearly, there are benefits from a clean separation for both the library itself and for advanced users relying on jQuery&#39;s inbuilt &amp;quot;experience&amp;quot; with browser compatibility. If the two sides are kept separate jQuery Core could provide a build target that only includes the DOM manipulation and reduces the overall size of the gzipped include. Mobile devices have made file size a serious concern (belaboring the obvious) not just because of wire weight but also parsing time, and the reduction of code in this case could be significant.&lt;/p&gt;
&lt;p&gt;What&#39;s more, external framework authors and other advanced users would have a more foundational building block to make use of without the commitment to the entire jQuery source. For example users who are happy to rely on &lt;code&gt;querySelectorAll&lt;/code&gt; (which enjoys relatively broad support) and who don&#39;t need selectors/effects/etc could simply use the distilled knowledge in this hypothetical DOM manipulation core.&lt;/p&gt;
&lt;p&gt;Less interesting for end-users is the benefit to the Core team in terms of separating concerns and testing. For the DOM manipulations this change delineates &lt;code&gt;jQuery.fn&lt;/code&gt; methods as a usability layer on top of the underlying &lt;strong&gt;Html&lt;/strong&gt; morphism. If you ascribe to the ideas that fall out of the dependency between the two categories then &lt;strong&gt;Jqry&lt;/strong&gt; has always had this role. Also, where testing is concerned, the DOM manipulation methods can be tested in isolation from the code that makes jQuery easy to use (with stubbing in the latter case).&lt;/p&gt;
&lt;h2 id=&quot;performance-benefits&quot;&gt;Performance Benefits &lt;a class=&quot;direct-link&quot; href=&quot;#performance-benefits&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Assuming a perfect world where every jQuery method involved in DOM element manipulation is built on an &lt;strong&gt;Html&lt;/strong&gt; morphism there are a couple of possible performance benefits. First, and least impactful is that it makes rewrapping DOM elements using the &lt;code&gt;$&lt;/code&gt;/&lt;code&gt;jQuery&lt;/code&gt; function unnecessary in many cases.&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;click&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token comment&quot;&gt;// Current popular idiom&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token comment&quot;&gt;// - In favor of -&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	&lt;span class=&quot;token comment&quot;&gt;// Using the underlying morphism&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;	$&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; event&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rewrapping DOM objects with a jQuery object in event and loop callbacks to get access to jQuery methods is common practice. If the same functionality on jQuery objects can be used to directly manipulate DOM elements, the rewrapping can be avoided all together. This isn&#39;t likely to be a huge win, but the reduction in setup for iterating over jQuery objects cannot be overlooked.&lt;/p&gt;
&lt;p&gt;Much more interesting though is the possibility of stripping down the functionality provided by the DOM element manipulations. That is, removing the user-friendly layer associated with many jQuery methods and only providing the cross platform working core of each manipulation could have a serious performance and size impact. Again, looking at the &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; implementation, it&#39;s built to accept a whitespace-delimited list for the attribute name value as a concession to terse manipulations.&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Friendly&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;#foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo bar&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Not-friendly?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;#foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;bar&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The performance benefits of using the manipulations directly without this additional feature are real. Simply stripping the split and loop from &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; provided nearly a 25% gain&lt;sup&gt;3&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wA8wf.png&quot; alt=&quot;friendliness&quot;&gt;&lt;/p&gt;
&lt;p&gt;Again, the jQuery method would retain all its old functionality. The proposed underlying morphism is a new API. It can stick to what it does best: cross-platform manipulation of DOM elements. When a user is concerned about performance they can start looking at the ways their application uses jQuery and leverage a less friendly but still beautiful &amp;quot;low-level&amp;quot; API for DOM manipulations to save execution time.&lt;/p&gt;
&lt;h2 id=&quot;beautiful-api-design&quot;&gt;Beautiful API Design &lt;a class=&quot;direct-link&quot; href=&quot;#beautiful-api-design&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the benefits in library size reduction a separate set of methods can provide, these methods should all be available on some top level namespace. &lt;code&gt;$&lt;/code&gt;/&lt;code&gt;jQuery&lt;/code&gt; may be the most obvious choice but this requires some consideration due to compatibility concerns with existing methods like &lt;code&gt;jQuery.removeAttr&lt;/code&gt; and &lt;code&gt;jQuery.css&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;More importantly it might be useful, as suggested in the previous posts, to provide the method as an attribute of its associated jQuery method. That is, &lt;code&gt;jQuery.removeAttr&lt;/code&gt; would exist on the &lt;code&gt;jQuery&lt;/code&gt; object and also as something like &lt;code&gt;jQuery.fn.removeAttr.domManip&lt;/code&gt; or &lt;code&gt;jQuery.fn.removeAttr.alterOne&lt;/code&gt;&lt;sup&gt;4&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;To illustrate, let&#39;s look at an example with two conversions of a simple method chain assuming the jQuery function as the pure DOM manipulation namespace:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 1. Unoptimized&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;data-foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;bar&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;background-color&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;red&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 2. Optimized with jQuery.fn.each&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token function&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token comment&quot;&gt;// without check for null to remove, and hooks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;data-foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;bar&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token comment&quot;&gt;// without hook&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;background-color&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;red&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 3. Optimized in a while loop to avoid extra calls&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; $divs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;div&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;    length &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; $divs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;    elem&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; length&lt;span class=&quot;token operator&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  elem &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; $divs&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;elem&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token comment&quot;&gt;// without check for null to remove, and hooks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;data-foo&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;bar&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  &lt;span class=&quot;token comment&quot;&gt;// without hook&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  jQuery&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;background-color&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;red&#39;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;what-happened-to-the-math%3F&quot;&gt;What happened to the Math? &lt;a class=&quot;direct-link&quot; href=&quot;#what-happened-to-the-math%3F&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Long story short: I&#39;m looking into it. There is certainly a dependent relationship between the set of &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that operate on the contents of &lt;strong&gt;Jqry&lt;/strong&gt; objects (remember there are &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that don&#39;t, eg. &lt;code&gt;jQuery.fn.first&lt;/code&gt; only alters the container) and the underlying &lt;strong&gt;Html&lt;/strong&gt; morphisms. That subset of morphisms and all jQuery objects may form a subcategory &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tTwkz.png&quot; alt=&quot;jquery sub h equation&quot;&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;em&gt;F&lt;/em&gt; is the functor previously defined (eq 1), the objects of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are the objects of &lt;strong&gt;Jqry&lt;/strong&gt; (eq 3) and the morphisms of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are &lt;strong&gt;Html&lt;/strong&gt; morphisms lifted into &lt;strong&gt;Jqry&lt;/strong&gt; with &lt;em&gt;F&lt;/em&gt; (eq 3). Do note that morphisms of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are a proper subset of &lt;strong&gt;Jqry&lt;/strong&gt; because of methods like &lt;code&gt;jQuery.fn.first&lt;/code&gt; (eq 4).&lt;/p&gt;
&lt;p&gt;I&#39;m sure there&#39;s a more elegant way to represent the two sets, objects and morphisms, of this subcategory but this works for me now. Also, it&#39;s not clear that there are useful practical implications for the dependency aside from how it might otherwise affect our perception of jQuery as a library. I intend to look into this a bit more when I have time.&lt;/p&gt;
&lt;h2 id=&quot;further-investigation-required&quot;&gt;Further Investigation Required &lt;a class=&quot;direct-link&quot; href=&quot;#further-investigation-required&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If the goals presented here turn out to be of real value there&#39;s a lot of work left to do. Most importantly the performance overhead of an extra function call in so many jQuery methods needs to be examined thoroughly, not just in jQuery Core but in dependent projects like UI, Mobile, and possibly plugins. Hopefully the initial impression of fast function calls bears out in further testing.&lt;/p&gt;
&lt;p&gt;It would also be useful to examine the conversion of some complex applications to the &lt;strong&gt;Html&lt;/strong&gt; morphisms to see what kind of cognitive overhead is incurred. If no one wants to use the underlying functions because they are a pain, then the exercise would be futile. This examination should includes aspects like namespacing and how each function is made available to the end user in both the full and &amp;quot;stripped down&amp;quot; builds.&lt;/p&gt;
&lt;p&gt;Ultimately the ideas here are a rough sketch.&lt;/p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;To be totally clear this isn&#39;t a jab at the core team. I&#39;m under the impression that the readings are really entertaining. Moreover the talks at conferences are rarely really interesting to the presenters in my experience. Most of the time you can find them chatting/hacking in the halls, which might indicate some level of boredom with the material and may even be a leading indicator of when someone is ready to start submitting talk proposals in terms of experience/content knowledge.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Appears&lt;/em&gt; is the key word here. More testing in varied situations is really required to make sure this small sample set is consistent with other jQuery methods.&lt;/li&gt;
&lt;li&gt;The benefits here will vary widely depending on the complexity of the &amp;quot;user-friendliness&amp;quot; built into a given jQuery method. Disclaim all the things!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alterOne&lt;/code&gt; was, again, suggested by Yehuda during our discussion.&lt;/li&gt;
&lt;li&gt;The reader will have noted the conspicuous absence of IE in my performance test results. For whatever reason there was a consistent exception raised when executing the test code in IE that I haven&#39;t had time to investigate. For serious consideration of the content in this post those numbers need to be included.&lt;/li&gt;
&lt;li&gt;perf links: &lt;a href=&quot;http://jsperf.com/chained-sequence-or-composition-removeattr/2&quot;&gt;chained, sequence, or composed&lt;/a&gt;, &lt;a href=&quot;http://jsperf.com/user-friendliness-overhead-for-remove-attr/2&quot;&gt;user friendlyness overhead&lt;/a&gt;, &lt;a href=&quot;http://jsperf.com/additional-function-call-overhead-for-remove-attr/3&quot;&gt;additional function call overhead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Special thanks to &lt;a href=&quot;http://twitter.com/keyist&quot;&gt;Tim Goh&lt;/a&gt; for reviewing this post.&lt;/li&gt;
&lt;/ol&gt;
</content>
	</entry>
	
	<entry>
		<title>Faster JavaScript through Category Theory</title>
		<link href="https://johnbender.us/posts/2013-08-29-presentation-faster-javascript-through-category-theory/"/>
		<updated>2013-08-29T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2013-08-29-presentation-faster-javascript-through-category-theory/</id>
		<content type="html">&lt;p&gt;&lt;b&gt;Update&lt;/b&gt; My final presentation of the material from JQuery UK has been posted. On a personal note the venue and speakers made for an awesome setting to retire this talk.&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;http://player.vimeo.com/video/71132093&quot; width=&quot;100%&quot; height=&quot;340&quot; frameborder=&quot;0&quot; webkitAllowFullScreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowFullScreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://vimeo.com/album/2509484/video/71132093&quot; class=&quot;video-link&quot;&gt;View video on Vimeo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update&lt;/b&gt; My presentation of the revised material from JSCONFEU 2012 has been posted. Thanks again the &lt;a href=&quot;http://twitter.com/jsconfeu&quot;&gt;@jsconfeu&lt;/a&gt; crew for puting on one of the best conferences I&#39;ve yet been to.&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&quot;100%&quot; height=&quot;340&quot; src=&quot;http://www.youtube.com/embed/PtD-WKSC6ak&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://www.youtube.com/watch?v=PtD-WKSC6ak&quot; class=&quot;video-link&quot;&gt;View video on Youtube&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;My presentation at JQCON 2012. Thanks again to the good folks from &lt;a href=&quot;http://twitter.com/confreaks&quot;&gt;@confreaks&lt;/a&gt; for all the hard work they do.&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&quot;100%&quot; height=&quot;340&quot; src=&quot;http://www.youtube.com/embed/u-_lZ2G82Rk&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://www.youtube.com/watch?v=u-_lZ2G82Rk&quot; class=&quot;video-link&quot;&gt;View video on Youtube&lt;/a&gt;&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Why I&#39;m Getting a PhD</title>
		<link href="https://johnbender.us/posts/2013-09-16-why-im-getting-a-phd/"/>
		<updated>2013-09-16T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2013-09-16-why-im-getting-a-phd/</id>
		<content type="html">&lt;p&gt;The 26th is the first day of instruction in the first academic year of my PhD in Computer Science at UCLA. I have a two year old daughter, an incredibly supportive wife, and I just turned 30.&lt;/p&gt;
&lt;p&gt;Unsurprisingly, I&#39;ve been asked many times why I want to get a PhD and I rarely get a chance to explain my thinking fully. This post is both a detailed account of my reasons and a counterpoint to the popular opinion that there isn&#39;t much value in higher education in Computer Science.&lt;/p&gt;
&lt;h2 id=&quot;why-bother%3F&quot;&gt;Why Bother? &lt;a class=&quot;direct-link&quot; href=&quot;#why-bother%3F&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Any confusion or surprise over my decision to go back to school can generally be reduced to a simple idea: the success I would otherwise have while getting my PhD is of greater absolute value than the education.&lt;/p&gt;
&lt;p&gt;This comes in many reasonable forms. Why are you leaving such a high paying job? Will you be able to speak at conferences? When will you find time to contribute to open source? Couldn&#39;t you just work on those ideas in your free time? These questions are asked directly and without implication.&lt;/p&gt;
&lt;p&gt;In some cases there is a subtle suggestion that academia and higher education are losing their value. Why would someone pursue a PhD when there are people without any higher education earning comparable salaries and working on important projects? I never hear this asked explicitly, but it comes through in many conversations and the idea that education isn&#39;t important is pervasive in the software &amp;quot;meritocracy&amp;quot;.&lt;/p&gt;
&lt;p&gt;In each case, I&#39;m consistently left wanting more time to describe my thinking and the personal experiences that landed me in a PhD program.&lt;/p&gt;
&lt;h2 id=&quot;career-path&quot;&gt;Career Path &lt;a class=&quot;direct-link&quot; href=&quot;#career-path&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I got my first legitimate management position as the director of engineering at a consultancy/incubator it quickly became clear that management wasn&#39;t for me. I enjoyed seeing my teammates succeed. I enjoyed building and refining Process. I enjoyed winning business. I enjoyed the subtleties of communicating complex technical ideas to people with all types of backgrounds and experience. By my own estimation I was even pretty good at all those things.&lt;/p&gt;
&lt;p&gt;The thing that got to me was the amount of time I spent staring at my email client. After a year I missed the technical aspects of the job, and I started to think about my long-term career options. At the time I saw three paths that didn&#39;t route back through school.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Avoid titles and stick with engineering&lt;/strong&gt; This was, at least initially, the path I took. I left for Adobe and a position working full time on jQuery Mobile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grab the title and climb the ladder&lt;/strong&gt; Management positions pay a lot of money, and there&#39;s a lot of room for advancement. Not all require you to hand over your keyboard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Employee Number One or Co-Founder&lt;/strong&gt; First employee/Co-Founder positions are available for experienced &amp;quot;generalists&amp;quot; as far as I can tell. This is purely based on personal observations and conversation with friends who are better informed on the topic.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, there are a lot of subtle variants to each of these, but this was my assessment. I can say with confidence that my move to Adobe put me in an ideal engineering position. Working on an OSS project full time gave me the freedom to pursue long term solutions to difficult problems and I still had access to the good parts of a large corporate support infrastructure.&lt;/p&gt;
&lt;p&gt;Unfortunately, the problems I gravitate towards are not normally assigned to engineers and attempts to marry my interests with my domain of expertise [1,2] have met with understandably tepid responses. The ideas are hard to follow in short presentations, most people don&#39;t have time to read marathon blog posts, and the underlying work isn&#39;t funded by my employer. All of that makes perfect sense but it means I can&#39;t focus on the problems that I&#39;m interested in.&lt;/p&gt;
&lt;h2 id=&quot;what-interests-me&quot;&gt;What Interests Me &lt;a class=&quot;direct-link&quot; href=&quot;#what-interests-me&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The things that keep me up past midnight working and learning are technical. Problems both large and small that remain unsolved or problems where the solution seems unsatisfactory to me. A short and incomplete list in no particular order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Descriptive declarative languages that aren&#39;t&lt;/li&gt;
&lt;li&gt;Correctness in dynamic languages&lt;/li&gt;
&lt;li&gt;System configuration and state management&lt;/li&gt;
&lt;li&gt;Adoption, understanding, and value of advanced type systems&lt;/li&gt;
&lt;li&gt;Direct applications of mathematics to programming languages&lt;/li&gt;
&lt;li&gt;Semantics based approaches to hot code loading&lt;/li&gt;
&lt;li&gt;Preventing language bugs/quirks during language creation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A few of these might align with a job posting somewhere but most don&#39;t. More importantly, I&#39;m not as interested in the implementation as I am in conceiving a solution and understanding its value. I&#39;m sure that will sound like laziness to some, but the part I enjoy the most is thinking through the idea. Most of the time an implementation is an important part of that, and I enjoy hacking as much as anyone, but sometimes it&#39;s not. Sometimes a more abstract representation of the problem is the best way to predict the relative value of a solution before committing time and effort to an implementation. Again, this isn&#39;t the type of work that engineers get funded to do.&lt;/p&gt;
&lt;h2 id=&quot;on-academia&quot;&gt;On Academia &lt;a class=&quot;direct-link&quot; href=&quot;#on-academia&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Perception of academia varies depending on the field and an individual&#39;s cultural disposition. In the software community there is a certain sense of respect for the research and science on which our careers are built. People have even sort of deified greats like Alan Kay, Alonzo Church, and Alan Turing.&lt;/p&gt;
&lt;p&gt;More and more though, the word &amp;quot;academic&amp;quot; is being used as a pejorative to mean irrelevant, unimportant, or a wasted effort. It&#39;s easy to wave this away as an issue of sloppy semantics but I think it highlights the suffering perception of academics. In my experience working on research projects and doing a lot of reading over the last few years, much of the stigma appears to result from two issues. The first is, what people think research should be for, and the second is the occasionally impenetrable nature of formalism.&lt;/p&gt;
&lt;p&gt;Computer Science research is frequently accompanied by proof of concept software. It might be poorly constructed, hard to get working, or even hard to find. In turn, that can lead to a poor opinion of the research and researchers, but the implementations are rarely the primary contribution of the work. The goal of the researcher is &lt;em&gt;not&lt;/em&gt; to provide implementations or information directly to industry, but rather to produce a solution to an outstanding problem. The work of translating that solution into something &amp;quot;well built&amp;quot; or even concrete is frequently left to the reader.&lt;/p&gt;
&lt;p&gt;Unfortunately, reading Computer Science papers can be hard work. The deluge of notation can be discouraging. It can even seem like unnecessary ceremony, but a lot of ground has to be covered in the limited space provided for conference publications. Moreover, formalism and logic are the most important tools we have when streamlining and finding consensus on a good solution. In a perfect world all the necessary context would be easily accessible, and the formal tools used to establish properties of a solution would be easy to understand. Sadly that&#39;s not the case, but it doesn&#39;t diminish the value of the &amp;quot;encoded&amp;quot; contribution.&lt;/p&gt;
&lt;p&gt;It&#39;s &lt;em&gt;because&lt;/em&gt; of these things and not in spite of them that I&#39;m going back to school. I want to work in an environment that explicitly promotes a focus on the fundamentals of a problem and requires that the utmost care be taken when presenting a solution.&lt;/p&gt;
&lt;h2 id=&quot;the-fourth-path&quot;&gt;The Fourth Path &lt;a class=&quot;direct-link&quot; href=&quot;#the-fourth-path&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I guess you could say I&#39;m taking The Fourth Path™.&lt;/p&gt;
&lt;p&gt;While I may be new to the academic environment, I have taken efforts to ensure that my impressions are not naive. I have been working on research projects since last year with folks at UCLA and I have been attending regular reading groups. I also know what problems I want to work on; one of which I&#39;m pursuing with a strong blessing from my adviser.&lt;/p&gt;
&lt;p&gt;Even if this doesn&#39;t turn out as planned, at least I know that the &amp;quot;what&amp;quot; and &amp;quot;how&amp;quot; of my work will fit and that&#39;s why I&#39;m getting a PhD.&lt;/p&gt;
&lt;br&gt;
&lt;h3 id=&quot;acknowledgments&quot;&gt;Acknowledgments &lt;a class=&quot;direct-link&quot; href=&quot;#acknowledgments&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/keyist&quot;&gt;@keyist&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/melliebe&quot;&gt;@melliebe&lt;/a&gt; for their notes and revisions.&lt;/p&gt;
&lt;p&gt;Special thanks to &lt;a href=&quot;http://philipmjohnson.wordpress.com/&quot;&gt;Professor Philip M. Johnson&lt;/a&gt; who has helped me continuously since I graduated from the University of Hawaii more than seven years ago. His advice has been extremely important in my long and winding path back to academia.&lt;/p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://johnbender.us/2013/08/29/presentation-faster-javascript-through-category-theory/&quot;&gt;Presentation: Faster JavaScript through Category Theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://johnbender.us/2013/07/19/presentation-math-envy-and-coffeescripts-foibles/&quot;&gt;Presentation: Math Envy and CoffeeScript&#39;s Foibles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;Less&amp;quot; is not, &amp;quot;not at all&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I also have a short list of things I&#39;m &lt;em&gt;not&lt;/em&gt; interested in. I intended to include this in the main body of the post but it seemed like a distraction.&lt;/p&gt;
&lt;p&gt;As a web developer and someone who&#39;s worked almost exclusively on the client side for the last few years I have a fairly long list of things that do not interest me or are an active source of frustration. Nearly all of them would be impossible to describe as &amp;quot;general&amp;quot; problems.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Esoteric browser bugs (yes they still exist in abundance)&lt;/li&gt;
&lt;li&gt;The culture/necessity of JavaScript micro-libraries&lt;/li&gt;
&lt;li&gt;Effort required to provide broad access to web based content&lt;/li&gt;
&lt;li&gt;Dynamic programming languages as an industry default&lt;/li&gt;
&lt;li&gt;Non-transferable esoterica (e.g., how iptables works on CentOS, Chef&#39;s attribute resolution order)&lt;/li&gt;
&lt;li&gt;Large JavaScript projects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&#39;m not above working on, or around, these problems. For a web developer many of these are simply facts of life. I&#39;m just not content to let them bother me indefinitely which means contributing to solutions or moving on.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>A Better SQL</title>
		<link href="https://johnbender.us/posts/2013-11-04-a-better-sql/"/>
		<updated>2013-11-04T00:00:00-08:00</updated>
		<id>https://johnbender.us/posts/2013-11-04-a-better-sql/</id>
		<content type="html">&lt;p&gt;The relational model for data is ubiquitous. That&#39;s in part due to SQL&#39;s declarative approach to manipulating and exploring data stored as relations. Unfortunately SQL has its warts. In particular schema changes made in the data definition subset of the language (DDL) [1] can be awkward for creating idempotent migrations. Enough so, that the responsibility is frequently delegated to the application layer where more expressive languages can be employed. Here I&#39;ll lay out an alternate semantics for SQL DDL that embraces schema change and expands the expressive power of DDL&#39;s declarative core.&lt;/p&gt;
&lt;h2 id=&quot;a-common-activity&quot;&gt;A Common Activity &lt;a class=&quot;direct-link&quot; href=&quot;#a-common-activity&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To illustrate how schema changes break the initially declarative semantics of DDL, lets look at an example:&lt;/p&gt;
&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  bar &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  baz &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All tables start this way. The only piece of syntax that might otherwise alert a new user to the fact that this is not an entirely descriptive declarative language is &lt;code&gt;create&lt;/code&gt;. The definition is very much &amp;quot;what&amp;quot; is desired and not &amp;quot;how&amp;quot; to get it. This breaks down when anything about the table needs to change:&lt;/p&gt;
&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;exists&lt;/span&gt; foo &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  bar &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  baz &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;column&lt;/span&gt; bak &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All together this will ensure the proper end-state whether the target database is at the initial state without the table &lt;code&gt;foo&lt;/code&gt; or at the second state where &lt;code&gt;foo&lt;/code&gt; lacks the column &lt;code&gt;bak&lt;/code&gt;. In this case it&#39;s easy to understand the final state of the table because the example is very simple, but it&#39;s acquired an imperative pall with the inclusion of the first &lt;code&gt;alter&lt;/code&gt;. As the schema definition grows more complex through many &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, and type cast changes, the final state of the table becomes less clear:&lt;/p&gt;
&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;exists&lt;/span&gt; foo &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  bar &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  baz &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;column&lt;/span&gt; bak &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token keyword&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;column&lt;/span&gt; bak &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;column&lt;/span&gt; baks &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It would be better to simply add columns to the original table definition, and then the shape of the resulting table would be immediately clear at a glance.&lt;/p&gt;
&lt;h2 id=&quot;differential-semantics&quot;&gt;Differential Semantics &lt;a class=&quot;direct-link&quot; href=&quot;#differential-semantics&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In our toy example the desired table definition included a new column &lt;code&gt;bak&lt;/code&gt;. An entirely descriptive update to the table declaration would look like this (Note that the original alter statement is absent):&lt;/p&gt;
&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;table&lt;/span&gt; foo &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  bar &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  baz &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;  bak &lt;span class=&quot;token keyword&quot;&gt;text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately the SQL runtime considers the syntax in isolation and makes no attempt to reconcile that with it&#39;s internal representation. That makes perfect sense because a user is permitted to run small, ad hoc snippets in addition to full schema migration scripts. That is, the RDBMS can&#39;t know where this declaration is coming from nor why it&#39;s being run so it&#39;s unsafe to assume it should do any reconciliation. In contrast a well outfitted user can provide exactly that information.&lt;/p&gt;
&lt;pre class=&quot;language-diff&quot;&gt;&lt;code class=&quot;language-diff&quot;&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token coord&quot;&gt;@@ -1,4 +1,5 @@&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt; create table foo (l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;   bar int,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token deleted&quot;&gt;-  baz text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token inserted&quot;&gt;+  baz text,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt;&lt;span class=&quot;token inserted&quot;&gt;+  bak text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;highlight-line&quot;&gt; );&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the diff, it&#39;s clear that the intention is to add the column &lt;code&gt;bak&lt;/code&gt; to the table. What&#39;s required then, is to assign some semantics to this diff. With that established a simple pre-processor could map this differential to the corresponding alter statement in DDL, namely the original alter statement.&lt;/p&gt;
&lt;p&gt;The key insight here is that we can permit schema migrations while retaining an entirely descriptive declarative syntax by appealing to the differential information available via source control tools.&lt;/p&gt;
&lt;h2 id=&quot;value-proposition&quot;&gt;Value Proposition &lt;a class=&quot;direct-link&quot; href=&quot;#value-proposition&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The basic value proposition is reduced cognitive overhead when maintaining schemas using SQL DDL. In addition, DDL&#39;s syntax is reduced by about half because alters and drops [2] can simply go away which should make it easier to learn [3].&lt;/p&gt;
&lt;p&gt;This could also be pushed up the stack to migration tools by an enterprising library or framework author. For example, Rails generates and maintains a &lt;code&gt;db/schema.rb&lt;/code&gt; file that is supposed to represent the state of the schema for the associated migrations. A similar technique could be applied there to divine the appropriate alterations when an change to that file is made in place of using migrations for schema changes.&lt;/p&gt;
&lt;p&gt;Finally, by associating meaning with syntactic change the user can more safely understand and execute post commit reverts to schema changes. That is, instead of manually defining the necessary steps to &amp;quot;undo&amp;quot; some previous schema change, the source control system can provide the exact information that is necessary.&lt;/p&gt;
&lt;h2 id=&quot;pitfalls&quot;&gt;Pitfalls &lt;a class=&quot;direct-link&quot; href=&quot;#pitfalls&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Obviously, not every migration is just about the schema. Frequently the data has to be altered to conform to the target schema. This is actually an area of active research in the Database Systems community [4].&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion &lt;a class=&quot;direct-link&quot; href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For the interested reader, I started work on a &lt;a href=&quot;https://github.com/johnbender/sql-delta&quot;&gt;preprocessor&lt;/a&gt; implemented in Haskell. Unfortunately since I don&#39;t have any plans to pursue this further I haven&#39;t been working on it. Also, for comparison I&#39;ve included two very simple sets of denotational semantics in the footnotes; one to represent the current implementation and one to represent the differential semantics [5]. They highlight the symmetry of this new approach to the language when compared with the current implementation.&lt;/p&gt;
&lt;p&gt;This technique can be extended to other languages that manage system state declaratively like configuration management DSLs or even HTML. Though in the case of configuration management, understanding the mapping between syntax and state is quite complex because system components frequently generate artifacts that are not explicitly declared.&lt;/p&gt;
&lt;p&gt;Broadly, the idea of differential semantics is to gather more information about intent from readily available sources so that language runtimes (declarative or otherwise) can make more informed decisions about user intent. The results need not be confined to accurate interpretation of the desired system state.&lt;/p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_definition_language&quot;&gt;http://en.wikipedia.org/wiki/Data_definition_language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;In our example a drop would be accomplished by removing the table definition completely.&lt;/li&gt;
&lt;li&gt;The mapping presumes feature parity in the create with the alter statements, but in my study of the standard and Postgres&#39; implementation this appears to be the case.&lt;/li&gt;
&lt;li&gt;There&#39;s a lot of interesting work and tooling around preventing issues resulting from schema migrations: &lt;a href=&quot;http://scholar.google.com/scholar?q=prism+schema+evolution&amp;amp;btnG=&amp;amp;hl=en&amp;amp;as_sdt=0%2C5&quot;&gt;schema evolution&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A denotational semantics for both the current DDL semantics and the proposed semantics. Note that in the proposed section the &amp;quot;differential&amp;quot; semantics eval function is parameterized by the state of the syntax: &lt;a href=&quot;https://speakerdeck.com/johnbender/sql-ddl-differential-semantics&quot;&gt;PDF&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
	</entry>
	
	<entry>
		<title>Differential Semantics</title>
		<link href="https://johnbender.us/posts/2014-04-07-presentation-differential-semantics/"/>
		<updated>2014-04-07T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2014-04-07-presentation-differential-semantics/</id>
		<content type="html">&lt;p&gt;
  A quick presentation I gave to my CS 239, Spring 2014 on my early thinking around deriving programmer intent from source control and program evolution.
&lt;/p&gt;
&lt;p style=&quot;margin-top: 2em
;&quot;&gt;
  &lt;script async=&quot;&quot; class=&quot;speakerdeck-embed&quot; data-id=&quot;af35e490a0b00131f6cb2abc05ca10ad&quot; data-ratio=&quot;1.33333333333&quot; src=&quot;https://speakerdeck.com/assets/embed.js&quot;&gt;&lt;/script&gt;
&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>NP-complete: how hard is that climb?</title>
		<link href="https://johnbender.us/posts/2014-06-22-complexity-how-hard-is-that-climb/"/>
		<updated>2014-06-22T00:00:00-07:00</updated>
		<id>https://johnbender.us/posts/2014-06-22-complexity-how-hard-is-that-climb/</id>
		<content type="html">&lt;p&gt;The purpose of this post is to clarify the difference between &lt;strong&gt;NP&lt;/strong&gt;-hard and &lt;strong&gt;NP&lt;/strong&gt;-complete problems for developers who, like me, have found that the abstract nature of the definitions make developing an intuition for it difficult.&lt;/p&gt;
&lt;h2 id=&quot;climbing-a-mountain&quot;&gt;Climbing a Mountain &lt;a class=&quot;direct-link&quot; href=&quot;#climbing-a-mountain&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Imagine that a friend came to you and said that she would like you plan a trip up an obscure mountain,  &lt;strong&gt;X&lt;/strong&gt;. Obviously you need to know how difficult the trip is going to be to do a good job. If it&#39;s only a quick day hike to the top you probably just need some sandwiches and water, but if it&#39;s a multi-week expedition then you&#39;ll need a more comprehensive set of supplies.&lt;/p&gt;
&lt;p&gt;Further, imagine that you are unable to find any information about the difficulty of climbing up mountain &lt;strong&gt;X&lt;/strong&gt;! Your intuitive reaction would probably be to find &lt;em&gt;comparable&lt;/em&gt; mountains to get a sense for the difficulty of mountain &lt;strong&gt;X&lt;/strong&gt; using some sort of comparison. Fortunately, right near by there is a mountain &lt;strong&gt;Y&lt;/strong&gt; that is well known. In fact it&#39;s close enough that a comparison by height (which we&#39;ll use as our proxy for difficulty) is possible save for that fact that peak of mountain &lt;strong&gt;X&lt;/strong&gt; is constantly covered by clouds.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/x-obscured.png&quot; alt=&quot;X mountain obscured&quot;&gt;&lt;/p&gt;
&lt;p&gt;All we really know about mountains &lt;strong&gt;X&lt;/strong&gt; and &lt;strong&gt;Y&lt;/strong&gt; is that &lt;strong&gt;X&lt;/strong&gt; is at least as tall as &lt;strong&gt;Y&lt;/strong&gt; and therefore at least as difficult. We need to get some sense for how difficult mountain &lt;strong&gt;Y&lt;/strong&gt; is so that we can then infer something useful about mountain &lt;strong&gt;X&lt;/strong&gt;. Since we&#39;re using vision as our measuring device our system of classification is going to be fairly coarse. That is, if we&#39;re positive a mountain can be scaled in a day (think, large hill) then it&#39;s probably visually pretty small and if it&#39;s going to be on the order of a few weeks then it probably looks pretty serious (think, K2).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/d-vs-wd.png&quot; alt=&quot;Days vs Weeks and Days&quot;&gt;&lt;/p&gt;
&lt;p&gt;Lets call these two classes of mountains &lt;strong&gt;D&lt;/strong&gt; and &lt;strong&gt;WD&lt;/strong&gt;, for &amp;quot;Day&amp;quot; and &amp;quot;Weeks and Days&amp;quot;. When a mountain will take at least a day to hike we say it&#39;s &lt;strong&gt;D&lt;/strong&gt;-hard. When it will take at least weeks and days to hike then we say it&#39;s &lt;strong&gt;WD&lt;/strong&gt;-hard. So if mountain &lt;strong&gt;Y&lt;/strong&gt; is &lt;strong&gt;D&lt;/strong&gt;-hard then clearly mountain &lt;strong&gt;X&lt;/strong&gt; is at least &lt;strong&gt;D&lt;/strong&gt;-hard and similarly so if &lt;strong&gt;Y&lt;/strong&gt; is &lt;strong&gt;WD&lt;/strong&gt;-hard.&lt;/p&gt;
&lt;p&gt;Lets assume that &lt;strong&gt;Y&lt;/strong&gt; is &amp;quot;Weeks and Days&amp;quot;-hard, and that means we know that &lt;strong&gt;X&lt;/strong&gt; is too because it&#39;s at least as big as &lt;strong&gt;Y&lt;/strong&gt;. But there&#39;s still a problem, we don&#39;t know &lt;em&gt;exactly&lt;/em&gt; how big mountain &lt;strong&gt;X&lt;/strong&gt; is since the top is obscured by clouds. We only know that it&#39;s as as least as hard as &lt;strong&gt;Y&lt;/strong&gt; to climb. If &lt;strong&gt;X&lt;/strong&gt; ends up being as tall as Olympus Mons we should probably just forget it. So, on a clear day when the top of mountain &lt;strong&gt;X&lt;/strong&gt; is visible and comparable to the top of mountain &lt;strong&gt;Y&lt;/strong&gt; you take a look and verify that mountain &lt;strong&gt;X&lt;/strong&gt; is roughly the same size as mountain &lt;strong&gt;Y&lt;/strong&gt;. Now we say that mountain &lt;strong&gt;X&lt;/strong&gt; is &lt;strong&gt;WD&lt;/strong&gt;-complete. That is, we know it&#39;s at least as hard as another &amp;quot;Weeks and Days&amp;quot; mountain and we feel confident that it will &lt;em&gt;only&lt;/em&gt; take weeks and days and not, for instance, months and years.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/x-visible.png&quot; alt=&quot;X visible&quot;&gt;&lt;/p&gt;
&lt;p&gt;This is really great for a couple of reasons. First, we have enough information to start planning a trip to the top of mountain &lt;strong&gt;X&lt;/strong&gt;. Second, because we&#39;ve classified mountain &lt;strong&gt;X&lt;/strong&gt; as being both &lt;strong&gt;WD&lt;/strong&gt;-hard and &amp;quot;in&amp;quot; the class of &lt;strong&gt;WD&lt;/strong&gt; mountains it stands as an exemplar of that class of mountain, which means we can use it to classify other mountains, in the same way we did with mountain &lt;strong&gt;Y&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;p%2C-np%2C-np-hard%2C-np-complete&quot;&gt;&lt;strong&gt;P&lt;/strong&gt;, &lt;strong&gt;NP&lt;/strong&gt;, &lt;strong&gt;NP&lt;/strong&gt;-hard, &lt;strong&gt;NP&lt;/strong&gt;-complete &lt;a class=&quot;direct-link&quot; href=&quot;#p%2C-np%2C-np-hard%2C-np-complete&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While you may not be a climbing fan, this serves to illustrate the basic process of establishing when a decision problem is &lt;strong&gt;NP&lt;/strong&gt;-complete by &amp;quot;comparison&amp;quot;. To make the analogy clear we&#39;ll define, &lt;strong&gt;P&lt;/strong&gt;, &lt;strong&gt;NP&lt;/strong&gt;, &lt;strong&gt;NP&lt;/strong&gt;-hard and &lt;strong&gt;NP&lt;/strong&gt;-complete and link them to the analogy. First though we need to establish exactly what a decision problem is and how Turing machines fit in so that the definitions will make more sense.&lt;/p&gt;
&lt;p&gt;NP-hard problems like &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;The Traveling Salesman&lt;/a&gt; ( &lt;strong&gt;TSP&lt;/strong&gt; ) are often characterized in their optimization form. In this case the problem is to find the &lt;em&gt;shortest possible route&lt;/em&gt; that visits all cities. The decision version is subtly different. The question is changed to whether there exists a path, less than or equal to some length, that visits all the cities. More formally:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a graph of cities &lt;code&gt;G&lt;/code&gt; and a length of trip &lt;code&gt;l&lt;/code&gt;, is the pair &lt;code&gt;&amp;lt;G, l&amp;gt;&lt;/code&gt; in &lt;strong&gt;TSP&lt;/strong&gt;? Where &lt;strong&gt;TSP&lt;/strong&gt; is the set of all graphs and lengths for which the graph has a trip of length less than or equal to its paired &lt;code&gt;l&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If an algorithm can tell you whether an arbitrary pair &lt;code&gt;&amp;lt;G, l&amp;gt;&lt;/code&gt; is in &lt;strong&gt;TSP&lt;/strong&gt; we say that the algorithm &amp;quot;decides&amp;quot; &lt;strong&gt;TSP&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The distinction between these two characterizations may seem like a minor detail especially given that solving the optimization version gives you an answer to the decision version. Later we&#39;ll see the fact that the decision version has a yes or no answer is important when we talk about a problem being &amp;quot;in &lt;strong&gt;NP&lt;/strong&gt;&amp;quot; in the same way that mountain &lt;strong&gt;X&lt;/strong&gt; was discovered to be &amp;quot;in &lt;strong&gt;WD&lt;/strong&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;The final bit of required preamble is the Turing machine. I am going to assume some familiarity with Turing machines for the sake of space but when we talk about algorithms and their complexity we&#39;re talking about those algorithms and a corresponding Turing machine. The choice of the Turing machine as the model for discussions in complexity is due to it&#39;s incredibly robust and universal nature [1] though we won&#39;t explore that here. In particular we can feel confident that when we say a Turing machine operates in polynomial time it isn&#39;t due to some cleverness that we employed in the construction of the Turing machine [2].&lt;/p&gt;
&lt;h2 id=&quot;polynomial-time&quot;&gt;Polynomial Time &lt;a class=&quot;direct-link&quot; href=&quot;#polynomial-time&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Informally the class &lt;strong&gt;P&lt;/strong&gt; is the class of problems that can be solved in polynomial time, or in other words the class of problems that can be solved in a number of steps that is a polynomial function of the size of the input. A slightly more formal definition of polynomial time problems:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A problem is in &lt;strong&gt;P&lt;/strong&gt; if there exists a Turing machine that can decide an instance of the problem in a number of steps that is a polynomial function of the size of the input.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Again, deciding a problem means determining an instance&#39;s inclusion in the set for the problem (eg, whether a graph and length &lt;code&gt;&amp;lt;G, l&amp;gt;&lt;/code&gt; are in &lt;strong&gt;TSP&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;In terms of our analogy, &lt;strong&gt;P&lt;/strong&gt; corresponds with the day hike category, &lt;strong&gt;D&lt;/strong&gt;. That is, efficiently solvable problems equate with easily hikeable mountains. I think it&#39;s initially hard to swallow polynomial functions like n&lt;sup&gt;5&lt;/sup&gt; as &amp;quot;efficient&amp;quot; since they can clearly grow quite quickly with the size of the input. The key is that polynomial time functions represent some sort of cleverness in finding a solution. With a polynomial time function it&#39;s certainly &lt;em&gt;not&lt;/em&gt; the case that all the possibilities for a given input have to be tried to determine the answer.&lt;/p&gt;
&lt;h2 id=&quot;non-deterministic-polynomial-time&quot;&gt;Non-deterministic Polynomial Time &lt;a class=&quot;direct-link&quot; href=&quot;#non-deterministic-polynomial-time&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Contrary to the section title we&#39;re going to use the more popular definition of &lt;strong&gt;NP&lt;/strong&gt;, which is that of a verifying Turing machine that can take an instance of a problem and some &amp;quot;certificate&amp;quot; that convinces the Turing machine to decide positively for the instance. This definition and that of the non-deterministic polynomial time Turing machine are equivalent [3] but the first requires a less detailed discussion of Turing machine so we adopt it here.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A problem is in &lt;strong&gt;NP&lt;/strong&gt; if there exists a Turing machine that can decide an instance of the problem in polynomial time given a certificate of size polynomial in the size of the instance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Instead of solving the problem directly, problems in &lt;strong&gt;NP&lt;/strong&gt; require a Turing machine that can check the problem given some extra information. In most (all?) cases the certificate is the solution to the problem. For the traveling salesmen, the certificate would be a path that covers all cities in &lt;code&gt;G&lt;/code&gt; that has a total length less than or equal to &lt;code&gt;l&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that the certificate must be polynomial in the size of the problem instance or the Turing machine wouldn&#39;t be able to read the certificate in polynomial time let alone use it for verification! Again, for &lt;strong&gt;TSP&lt;/strong&gt; the certificate is a subset of the edges of the graph (a path with length &amp;lt;= &lt;code&gt;l&lt;/code&gt;) so it&#39;s linear in the size of the input.&lt;/p&gt;
&lt;p&gt;In our analogy, &lt;strong&gt;NP&lt;/strong&gt; problems equate with weeks and days long hikes, &lt;strong&gt;WD&lt;/strong&gt;. While &lt;strong&gt;WD&lt;/strong&gt; is fairly abstract in terms of difficulty &lt;strong&gt;NP&lt;/strong&gt; problems are very precise in that they require that a solution can be &lt;em&gt;verified&lt;/em&gt; in polynomial time given some certificate. Also, just like the mountains, all problems in &lt;strong&gt;P&lt;/strong&gt; are in &lt;strong&gt;NP&lt;/strong&gt; in the same way that all day long hikes can also be done in weeks and days if you like to take your time. The containment of &lt;strong&gt;P&lt;/strong&gt; in &lt;strong&gt;NP&lt;/strong&gt; follows from observing that each polynomial time Turing machine can act as a polynomial time verifier for a problem instance by simply ignoring the certificate and generating the solution directly.&lt;/p&gt;
&lt;p&gt;A slight departure from our analogy is that the distinction between &lt;strong&gt;D&lt;/strong&gt; and &lt;strong&gt;WD&lt;/strong&gt; is fairly clear. It&#39;s possible that in some distant future there will be shortcuts to the top of mountains like K2 and Everest that will make them surmountable in a day (teleportation?), but intuitively day hikes and weeks long hikes are very different things. Not necessarily so for &lt;strong&gt;P&lt;/strong&gt; and &lt;strong&gt;NP&lt;/strong&gt;. For good reason [4] it is &lt;em&gt;strongly&lt;/em&gt; believed that &lt;strong&gt;P&lt;/strong&gt; is not the same as &lt;strong&gt;NP&lt;/strong&gt; though it has yet to be shown conclusively. Further, the definitions ask nothing that might automatically differentiate the two classes and so whenever we distinguish between &lt;strong&gt;P&lt;/strong&gt; and &lt;strong&gt;NP&lt;/strong&gt; it comes with the caveat that it is still possible they are the same class of problem however unlikely that may be.&lt;/p&gt;
&lt;h2 id=&quot;polynomial-time-reduction&quot;&gt;Polynomial Time Reduction &lt;a class=&quot;direct-link&quot; href=&quot;#polynomial-time-reduction&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We used vision to compare mountains but for the complexity of decision problems we need something more precise. The primary tool for comparison in complexity is the reduction. A reduction is a sort of translation and it&#39;s valid if the translated problem&#39;s solution implies a solution to the original problem and vice versa.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A problem is polynomial time reducible to another problem if there exists a Turing machine that can translate any instance of the first problem to the second such that the original instance has a solution if and only if the reduced instance has a solution and if the reduction operates in polynomial time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Understanding this is absolutely essential to understanding what it means for a problem to be &lt;strong&gt;NP&lt;/strong&gt;-hard, so we&#39;re going to abuse the mountain climbing analogy just a bit to help. Instead of measuring the relative difficulty of a climb by sight, we&#39;ll introduce a more serious restriction on how to compare mountains. To match the reduction problems we&#39;ll require that a &lt;em&gt;bridge&lt;/em&gt; be built between mountains.&lt;/p&gt;
&lt;p&gt;Leaving aside the normal lateral distance  it&#39;s definitely the case that the bridge should only take days to hike, otherwise in the process of crossing the bridge you might end up climbing a different class of mountain! This corresponds to the requirement that our reduction between problems should take polynomial time.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/d-bridge-wd-mountain.png&quot; alt=&quot;X mountain obscured&quot;&gt;&lt;/p&gt;
&lt;p&gt;This is important because if you could devise some special bridge (teleporter?) that allowed you to cross from the top of a weeks and days mountain to the top of a day trip mountain in the length of a day trip, you&#39;d have a way to scale that weeks and days mountain in about a day by climbing the day trip mountain and then taking the bridge.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/d-hike-d-bridge.png&quot; alt=&quot;X mountain obscured&quot;&gt;&lt;/p&gt;
&lt;p&gt;In essence you will have shrunk the bigger mountain! Further, if you have &amp;quot;day trip bridges&amp;quot; between that first big mountain and other big mountains then you could get to the top of any them with a relatively short trip. The hiking world would be changed forever [5].&lt;/p&gt;
&lt;h2 id=&quot;np-hard&quot;&gt;&lt;strong&gt;NP&lt;/strong&gt;-hard &lt;a class=&quot;direct-link&quot; href=&quot;#np-hard&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It&#39;s this type of reduction that defines what it means for a problem to be &lt;strong&gt;NP&lt;/strong&gt;-hard. We say that a problem is &lt;strong&gt;NP&lt;/strong&gt;-hard if it can be compared to any other problem in &lt;strong&gt;NP&lt;/strong&gt; by means of a reduction in the same way that we can classify mountain &lt;strong&gt;X&lt;/strong&gt; by means of a &amp;quot;reduction&amp;quot; or &amp;quot;bridge&amp;quot; from mountain &lt;strong&gt;Y&lt;/strong&gt;. The seeming impossibility of building a day trip bridge from a weeks and days mountain to a day trip mountain ensures that if you &lt;em&gt;can&lt;/em&gt; build that bridge one of two things has happened:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You&#39;ve come up with an absolutely ground breaking bridge building technique.&lt;/li&gt;
&lt;li&gt;The target mountain is also &lt;em&gt;at least&lt;/em&gt; a weeks and days mountain.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the same way, if you can come up with a polynomial time reduction to some problem from a problem that is &lt;strong&gt;NP&lt;/strong&gt;-hard but also in &lt;strong&gt;NP&lt;/strong&gt; then you&#39;ve either come up with a ground breaking reduction or your problem is also &lt;strong&gt;NP&lt;/strong&gt;-hard.&lt;/p&gt;
&lt;p&gt;It&#39;s also important to note that if we want to get an understanding for how difficult mountains are the bridges must be from tops to tops. That is, you could build a day bridge from the top of a day mountain to the &lt;em&gt;side&lt;/em&gt; of a much bigger mountain but that wouldn&#39;t tell you a whole lot about the much bigger mountain.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://johnbender.us/img/complexity/d-bridge-to-nowhere.png&quot; alt=&quot;X mountain obscured&quot;&gt;&lt;/p&gt;
&lt;p&gt;Similarly you can reduce from polynomial time problems to &lt;strong&gt;NP&lt;/strong&gt;-hard problems but it&#39;s not going to mean a whole lot, which is why we reduce &lt;em&gt;from&lt;/em&gt; problems known to be &lt;strong&gt;NP&lt;/strong&gt;-hard and in &lt;strong&gt;NP&lt;/strong&gt; [6].&lt;/p&gt;
&lt;h2 id=&quot;np-complete&quot;&gt;&lt;strong&gt;NP&lt;/strong&gt;-complete &lt;a class=&quot;direct-link&quot; href=&quot;#np-complete&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Recall that when a mountain is &lt;strong&gt;WD&lt;/strong&gt;-hard like &lt;strong&gt;X&lt;/strong&gt; was before the clouds cleared we said that it was going to take &lt;em&gt;at least&lt;/em&gt; weeks and days to climb; it could take more. Again &lt;strong&gt;NP&lt;/strong&gt;-hard gives the same characterization for problems. When we say that something is &lt;strong&gt;NP&lt;/strong&gt;-hard we&#39;re simply saying that it&#39;s &lt;em&gt;at least&lt;/em&gt; as hard as any other problem in &lt;strong&gt;NP&lt;/strong&gt; but it could be harder.&lt;/p&gt;
&lt;p&gt;So in addition to knowing whether a problem is &lt;strong&gt;NP&lt;/strong&gt;-hard, if we can also show that a problem is in the class &lt;strong&gt;NP&lt;/strong&gt;, we say that it is &lt;strong&gt;NP&lt;/strong&gt;-complete and that it represents a prime example of the class. This is precisely why the optimization form of &lt;strong&gt;TSP&lt;/strong&gt; can only be said to be &lt;strong&gt;NP&lt;/strong&gt;-hard and not &lt;strong&gt;NP&lt;/strong&gt;-complete because verifying the optimal solution for a given graph of cities will take as long as generating the solution in the first place, so there&#39;s no way to build an algorithm that can verify that a given solution is optimal in polynomial time. On the other hand if we tweak the question and ask whether a graph has a solution of a certain length then we can certainly check that in polynomial time placing it firmly in &lt;strong&gt;NP&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;If the mountain is both &lt;strong&gt;WD&lt;/strong&gt;-hard and also in the &lt;strong&gt;WD&lt;/strong&gt; class it&#39;s a &lt;strong&gt;WD&lt;/strong&gt;-complete mountain. If a problem is &lt;strong&gt;NP&lt;/strong&gt;-hard also in &lt;strong&gt;NP&lt;/strong&gt; it&#39;s an &lt;strong&gt;NP&lt;/strong&gt;-complete problem.&lt;/p&gt;
&lt;h2 id=&quot;closing&quot;&gt;Closing &lt;a class=&quot;direct-link&quot; href=&quot;#closing&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If we want to know just how hard a problem is in terms of computation it&#39;s really not enough to know that it&#39;s at least as hard as another problem for the same reason we must know more about a mountain before we can plan to climb it. Ultimately we want to define our problems as complete for some complexity class so that we can clearly say to our hiking friends just how hard the climb will be.&lt;/p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;Footnotes &lt;a class=&quot;direct-link&quot; href=&quot;#footnotes&quot; aria-hidden=&quot;true&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis&quot;&gt;Wikipedia - Church-Turing Thesis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;logarithmic slowdown in simulation&amp;quot;. - &lt;a href=&quot;http://en.wikipedia.org/wiki/Turing_machine#Universal_Turing_machines&quot;&gt;Wikipedia - Turing Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/NP_(complexity)#Machine-definition&quot;&gt;Wikipedia - NP Machine Definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;n particular, if P = NP, then the hierarchy collapses completely.&amp;quot; - &lt;a href=&quot;http://en.wikipedia.org/wiki/Polynomial_hierarchy#Relations_between_classes_in_the_polynomial_hierarchy&quot;&gt;Wikipeda - Polynomial Hierarchy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I&#39;m not bothering to mention that the requirement is that all problems in NP have a reduction to the problem under consideration because I don&#39;t want to bother with Cook/Levin, &lt;a href=&quot;http://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem&quot;&gt;Wikipedia - Cook Levin Theorem&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;This is a sort of sidelong glance at the directionality of reductions being from the existing NP problem to the unknown.&lt;/li&gt;
&lt;/ol&gt;
</content>
	</entry>
</feed>
