
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    
    <title>johnbender.us</title>
    
    
    <meta name="author" content="John Bender">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="//johnbender.github.com/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="//johnbender.github.com/assets/themes/twitter/css/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="//johnbender.github.com/assets/themes/twitter/css/cv.css" rel="stylesheet" type="text/css" media="all">
    <link href="//johnbender.github.com/assets/themes/twitter/css/font-awesome.min.css" rel="stylesheet" type="text/css" media="all">
    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="//johnbender.github.com">johnbender.us</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
  
    
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/cv.html">Curriculum Vitae</a></li>
      	
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/portfolio.html">Portfolio</a></li>
      	
      
    
  



          </ul>

          <div class="social-media">
            <a href="http://twitter.com/johnbender">
              <i class="icon-twitter-sign"></i>
            </a>
            <a href="http://github.com/johnbender">
              <i class="icon-github-sign"></i>
            </a>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        

<div class="page-header">
  <h1><a href="//johnbender.github.com/2013/02/07/presentation-math-envy-and-coffeescripts-foibles">Presentation: Math Envy and CoffeeScript's Foibles</a></h1>
</div>

<div class="row-fluid">
  <div class="span10 text">
    <p>I&#39;d like to thank the good folks at <a href="http://js.la">js.la</a> for putting on a great meetup and having me out to participate. You can see the slides at <a href="http://johnbender.us/presentation-cs-foibles">http://johnbender.us/presentation-cs-foibles</a>.</p>

<p>
<iframe src="http://player.vimeo.com/video/58872586" width="610" height="340" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
<a href="http://vimeo.com/58872586" class="video-link">View video on Vimeo</a>
</p>

<p><strong>NOTE</strong>: The larger format presented on <a href="http://vimeo.com/58872586">the Vimeo site itself</a> might be better viewing.</p>

  </div>

  <div id="info" class="span2">
    

    <h4>Published</h4>
    <div class="date">
      <span>07 Feb 2013</span>
    </div>

    
    <h4>Tags</h4>
    <ul class="tag_box">
      
      


  
    
    	<li><a href="/archive.html#coffeescript">coffeescript <span>4</span></a></li>
    
    	<li><a href="/archive.html#presentation">presentation <span>3</span></a></li>
    
    	<li><a href="/archive.html#math">math <span>12</span></a></li>
    
  



    </ul>
    
  </div>
</div>

<div class="page-header">
  <h1><a href="//johnbender.github.com/2013/01/15/system-f-in-coffeescript">System F in CoffeeScript</a></h1>
</div>

<div class="row-fluid">
  <div class="span10 text">
    <p>System F and its variants are used frequently in the study of typed computation and an extended form, System FC, plays an important role in GHC&#39;s compilation process [1]. This post will attempt to translate the grammars of the Lambda Calculus, Simply Typed Lambda Calculus, and finally System F into a small subset of CoffeeScript while covering the basics of application and abstraction in each. Hopefully, through studying the basics here, readers who are interested in learning more about type theory and the lambda calculi will feel a little less intimidated by the notation and concepts.</p>

<h2 id="toc_40">Lambda Calculus</h2>

<p>Representing the Lambda Calculus only requires a small subset of CoffeeScript&#39;s total syntax. Let&#39;s define both grammars side by side.</p>

<div class="center">
  <img class="slim" src="/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-grammars.png"></img>
</div>

<p>In both cases <code>x</code> represents a variable and <code>t t</code> represents application of one term to another. The only real difference is the lambda abstraction syntax (red).</p>

<div class="center">
  <img class="slim" style="width: 50%" src="/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-abstraction-examples.png"></img>
</div>

<p>In the Lambda Calculus, abstraction involves preceding or wrapping a term <code>t</code> with <code>λx.t</code> which captures or binds the variable <code>x</code> inside the term <code>t</code>. In the example <code>t</code> is <code>λx.y</code>, using the abstraction <code>λy.t</code> creates a new term <code>λy.λx.y</code> (otherwise known as the K-combinator). Note that the <code>x</code> in <code>λx.t</code> shown in the grammar could be any variable like <code>y</code> or <code>z</code>.</p>

<p>In CoffeeScript we can do that same thing with the term <code>(x) -&gt; y</code> by applying the CoffeeScript version of abstraction, yielding <code>(y) -&gt; (x) -&gt; y</code>.</p>

<div class="center">
  <img src="/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-application-examples.png"></img>
</div>

<p>The application of a term that shows two abstractions (<code>y</code> and <code>x</code>) to a single argument results in another term. The <a href="http://coffeescript.org/#try:z%20%3D%20undefined%0A%0A((y)%20-%3E%20(x)%20-%3E%20y)%20z">translation</a> to JavaScript shows that a function object is returned ready for application. The concept of <em>application</em> in the Lambda Calculus is really the idea of substitution. You can see that the <code>z</code> is substituted for the instances of <code>y</code> in the body of the inner lambda term. Similarly in CoffeeScript the outer lambda puts <code>y</code> in scope and now all occurrences in the body of the lambda term will behave as <code>z</code>.</p>

<p>The notion of <em>closed</em> terms in the Lambda Calculus is a point of departure with CoffeeScript. A closed term has no free variables. For example, in <code>λx.y</code> the <code>y</code> variable is called <em>free</em> because it hasn&#39;t been bound by an enclosing abstractions. Adding an additional abstraction to get <code>λy.λx.y</code> captures the <code>y</code>. The JavaScript generated by the CoffeeScript <code>(x) -&gt; y</code> will throw a reference error without a definition for <code>y</code> in scope, in contrast to the lambda term which will simply discard its argument and produce the <code>y</code>.</p>

<h2 id="toc_41">Simply Typed Lambda Calculus</h2>

<p>The Simply Typed Lambda Calculus expands on the Lambda Calculus with type information in abstractions.</p>

<div class="center">
  <img src="/assets/images/diagrams/system-f-cs/simply-typed-lambda-calculus-grammars.png"></img>
</div>

<p>It adds a type requirement to the argument of abstractions. The CoffeeScript equivalent adds a function that compares a type argument to the argument term. To keep things simple, <code>ifft</code> will throw an exception when the types don&#39;t line up.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="c1"># If and only if (iff) the type (t) is correct</span>
<span class="nv">ifft = </span><span class="nf">(type, obj) -&gt;</span>
  <span class="k">if</span> <span class="nx">obj</span> <span class="k">instanceof</span> <span class="nx">type</span>
    <span class="k">throw</span> <span class="s">&quot;Type mismatch&quot;</span>
</code></pre>
</div>

<p>This definition assumes that the browser&#39;s <code>instanceof</code> implementation is behaving properly but certainly serves the purpose of illustration here. Assuming the type <code>Foo</code> is defined for the calculus and with <code>class Foo</code> in the CoffeeScript, we can add types to a simple example.</p>

<div class="center">
  <img class="slim" src="/assets/images/diagrams/system-f-cs/simply-typed-lambda-calculus-typing-examples.png"></img>
</div>

<p>The types <code>τ</code> can represent are an important part of the Simply Typed Lambda Calculus. Some definitions provide a set of base types like natural numbers or booleans. Along with that comes a set of base constant values that can represent those types. For natural numbers a base constant of <code>0</code> and <a href="http://en.wikipedia.org/wiki/Church_encoding">church numerals</a> allows users to represent all the natural numbers. Here we&#39;ve assumed the simple case allowing only the function type <code>τ → τ</code>, meaning every argument must be a lambda term.</p>

<p>Unfortunately even the simple case throws a rather large monkey wrench into the works. That&#39;s because there&#39;s no way to write <code>ifft</code> such that it can know or inspect the arguments type and return type of a lambda term (JavaScript function). In spite of that let&#39;s proceed to see what we can learn about System F.</p>

<h2 id="toc_42">System F</h2>

<p>System F adds the notion of <em>polymorphic types</em> to the Simply Typed Lambda Calculus. The term polymorphic carries a lot of baggage, but here it is <em>parametric polymorphism</em> [3]. That is, the type of a term can change depending on the setting.</p>

<div class="center">
  <img src="/assets/images/diagrams/system-f-cs/system-f-grammars.png"></img>
</div>

<p>System F makes two extensions. <code>Λα.e</code> is a type abstraction on the type variables in terms and <code>e [τ]</code> is the application of a type to a term that has been wrapped by a type abstraction. Note that the abstraction uses <code>α</code> to represent a type variable and <code>τ</code> to represent types that may or may not contain type variables. Since CoffeeScript&#39;s &quot;types&quot; are really constructor functions, all that&#39;s needed is an enclosing lambda to pull the type argument to <code>ifft</code> into scope and an application to a constructor function at runtime.</p>

<div class="center">
  <img class="slim" src="/assets/images/diagrams/system-f-cs/system-f-type-abstraction-examples.png"></img>
</div>

<p>For System F the type abstraction is very specific. It works at the type level [4]. In CoffeeScript, on the other hand, it&#39;s just another lambda abstraction that puts the constructor function in scope as a lambda argument. In both cases when the term is applied to a type a substitution of the type for the type variable <code>α</code> takes place, just like regular (term) abstractions.</p>

<div class="center">
  <img src="/assets/images/diagrams/system-f-cs/system-f-type-application-examples.png"></img>
</div>

<p>Again there is an important exception with regards to the types permitted in System F that makes the <code>ifft</code> even more inadequate than it was with the Simply Typed Lambda Calculus. Not only is there no way to write <code>ifft</code> so that it can properly check against lambda types but in addition System F defines universally quantified types. This means that a lambda can be polymorphic and operate without knowing anything about the type of its argument.</p>

<p>For example the identity combinator <code>Λα.λx:α.x</code>, or in CoffeeScript <code>(α) -&gt; (x) -&gt; ifft(α, x); x</code>, has the polymorphic type <code>∀α.α → α</code>. That is, its type isn&#39;t determined until a type application takes place or it &quot;works&quot; for all types. The issue arises when a combinator like identity is passed as an argument to another lambda term that expects a polymorphic function. Again, <code>ifft</code> can&#39;t check the types of a combinator if a type has been applied and it certainly can&#39;t check that the combinator is type agnostic in its dealings (polymorphic).</p>

<h2 id="toc_43">Strong and Normal</h2>

<p>System F has some really neat properties. Most importantly System F is <em>strongly normalizing</em>. That means that it always terminates and always reduces to a normal form when the terms are well typed (the types line up properly). That alone makes it worth studying.</p>

<p>It&#39;s also possible to make the type abstraction a bit more robust in the CoffeeScript by verifying that the argument is at least a function. A more adventuresome individual might alter CoffeeScript to annotate constructor function objects with a property that could be used to set them apart and compare them [5].</p>

<p>Even if we came up short of a really meaningful translation, hopefully it has demystified parts of how these calculi work. If you want to learn more I suggest reading <a href="http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091"><em>Types and Programming Languages</em></a> by Pierce (not an affiliate link).</p>

<h3 id="toc_44">Footnotes</h3>

<ol>
<li>There are some <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/">interesting papers</a> to read from Microsoft Research this particular extension of System F.</li>
<li>This is a more <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations">intrinsic</a> approach to the translation as we aren&#39;t attempting to use types to reason about the terms/grammars.</li>
<li>Specifically <em>rank-n</em> polymorphism since the type variable <code>α</code> can be replaced by a quantified type.</li>
<li>This is actually captured in the reduction rules for System F.</li>
<li><em>Gasp!</em> types in CoffeeScript.</li>
</ol>

  </div>

  <div id="info" class="span2">
    
    <h4>Vote/Comment</h4>
    <ul id="vote">
      <li>
        <a id="hn" href="http://news.ycombinator.com/newest" alt="Hacker News">Hacker News</a>
      </li>
    </ul>
    

    <h4>Published</h4>
    <div class="date">
      <span>15 Jan 2013</span>
    </div>

    
    <h4>Tags</h4>
    <ul class="tag_box">
      
      


  
    
    	<li><a href="/archive.html#coffeescript">coffeescript <span>4</span></a></li>
    
    	<li><a href="/archive.html#math">math <span>12</span></a></li>
    
  



    </ul>
    
  </div>
</div>

<div class="page-header">
  <h1><a href="//johnbender.github.com/2013/01/09/math-envy-and-coffeescripts-foibles-2">Math Envy and CoffeeScript's Foibles, Part 2</a></h1>
</div>

<div class="row-fluid">
  <div class="span10 text">
    <p>In the <a href="/2012/11/27/math-envy-and-coffeescripts-foibles/">previous post</a> I presented the basics of operational semantics and showed how derivations trees can be used to differentiate two terms that are syntactically similar. This post develops the closing thoughts further with the introduction of type rules, example tools for automating evaluation and type derivation, and a concrete definition of semantic ambiguity. The primary goal is to establish the best way to detect ambiguous term pairings and then outline what will work for a tool that can be generalized beyond the CoffeeScript subset.</p>

<h2 id="toc_27">Type Rules</h2>

<p>Type rules are similar in construction to evaluation rules, consisting of a premise and conclusion. As with evaluation rules the premise establishes the preconditions for the conclusion. Again, each rule is tagged with a name for reference but preceded by a <em>t-</em> in this case to distinguish them from inference rules (<em>e-</em>).</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-type-rules.png"></img>
</div>

<p>Type rules without a premise like <em>t-true</em> and <em>t-false</em> are taken to be true out of hand. That is, the terms <code>true</code> and <code>false</code> both have the type <code>Bool</code>. The others are more complicated.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-term.png"></img>
</div>

<p><em>t-lambda</em> illustrates how to determine the type of a lambda term like <code>(-&gt; true)</code>. The premise above the line states that if the subterm <code>t</code> has the <em>concrete</em> type <code>T</code>, then the conclusion <code>λt</code> has the type <code>X -&gt; T</code>. Here <code>X</code> is a <em>type variable</em> because we don&#39;t know whether the lambda will be evaluated with the invocation operator <code>()</code> or applied to an argument. <code>T</code> will be concrete because it can be determined from the body of the lambda expression. For example, in <code>(-&gt; true)</code> the subterm <code>true</code> has the type <code>Bool</code> so the lambda term has the type <code>X -&gt; Bool</code>.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-invocation.png"></img>
</div>

<p><em>t-inv</em> shows how to determine the type of lambda invocation like <code>(-&gt; true)()</code>. The premise states if the lambda term has the type <code>X -&gt; T</code> the term <code>λt()</code> has the type <code>T</code>. For example, <code>(-&gt; true)()</code> evaluates to <code>true</code> and has the type <code>Bool</code>. It&#39;s worth noting that <code>X</code> is constrained to be the <code>Unit</code> or empty type since no argument is used.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-application.png"></img>
</div>

<p><em>t-app</em> is the type rule for lambda applications, e.g. <code>(-&gt; true) false</code>. The premise says that if the lambda term <code>λt</code> on the left has the type <code>X -&gt; T</code> the conclusion is that the application will have the result type of the lambda term. Again, the type of an application, like invocation, is only concerned with the type of the <em>first</em> lambda&#39;s subterm <code>t</code> and it ignores the type of the argument that it&#39;s applied to.</p>

<h2 id="toc_28">Type Rule Stacking</h2>

<p>This notation makes it easy to establish the type of a term by stacking the type rules on one another in the same fashion as evaluation rules. Taking a very simple example, some diagrams will illustrate how this works:</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span>
</code></pre>
</div>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-type-derivation-simple.png"></img>
</div>

<p>This highlights how to derive the type at the bottom from its subterms. Typing the innermost subterm <code>true</code> with <em>t-true</em> can be &quot;stacked&quot; by using it to replace the premise of type rule <em>t-lambda</em>. The type derivation expands from the subterm to establish each subsequent parent term&#39;s type. Another more complex derivation:</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">false</span><span class="p">))()</span> <span class="kc">true</span>
</code></pre>
</div>

<div class="center">
  <img style="width: 300px" src="/assets/images/diagrams/math-envy-cs/cs-type-derivation-complex.png"></img>
</div>

<p>The second subterm of the application is unimportant where the type of the term is concerned and as a result it&#39;s wholly ignored. Working on the left term, the tree extends upward until it reaches the atomic value type, <code>false : Bool</code>. The complexity of nested lambdas and invocation make for a taller stack of type rules to reach the atomic <code>false</code> when compared with the previous example.</p>

<h2 id="toc_29">Not Quite There</h2>

<p>At this point the type rules can describe the original issue. A derivation tree based on the typing rules highlights that the term is untypable. Taking our canonical example, <code>(-&gt; true)() -&gt; false</code>:</p>

<div class="center">
  <img style="width: 300px" src="/assets/images/diagrams/math-envy-cs/cs-type-derivation-original-issue.png"></img>
</div>

<p>Once the derivation tree reaches the outermost term it breaks. There is no type rule for the application of something with type <code>Bool</code> to something with type <code>X -&gt; Bool</code> since <em>t-app</em> requires the first term have the type <code>X -&gt; T</code> in its premise. It&#39;s a type error.</p>

<p>Previously we saw that this would result in a type error under evaluation by the CoffeeScript interpreter. We also saw that it was easy to construct a term that suffered the same semantic confusion without the type error <code>(-&gt; (-&gt; true))() -&gt; false</code>. This issue applies to the type derivation as well.</p>

<p>In addition we saw that it&#39;s possible to construct terms, albeit in the boolean example language, that might produce the same value through different evaluation paths. That is, they had different derivation trees in the evaluation relation but the same evaluation result. This issue also applies to type derivations.</p>

<p>In both cases useful information is lost when the derivation is discarded in favor of the final value or type. The advantage with the type information is obviously that no evaluation is required to determine if two terms are &quot;different&quot; in some way other than their syntax. The disadvantage is that not all languages make determining type information easy.</p>

<p>Ultimately the type information provides a second way to differentiate syntactically similar terms. Indeed there are cases where both the evaluation and type information are necessary to distinguish terms. For example <code>((x, y) -&gt; x + y)(1, 1)</code> has a type derivation identical to <code>((x, y) -&gt; x * y)(1, 2)</code> and the same evaluation result, but it clearly takes a different evaluation path [1].</p>

<p><em>Note: The next five sections cover an implementation of a lexer, parser, evaluator and mechanisms for type/evaluation derivation. If you&#39;d rather just read about how the generated evaluation and type derivations are used to find confusing term pairings you can skip to Detecting Ambiguity</em></p>

<h2 id="toc_30">Happy Parsing</h2>

<p>It&#39;s time to build something concrete from the formal notion of evaluation and types. An AST for this CoffeeScript subset will provide enough information to perform evaluation and establish derivation trees for both evaluation and types. I&#39;ve chosen Haskell along with the <a href="http://www.haskell.org/alex/">Alex</a> and <a href="http://www.haskell.org/happy/">Happy</a> tools to implement a simple lexer and parser. As you would expect the parser grammar definition looks very similar to the grammar definition presented in the previous post:</p>
<div class="highlight"><pre><code class="text">%token
    white   { Whitespace }
    bool    { Boolean $$ }
    &#39;()&#39;    { Unit       }
    &#39;-&gt;&#39;    { Arrow      }
    &#39;(&#39;     { LeftParen  }
    &#39;)&#39;     { RightParen }

Expr   : Value                      { $1 }
       | Lambda &#39;()&#39;                { Invoke $1 }
       | Expr white Expr            { Apply $1 $3 }

Lambda : &#39;()&#39; white &#39;-&gt;&#39; white Expr { Lambda $5 }
       | &#39;-&gt;&#39; white Expr            { Lambda $3 }
       | &#39;(&#39; Lambda &#39;)&#39;             { $2 }

Value  : bool                       { BooleanExpr $1 }
       | Lambda                     { $1 }
</code></pre>
</div>

<p>You can view the full lexer and parser implementations <a href="https://gist.github.com/8d7db37e8a6dc99e1ea3">here</a>.</p>

<p>There are two differences from the original grammar definition. Lambda terms in parentheses are just a convenience for readability. More importantly a correction must be made to application of two terms, allowing for any term as the left side (the <em>applicand</em>) [2]. This enables the grammar to reproduce the original issue, since <code>(-&gt; true)() -&gt; false</code> translates to an invocation applied to a lambda term. The corrected grammar:</p>

<div class="center">
  <img style="width: 200px;" src="/assets/images/diagrams/math-envy-cs/cs-grammar-corrected.png"></img>
</div>

<p>Also, a correction and an addition must be made to the inference rules presented in the previous post. This will ensure that any term type is permitted as the left half of an application, and that it is fully evaluated before applying it.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-inference-rules-corrected.png"></img>
</div>

<p>Where <em>e-arg-eval</em> ensures that the argument of an application is fully evaluated, <em>e-app-eval</em> ensures that the applicand is fully evaluated before the application takes place.</p>

<h2 id="toc_31">Matching Rules</h2>

<p>The abstract representation produced by the parser is a simple tree structure built with Haskell types. Pattern matching can be used with the type and inference rules to produce evaluation and derivation results. To start let&#39;s look at a simple evaluator and derivation builder.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- an enumeration of each inference rule</span>
<span class="kr">data</span> <span class="kt">InfRule</span> <span class="ow">=</span> <span class="kt">Inv</span> <span class="o">|</span> <span class="kt">App</span> <span class="o">|</span> <span class="kt">ArgEval</span> <span class="o">|</span> <span class="kt">AppEval</span>
</code></pre>
</div>

<p>The <code>InfRule</code> Haskell type is a simple enumeration of the tags belonging to each inference rule. <em>e-inv</em> corresponds to <code>Inv</code> and so on.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- an intermediate form for performing derivation and evaluation</span>
<span class="kr">data</span> <span class="kt">RuleMatch</span> <span class="ow">=</span> <span class="kt">None</span> <span class="o">|</span> <span class="kt">RuleMatch</span> <span class="kt">InfRule</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Expr</span><span class="p">)</span> <span class="kt">Expr</span>

<span class="c1">-- match a rule and provide the relevant sub terms for action</span>
<span class="nf">matchRule</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">RuleMatch</span>
</code></pre>
</div>

<p>Both the evaluator and the derivation builder will operate based on the inference rules that apply to each term and its subterms. The function <code>matchRule</code> takes an expression, <code>Expr</code>, and provides three pieces of information in a <code>RuleMatch</code> result: the inference rule that applies to the term, an optional term for the premise of an inference rule pulled from the body of the parent term, and a term for the conclusion of the inference rule also pulled from the body of the parent term. There are pattern matching definitions for each rule.</p>
<div class="highlight"><pre><code class="haskell"><span class="nf">matchRule</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">None</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="kr">_</span><span class="p">)</span>      <span class="ow">=</span> <span class="kt">None</span>
</code></pre>
</div>

<p>The value terms <code>true</code>, <code>false</code> and <code>(-&gt; x)</code> are the base case of <code>matchRule</code>. That is, whenever another function requests a rule match on the value terms <code>None</code> is provided to signal that the term has been fully evaluated.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- Rule: e-inv</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Invoke</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">t</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">Inv</span> <span class="kt">Nothing</span> <span class="n">t</span>
</code></pre>
</div>

<p>Invocation can only be applied to a lambda term and the result of the invocation is the lambda&#39;s subterm, e.g. <code>(-&gt; true)()</code> evaluates to <code>true</code>. An invocation on anything else will simply drop through this match and ultimately to the catch all <code>error</code> case. For example the CoffeeScript <code>true()</code> is invalid. Its abstract representation from the parser is <code>Invoke (BooleanExpr True)</code> which clearly won&#39;t match here. On a match, the <code>RuleMatch</code> result contains the rule tag for invocation <code>Inv</code>, nothing for an inference rule premise since there isn&#39;t one for <em>e-inv</em> and the subterm <code>t</code> for further derivation in the conclusion.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- Rule: e-app</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kr">_</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="kt">Nothing</span> <span class="n">t</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="kr">_</span><span class="p">))</span>      <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="kt">Nothing</span> <span class="n">t</span>
</code></pre>
</div>

<p>Like invocation <em>e-app</em> only works with lambda terms, but it carries the addition requirement that the argument be a value term. The grammar shows that the only <code>v</code> (value) terms are lambdas and boolean values so there&#39;s a match for those cases here. When there&#39;s a match the rule tag is <code>App</code> and the lambda subterm is again provided for possible further inspection/operation.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- Rule: e-arg-eval</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t</span> <span class="n">i</span><span class="o">@</span><span class="p">(</span><span class="kt">Invoke</span> <span class="kr">_</span><span class="p">))</span>  <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">ArgEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">i</span><span class="p">)</span> <span class="n">t</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t</span> <span class="n">a</span><span class="o">@</span><span class="p">(</span><span class="kt">Apply</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">ArgEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="n">t</span>

<span class="c1">-- Rule: e-app-eval</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">i</span><span class="o">@</span><span class="p">(</span><span class="kt">Invoke</span> <span class="kr">_</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">AppEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">i</span><span class="p">)</span> <span class="n">t</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">a</span><span class="o">@</span><span class="p">(</span><span class="kt">Apply</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">AppEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="n">t</span>
</code></pre>
</div>

<p><em>e-arg-eval</em> and <em>e-app-eval</em> are more complicated than either <em>e-inv</em> or <em>e-app</em> which makes sense when comparing them as inference rules. Both <em>e-arg-eval</em> and <em>e-app-eval</em> carry a premise.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-inference-rules-app-argeval.png"></img>
</div>

<p>Both rules require that some evaluation take place on one of the subterms. More importantly the shape of the term remains the same. Neither <em>e-arg-eval</em> or <em>e-app-eval</em> change the shape of the term to which they apply, only the shape of the sub terms. This is in contrast to <em>e-inv</em> and <em>e-app</em> which discard the invocation operator and second term respectively. As a result the <code>RuleMatch</code> contains the subterm that needs to be evaluated further and the other subterm that remains stagnant. Note that in the function definition the <em>e-arg-eval</em> rule is matched first so that the <em>e-app-eval</em> rule can ignore the second subterm under the assumption that it&#39;s a value term (not <code>Invoke</code> or <code>Apply</code>).</p>
<div class="highlight"><pre><code class="haskell"><span class="nf">matchRule</span> <span class="n">t</span> <span class="ow">=</span> <span class="ne">error</span> <span class="o">$</span> <span class="s">&quot;No inference rule applies for: &quot;</span> <span class="o">++</span> <span class="p">(</span><span class="n">show</span> <span class="n">t</span><span class="p">)</span>
</code></pre>
</div>

<p>Finally, in situations like <code>true()</code> or <code>true (-&gt; true)</code> where no rule applies, an error is raised.</p>

<h2 id="toc_32">Evaluating the Options</h2>

<p>The information contained in a <code>RuleMatch</code> instance can be used to evaluate or derive a given term. Evaluation is a simple matter of applying the rules recursively.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- perform a single evaluation step</span>
<span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
<span class="nf">eval</span> <span class="n">t</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="p">(</span><span class="n">matchRule</span> <span class="n">t</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">None</span>                             <span class="ow">-&gt;</span> <span class="n">t</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kr">_</span> <span class="kt">Nothing</span> <span class="n">t1</span><span class="p">)</span>         <span class="ow">-&gt;</span> <span class="n">t1</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">ArgEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Apply</span> <span class="n">t2</span> <span class="p">(</span><span class="n">eval</span> <span class="n">t1</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">AppEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Apply</span> <span class="p">(</span><span class="n">eval</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span>
</code></pre>
</div>

<p><code>eval</code> performs a single step of evaluation according the the inference rules. The first case match returns the original term <code>t</code> because <code>None</code> is the match for fully evaluated value terms like <code>true</code>, <code>false</code>, and <code>(-&gt; x)</code>. The second match handles both the <code>Inv</code> and <code>App</code> by returning the subterm of the invoked or applied lambda term. The <code>matchRule</code> function does a bit of evaluation for these two rules by stripping the applied lambda term. For example, <code>(-&gt; true) true</code> and <code>(-&gt; true)()</code> become <code>true</code>.</p>
<div class="highlight"><pre><code class="haskell">      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">ArgEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Apply</span> <span class="n">t2</span> <span class="p">(</span><span class="n">eval</span> <span class="n">t1</span><span class="p">)</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">AppEval</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Apply</span> <span class="p">(</span><span class="n">eval</span> <span class="n">t1</span><span class="p">)</span> <span class="n">t2</span>
</code></pre>
</div>

<p>For <code>ArgEval</code> and its cousin <code>AppEval</code> the subterm that needs further evaluation gets it and then the whole term is reassessed. The order of which evaluation happens first is preserved here by recursion. If the argument in an application needs more than one evaluation step, <code>eval</code> will continue to work on it until the result is returned to the original invocation. Subsequently if the applicand needs evaluation it will do the same. For example, in <code>(-&gt; true) (-&gt; true)()</code> the second term is evaluated with an <code>Inv</code> and then the boolean result is the argument to the first lambda term.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- reduce an expression to a value term</span>
<span class="nf">fullEval</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Expr</span>
<span class="nf">fullEval</span> <span class="n">t</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="p">(</span><span class="n">matchRule</span> <span class="n">t</span><span class="p">)</span> <span class="kr">of</span>
      <span class="kt">None</span> <span class="ow">-&gt;</span> <span class="n">t</span>
      <span class="kr">_</span>    <span class="ow">-&gt;</span> <span class="n">fullEval</span> <span class="o">$</span> <span class="n">eval</span> <span class="n">t</span>
</code></pre>
</div>

<p><code>fullEval</code> simply applies <code>eval</code> to <code>t</code> until it reaches a value term.</p>

<h2 id="toc_33">Automating Evaluation Derivation</h2>

<p>The <code>RuleMatch</code> instance is primarily geared toward building derivation trees. That&#39;s why the structure appears so awkward in use with <code>eval</code>.</p>
<div class="highlight"><pre><code class="haskell"><span class="kr">data</span> <span class="kt">Derivation</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Derivation</span> <span class="kt">InfRule</span> <span class="kt">Derivation</span> <span class="kt">Derivation</span> <span class="kt">Expr</span>
</code></pre>
</div>

<p>The <code>Derivation</code> data type is comprised of a tag from the <code>InfRule</code> enumeration, one <em>possible</em> derivation as a premise, the final derivation as the conclusion, and the expression representing the state of evaluation at a given moment. Taking the derivation tree of a simple example <code>(-&gt; (-&gt; true))() false</code> which is parsed to:</p>
<div class="highlight"><pre><code class="haskell"><span class="kt">Apply</span> <span class="p">(</span><span class="kt">Invoke</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">))))</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">)</span>
</code></pre>
</div>

<p>In english, the application of an invocation of a lambda with a lambda subterm to a boolean value. The resulting tree in the original notation takes the form:</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-derivation-trees-ast-example.png"></img>
</div>

<p>The <code>Derivation</code> instance has to work from the outside in so it&#39;s much harder to read than the notation, but it contains the same information</p>
<div class="highlight"><pre><code class="haskell"><span class="kt">Derivation</span> <span class="kt">AppEval</span>
  <span class="c1">-- |       premise        | |   e-inv value            |</span>
  <span class="p">(</span><span class="kt">Derivation</span> <span class="kt">Inv</span> <span class="kt">Empty</span> <span class="kt">Empty</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">)))</span>

  <span class="c1">-- |      conclusion      | |   e-app value   |</span>
  <span class="p">(</span><span class="kt">Derivation</span> <span class="kt">App</span> <span class="kt">Empty</span> <span class="kt">Empty</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">))</span>

  <span class="c1">-- |                e-app-eval value                  |</span>
  <span class="p">(</span><span class="kt">Apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">))</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">))</span>
</code></pre>
</div>

<p>It&#39;s clear that the applicand <code>(-&gt; (-&gt; true)()</code> needs evaluation using <em>e-app-eval</em> before it can be applied to the argument <code>false</code>. The premise of <em>e-app-eval</em> requires that the applicand take a step and here that means an invocation with <em>e-inv</em>. Finally the result of the invocation <code>(-&gt; true)</code> is applied to the <code>false</code> with <em>e-app</em> as the &quot;conclusion&quot; of the <em>e-app-eval</em>. In reality, <em>e-app</em> is applied to the result of the first derivation tree as it is with the logic notation.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- build a derivation from an expression</span>
<span class="nf">derive</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Derivation</span>
<span class="nf">derive</span> <span class="n">t</span> <span class="ow">=</span>
 <span class="kr">case</span> <span class="p">(</span><span class="n">matchRule</span> <span class="n">t</span><span class="p">)</span> <span class="kr">of</span>
  <span class="kt">None</span>                         <span class="ow">-&gt;</span> <span class="kt">Empty</span>
  <span class="p">(</span><span class="kt">RuleMatch</span> <span class="n">rule</span> <span class="kt">Nothing</span> <span class="n">t1</span><span class="p">)</span>  <span class="ow">-&gt;</span> <span class="kt">Derivation</span> <span class="n">rule</span> <span class="kt">Empty</span> <span class="p">(</span><span class="n">derive</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">evald</span><span class="p">)</span>
  <span class="p">(</span><span class="kt">RuleMatch</span> <span class="n">rule</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">t1</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Derivation</span> <span class="n">rule</span> <span class="p">(</span><span class="n">derive</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">derive</span> <span class="o">$</span> <span class="n">evald</span><span class="p">)</span> <span class="p">(</span><span class="n">evald</span><span class="p">)</span>
 <span class="kr">where</span> <span class="n">evald</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">t</span>
</code></pre>
</div>

<p>The <code>derive</code> function works in a similar fashion to <code>eval</code>. For a value/<code>None</code> result from <code>matchRules</code> there are no inference rules that apply. For <em>e-inv</em> or <em>e-app</em>, <code>derive</code> can recurse and build a derivation from the lambda&#39;s subterm. For <em>e-arg-eval</em> or <em>e-app-eval</em> the premise must be further derived and the conclusion is a derivation for the original term <code>t</code> with one evaluation step applied. That is, evaluating the subterm <code>t1</code> once inside the original term <code>t</code>. The use of <code>eval</code> to do that may look funny but it&#39;s just a convenience.</p>

<h2 id="toc_34">Automating Type Derivation</h2>

<p>Deriving the type for a term in the CoffeeScript subset is slightly less complex than deriving the evaluation. Again, a type rule is matched to each valid AST construction.</p>
<div class="highlight"><pre><code class="haskell"><span class="kr">data</span> <span class="kt">RuleMatch</span>  <span class="ow">=</span> <span class="kt">None</span> <span class="o">|</span> <span class="kt">RuleMatch</span> <span class="kt">TypeRule</span> <span class="kt">Expr</span>

<span class="c1">-- match a rule and provide the relevant sub terms for action</span>
<span class="nf">matchRule</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">RuleMatch</span>
</code></pre>
</div>

<p>The <code>RuleMatch</code> definition for types requires one less <code>Expr</code>. The <code>derive</code> and <code>fixType</code> definitions for types only require the first subterms in each expression. This is in contrast to <code>eval</code> which required both the conclusion and premise terms.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- t-true &amp; t-false</span>
<span class="nf">matchRule</span> <span class="n">b</span><span class="o">@</span><span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">)</span>    <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">TrueType</span> <span class="n">b</span>
<span class="nf">matchRule</span> <span class="n">b</span><span class="o">@</span><span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">)</span>   <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">FalseType</span> <span class="n">b</span>

<span class="c1">-- t-lambda</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">t</span><span class="p">)</span>              <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">LambdaType</span> <span class="n">t</span>

<span class="c1">-- t-inv</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Invoke</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="n">t</span><span class="p">))</span>     <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">Inv</span> <span class="n">t</span>

<span class="c1">-- t-apply</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Lambda</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="n">t</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Invoke</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span>  <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="n">t</span>
<span class="nf">matchRule</span> <span class="p">(</span><span class="kt">Apply</span> <span class="n">t</span><span class="o">@</span><span class="p">(</span><span class="kt">Apply</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="n">t</span>
</code></pre>
</div>

<p>The <code>Apply</code> matches capture only valid applicands and let the rest fall through to the error case. It&#39;s also worth noting that each of the <code>Apply</code> matches discards the argument term because it&#39;s unnecessary to the type of the expression. This fits with the definition of the type rules.</p>

<p>Fixing the type of a given expression is a simple recursive effort on applications. The <code>Type</code> data type captures both the <code>Bool</code> result, and the recursive <code>Arrow</code> type. For example <code>(-&gt; (-&gt; true))</code> has the type <code>Arrow (Arrow Bool)</code>.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- the two possible types for a given expression</span>
<span class="kr">data</span> <span class="kt">Type</span> <span class="ow">=</span> <span class="kt">Bool</span> <span class="o">|</span> <span class="kt">Arrow</span> <span class="kt">Type</span>

<span class="c1">-- determines the type of a given expression</span>
<span class="kr">data</span> <span class="kt">Derivation</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Derivation</span> <span class="kt">TypeRule</span> <span class="kt">Derivation</span> <span class="kt">Type</span>

<span class="nf">fixType</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Type</span>
<span class="nf">fixType</span> <span class="n">t</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="p">(</span><span class="n">matchRule</span> <span class="n">t</span><span class="p">)</span> <span class="kr">of</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">TrueType</span> <span class="kr">_</span><span class="p">)</span>    <span class="ow">-&gt;</span> <span class="kt">Bool</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">FalseType</span> <span class="kr">_</span><span class="p">)</span>   <span class="ow">-&gt;</span> <span class="kt">Bool</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">LambdaType</span> <span class="n">t1</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Arrow</span> <span class="o">$</span> <span class="n">fixType</span> <span class="n">t1</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">Inv</span> <span class="n">t1</span><span class="p">)</span>        <span class="ow">-&gt;</span> <span class="n">fixType</span> <span class="n">t1</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">App</span> <span class="kr">_</span><span class="p">)</span>         <span class="ow">-&gt;</span> <span class="n">fixType</span> <span class="o">$</span> <span class="n">eval</span> <span class="n">t</span>
</code></pre>
</div>

<p>The type of an invocation is determined by the lambda&#39;s subterm, so <code>matchRule</code> provides that as <code>t1</code> here for further type information. The type of an application is dependent on the type of it&#39;s first argument, so we cheat a bit here and use the single step <code>eval</code> to get at the result of the application.</p>
<div class="highlight"><pre><code class="haskell"><span class="nf">derive</span> <span class="ow">::</span> <span class="kt">Expr</span> <span class="ow">-&gt;</span> <span class="kt">Derivation</span>
<span class="nf">derive</span> <span class="n">t</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="p">(</span><span class="n">matchRule</span> <span class="n">t</span><span class="p">)</span> <span class="kr">of</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">TrueType</span> <span class="kr">_</span><span class="p">)</span>    <span class="ow">-&gt;</span> <span class="kt">Derivation</span> <span class="kt">TrueType</span> <span class="kt">Empty</span> <span class="o">$</span> <span class="n">fixType</span> <span class="n">t</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="kt">FalseType</span> <span class="kr">_</span> <span class="p">)</span>  <span class="ow">-&gt;</span> <span class="kt">Derivation</span> <span class="kt">FalseType</span> <span class="kt">Empty</span> <span class="o">$</span> <span class="n">fixType</span> <span class="n">t</span>
      <span class="p">(</span><span class="kt">RuleMatch</span> <span class="n">rule</span> <span class="n">t1</span><span class="p">)</span>       <span class="ow">-&gt;</span> <span class="kt">Derivation</span> <span class="n">rule</span> <span class="p">(</span><span class="n">derive</span> <span class="n">t1</span><span class="p">)</span> <span class="o">$</span> <span class="n">fixType</span> <span class="n">t</span>
</code></pre>
</div>

<p>The type rules are much easier to apply, they simply descend into the terms to build up the type, providing the fixed type at each step as the conclusion. Taking the same example from the evaluation rules earlier <code>(-&gt; (-&gt; true))() false</code> which is parsed to:</p>
<div class="highlight"><pre><code class="haskell"><span class="kt">Apply</span> <span class="p">(</span><span class="kt">Invoke</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">))))</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">)</span>
</code></pre>
</div>

<p>The type derivation using logic notation looks like:</p>

<div class="center">
  <img style="width: 300px" src="/assets/images/diagrams/math-envy-cs/cs-type-derivation-ast-example.png"></img>
</div>

<p>The <code>Derivation</code> instance corresponding the the logic notation is again much larger but captures the same information (formatting added after the fact):</p>
<div class="highlight"><pre><code class="haskell"><span class="kt">Derivation</span> <span class="kt">App</span>
  <span class="p">(</span><span class="kt">Derivation</span> <span class="kt">Inv</span>
    <span class="p">(</span><span class="kt">Derivation</span> <span class="kt">LambdaType</span>
      <span class="p">(</span><span class="kt">Derivation</span> <span class="kt">TrueType</span> <span class="kt">Nothing</span> <span class="kt">Bool</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="kt">Bool</span><span class="p">)</span> <span class="c1">-- Lambda type is X -&gt; &lt;subterm type&gt;</span>
  <span class="p">)</span> <span class="p">(</span><span class="kt">Arrow</span> <span class="kt">Bool</span><span class="p">)</span> <span class="c1">-- Inv type is it&#39;s subterm&#39;s type</span>
<span class="p">)</span> <span class="kt">Bool</span> <span class="c1">-- App type T in the applicand&#39;s X -&gt; T</span>
</code></pre>
</div>

<p>As noted in the comments each step in the derivation resolves the type at that step based on the inference rules.</p>

<h2 id="toc_35">Detecting Ambiguity</h2>

<p>So far we&#39;ve seen that it&#39;s possible to build an understanding of evaluation and typing that provides more information than just the evaluation result or the fixed type for a term. Capturing that extra information, a term can be represented by a triple <code>(S, E, T)</code>, where <code>S</code> is the syntax string of the term, <code>E</code> is the evaluation derivation, and <code>T</code> is the type derivation. This triple can be used to determine whether two terms will cause confusion.</p>

<p>One approach is to first compare the <code>S</code> values for two terms and then determine if the <code>E</code> and <code>T</code> values match. Terms with &quot;similar&quot; <code>S</code> values but different <code>E</code> or <code>T</code> values might be ambiguous and could be flagged for review. Using the <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein Distance</a> to keep the calculation for similarity simple:</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-dist.png"></img>
</div>

<p><em>lev</em> is the Levenshtein distance function and <em>dist</em> is just the ratio of the distance between the two strings and the maximum length of both. This is sometimes referred to as the Levenshtein Ratio. For <code>(-&gt; true)() -&gt; false</code> and <code>(-&gt; true) () -&gt; false</code>:</p>

<div class="center">
  <img style="width: 300px" src="/assets/images/diagrams/math-envy-cs/cs-dist-example.png"></img>
</div>

<p>A relative value for string distance that can be used as a threshold &quot;setting&quot; makes building a tool for automating the process easier. That is, if two terms are deemed &quot;close enough&quot; by virtue of their <em>dist</em> value being below a predetermined threshold and they have different information in either <code>E</code> or <code>T</code> then they might be flagged [3].</p>

<h2 id="toc_36">Fuzzy Search</h2>

<p>We now have enough information to define a system that will automate the exploration of the &quot;term space&quot; (all term combinations), and run a check against existing known terms for ambiguous pairs for each generated term.</p>

<p>Storing the triple of known terms for comparison is fairly easy with the text search capabilities available in most modern databases. One might even <a href="http://www.artfulsoftware.com/infotree/qrytip.php?id=552">implement</a> the Levenshtein Distance function and use it to check a new term against known terms. It may be that a purpose built data structure for the storage and retrieval based on a text search algorithm would perform better, but a good all purpose RDBMS would be fine for a first pass.</p>

<p>More interesting is the generation of terms for a non-trivial language. A <em>term generator</em> would start with atomic types and successively wrap them in terms defined to have subterms. That part can likely be performed with nothing more than knowledge of the grammar. There are two issues with this.</p>

<p>First, the complexity of many programming languages makes re-examining the same terms an enormous waste of time. Tracking the explored terms and &quot;resuming&quot; the exploration process would have a lot of value. Second, generating the derivations to store and compare along with the syntax is an involved effort. Again, it&#39;s easy to tag a piece of syntax with the result of execution or typing but information is lost.</p>

<h2 id="toc_37">Quick and Dirty</h2>

<p>A less complicated representation of a term might still be effective, and could avoid extra effort required of the language creator in generating the evaluation and type derivations. For example the tuple <code>(S, A)</code>, where <code>S</code> remains the syntax of the term and <code>A</code> is the AST representation.</p>
<div class="highlight"><pre><code class="haskell"><span class="p">(</span> <span class="s">&quot;(-&gt; true)() -&gt; false&quot;</span><span class="p">,</span>
  <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Invoke</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">)))</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">))</span> <span class="p">)</span>

<span class="p">(</span> <span class="s">&quot;(-&gt; true) () -&gt; false&quot;</span><span class="p">,</span>
  <span class="kt">Apply</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">True</span><span class="p">))</span> <span class="p">(</span><span class="kt">Lambda</span> <span class="p">(</span><span class="kt">BooleanExpr</span> <span class="kt">False</span><span class="p">))</span> <span class="p">)</span>
</code></pre>
</div>

<p>It&#39;s obvious that the abstract representations capture the issue at hand even if there is some information lost [4]. Best of all the AST for a term is available regardless of the host language and serialization is the only extra requirement. Having a term generator that works with a (E)BNF, a way to generate the AST for a term (presumably through the language parser), and a database equipped with the ability to find like terms it seems entirely possible to alert the language creator of complex or convoluted pairings.</p>

<h2 id="toc_38">Further Work</h2>

<p>First I have to apologize for not building out a tool for generating terms or a schema for term storage. I wanted to do the automated evaluation and type derivations to get a feel for the effort involved and the result was an exceptionally long post. If I find the time to return to this I&#39;d like to build out the term generator and couple it with a simple database. I think that going through the process of building a BNF parser would be a lot of fun by itself.</p>

<p>In the course of these two posts we&#39;ve seen what it looks like to formalize both the evaluation and type semantics of a simple programming language. We&#39;ve also come to a relatively satisfying formalization of semantic ambiguity that could be used in conjunction with a common language definition form (BNF, EBNF) to alert a language designer of potential issues [5] [6].</p>

<h3 id="toc_39">footnotes</h3>

<ol>
<li>It might be that when a function identifier is the only difference between terms, here <code>*</code> and <code>+</code>, it&#39;s reasonable to ignore ambiguous terms. In this case because the total string length for both terms is small it might be that a single character difference is enough to break some arbitrary threshold. I&#39;m leaving this for further consideration.</li>
<li>The implementation in Haskell forced these issues out into the open. I&#39;m curious if proving progress and preservation would have pointed out the flaws in my approach (this may be obvious one way or another to a better educated reader).</li>
<li>Assuming it&#39;s possible, it&#39;s interesting to think about what the inverse result means. That is, when two terms are very syntactically different but have identical types/evaluation derivations. This might signal the two terms or the parent language as antithetical to Python&#39;s slogan of &quot;one and only one way to do it&quot;.</li>
<li>For example, the AST doesn&#39;t capture the type of lambda form that was used. This may be useful information even if this particular example doesn&#39;t require it.</li>
<li>Though it would be infinitely more satisfying if we could build a tool based on the ideas and arrive at that same conclusions about this CoffeeScript subset and a few other BNF friendly languages.</li>
<li>It&#39;s worth pointing out that the CoffeeScript issue with lambdas and invocation <a href="http://news.ycombinator.com/item?id=4849151">has been/was known to Jeremy</a>. It was simply a choice in favor of flexibility. I like to think that the hypothetical tool presented here would be useful in cases where ambiguous term pairings are less obvious and for people who may want less flexibility.</li>
<li>A special thanks to <a href="http://twitter.com/keyist">keyist</a> for proofreading.</li>
</ol>

  </div>

  <div id="info" class="span2">
    
    <h4>Vote/Comment</h4>
    <ul id="vote">
      <li>
        <a id="hn" href="http://news.ycombinator.com/" alt="Hacker News">Hacker News</a>
      </li>
    </ul>
    

    <h4>Published</h4>
    <div class="date">
      <span>09 Jan 2013</span>
    </div>

    
    <h4>Tags</h4>
    <ul class="tag_box">
      
      


  
    
    	<li><a href="/archive.html#coffeescript">coffeescript <span>4</span></a></li>
    
    	<li><a href="/archive.html#javascript">javascript <span>10</span></a></li>
    
    	<li><a href="/archive.html#math">math <span>12</span></a></li>
    
  



    </ul>
    
  </div>
</div>

<div class="page-header">
  <h1><a href="//johnbender.github.com/2012/11/27/math-envy-and-coffeescripts-foibles">Math Envy and CoffeeScript's Foibles, Part 1</a></h1>
</div>

<div class="row-fluid">
  <div class="span10 text">
    <p>At Strange Loop 2011 in a <a href="http://www.infoq.com/presentations/Language-Panel">language panel (5:06)</a>, Jeremy Ashkenas was asked, &quot;What is the worst idea that was ever introduced into programming languages that continues to afflict us today?&quot; He responded, &quot;... mathematics envy&quot;. I agree with Mr. Ashkenas in part. Math appears to get in the way on occasion [1]. Even so it struck me as an odd response given that much of computing is built on the work of great mathematicians. For a modern example look no further than the <a href="http://wingolog.org/archives/2011/08/02/a-closer-look-at-crankshaft-v8s-optimizing-compiler">inner workings</a> of V8&#39;s optimizing compiler that runs a lot of Jeremy&#39;s code.</p>

<p>Fast forward a year and issues with CoffeeScript&#39;s flexible syntax start popping up in <a href="http://surana.wordpress.com/2011/02/08/coffeescript-oddities/">blog</a> <a href="http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/">posts</a>. Interactions between whitespace, operators, comprehensions, and lambda declarations appear to be a source of confusion. To be fair, it sounds like these examples rarely cause serious problems, but it left me wondering if they could have been avoided during the creation of the language. That is, could the timely application of mathematics have prevented these problems early in CoffeeScript&#39;s creation?</p>

<p>What follows is the first of two posts aimed at answering that question. This post provides an introduction to operational semantics, a description of one semantic issue in CoffeeScript, and the operational semantics for a CoffeeScript subset capable of reproducing said issue. The second post will introduce type derivations, define them for the same CoffeeScript subset, and attempt to formalize semantic ambiguity more completely. The background needed to understand the math is covered, but the post generally follows my thought process.</p>

<h2 id="toc_19">CoffeeScript Confusion</h2>

<p>I&#39;ve chosen to address the lambda syntax cited by both of the linked posts. Specifically the option to omit parenthesis in lambda declarations and how that interacts with 0-arity lambdas as arguments. Here&#39;s an example borrowed from Manuel Cerón&#39;s <a href="http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/">post</a>.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="nv">doSomething = </span><span class="nf">() -&gt;</span> <span class="kc">true</span>

<span class="nx">doSomething</span> <span class="nf">() -&gt;</span>  <span class="kc">false</span>

<span class="nx">doSomething</span><span class="nf">() -&gt;</span>  <span class="kc">false</span>
<span class="c1"># !!! =&gt; true(-&gt; false);</span>
</code></pre>
</div>

<p>The first invocation of <code>doSomething</code> applies it to the inline lambda. The second invokes it directly with the <code>()</code> operator and then attempts to apply the result <code>true</code> to a lambda defined with <code>-&gt; false</code>. This results in a type error. For clarity here&#39;s the equivalent in JavaScript.</p>
<div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">};</span>

<span class="nx">doSomething</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">});</span>

<span class="nx">doSomething</span><span class="p">()(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">// !!! =&gt; true(function(){ return false; });</span>
</code></pre>
</div>

<p>It&#39;s easy to see where this might cause issues given that the only difference between the two expressions is a single whitespace character. The goal then is to apply some formalism to this part of CoffeeScript. Ideally the formalism will result in an approach, technique, or tool that can highlight problems like this for a language designer <em>during</em> language creation.</p>

<h2 id="toc_20">Operational Semantics</h2>

<p>Operational Semantics is one way [2] to formalize the semantics of a programming language. We&#39;ll build a basic understanding of how it works by borrowing an example language from Pierce&#39;s book <em>Types and Programming Languages</em> [3].</p>

<div class="center">
  <img style="width: 40%; min-width: 200px;" src="/assets/images/diagrams/math-envy-cs/bool-grammar.png"></img>
</div>

<p>The grammar definition is made of up of two &quot;meta variables&quot; <code>t</code> and <code>v</code>. Assigned to those meta variables is a set of possible terms each separated by a <code>|</code>. <code>t</code> represents all of the ways to construct terms (see example below). <code>v</code> is the set of terms that are acceptable as the final result of evaluation. <code>v</code> is a subset of <code>t</code>, as witnessed by its inclusion in <code>t</code>, but it is distinct for a reason.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- simple values</span>
<span class="nf">true</span>
<span class="nf">false</span>

<span class="c1">-- a simple compound term</span>
<span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">true</span>

<span class="c1">-- a more complex compound term, parens for clarity</span>
<span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">true</span><span class="p">)</span>
</code></pre>
</div>

<p><code>v</code>&#39;s distinction means that any term like the second and third in the example has to eventually evaluate to a term in <code>v</code>, either <code>true</code> or <code>false</code>. Any other result means that something is &quot;stuck&quot; (a definition for &quot;stuck&quot; will be covered later). It also means that <code>true</code> and <code>false</code> cannot evaluate further.</p>

<p>Notice that that the only other construct in the grammar, <code>if t then t else t</code>, has subterms represented with the meta variable <code>t</code>. This captures the ability to use <code>true</code>, <code>false</code>, or another <code>if t then t else t</code> for each subterm (eg, second and third examples).</p>

<p>With the building blocks in place the next step is to establish a set of rules that will define the way terms are evaluated. That is, what steps should be used to reduce any term to <code>true</code> or <code>false</code>, and in what order they should be taken. Superficially this language seems extremely simple, but there are some subtle details of term evaluation that need to be captured.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/bool-inference-rules.png"></img>
</div>

<p>These equations are collectively referred to as the <em>evaluation relation</em> and individually as <em>inference rules</em>. Each of them plays an important role in the <em>evaluation strategy</em> of the example which instructs the reader in how to evaluate a term in the language. All of them are tagged with a name preceded by an &quot;<em>e-</em>&quot; for evaluation. The tags will be helpful when referring to the rules and later to keep them visually distinct from type rules.</p>

<p><em>e-true</em> and <em>e-false</em> are fairly simple. They represent the expected evaluation results for the different guard values in an <code>if t then t else t</code> term. With <code>true</code> you get the first subterm and with <code>false</code> you get the second subterm. Also, notice that there are no rules for either <code>true</code> or <code>false</code> by themselves. This further reinforces that <code>true</code> and <code>false</code> are values and that there&#39;s no way to evaluate them further. <em>e-if</em> is more interesting in its construction and how it captures an important part of the evaluation strategy.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/bool-inference-rules-guard.png"></img>
</div>

<p>There are two parts to this rule. Above the line is the <em>premise</em> and below is the <em>conclusion</em>. The premise establishes a requirement or precondition for applying the conclusion to a given term. Later we&#39;ll see how the premise is replaced by the conclusion of another rule. For <em>e-if</em> the premise says that if the first subterm <code>t</code> can be evaluated to <code>t&#39;</code> then the parent term <code>if t then t else t</code> should evaluate to <code>if t&#39; then t else t</code>. The importance is that evaluation will focus on the guard term and not the other subterms. A different evaluation strategy might fully evaluate the second or third subterms before evaluating the first subterm.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- parenthesis are supplied for clarity only</span>
<span class="c1">-- |     first/guard subterm     |      |       second subterm        |</span>
<span class="kr">if</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">false</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="n">true</span> <span class="kr">else</span> <span class="n">false</span><span class="p">)</span> <span class="kr">else</span> <span class="n">false</span>
</code></pre>
</div>

<p>This term could take two different evaluation paths without <em>e-if</em>. An alternative strategy would first evaluate the second subterm <code>if false then true else false</code> to <code>false</code>, then evaluate the guard <code>if true then false else false</code> to <code>false</code>, and finally the full term to <code>false</code>. Obviously the evaluation of the second subterm is unnecessary because the guard term evaluates to <code>false</code> and the second subterm is ignored completely.</p>

<p>There is enough information here for an interested party to implement this language without wondering about how to construct terms or how those terms should be evaluated. Additionally there are interesting properties that can be proved inductively using the inferences rules. For example it&#39;s possible to show that there is one and only one way to evaluate each term at each step [4]. The next step then is to turn back to CoffeeScript and begin apply operational semantics to see if anything interesting happens.</p>

<h2 id="toc_21">CoffeeScript Grammar</h2>

<p>The grammar will cover the subset of CoffeeScript necessary to reproduce the aforementioned ambiguity. In the original example, the overhead of assignment and identifiers can be avoided by using lambda expressions directly.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="nf">() -&gt;</span>  <span class="kc">false</span>
<span class="c1"># =&gt; true</span>

<span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span><span class="nf">() -&gt;</span>  <span class="kc">false</span>
<span class="c1"># !!! =&gt; true(function(){ return false; });</span>
</code></pre>
</div>

<p>This translates into JavaScript like the original example:</p>
<div class="highlight"><pre><code class="javascript"><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">})(</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// =&gt; true</span>

<span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">})()(</span><span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// !!! =&gt; true(function(){ return false; });</span>
</code></pre>
</div>

<p>Note that the use of atomic boolean values alleviates the need for arguments in the lambda syntax. Again, simplicity in reproducing the issue is preferred for the sake of brevity. Next is a precise definition of terms in the form of a language grammar.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-grammar.png"></img>
</div>

<p>To reiterate, the left hand side of each <code>::=</code> assignment is a meta variable that can be used in other parts of the grammar. In the case of <code>\t</code> it was easier to create a meta term than to repeat each possible lambda form in <code>t</code>. <code>v</code> on the other hand is the set of acceptable final results of evaluation. Finally <code>t</code> is complete set of forms used to build terms. Notable among them is the invocation and application of lambda terms, <code>\t</code>.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="c1"># invocation</span>
<span class="p">(</span><span class="o">-&gt;</span> <span class="kc">false</span><span class="p">)()</span>

<span class="c1"># application</span>
<span class="p">(</span><span class="nf">() -&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="kc">true</span>

<span class="c1"># both</span>
<span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="nf">() -&gt;</span> <span class="kc">true</span><span class="p">))()</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span>
</code></pre>
</div>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-grammar-examples.png"></img>
</div>

<p>The most important part to note is that lambda terms capture the subterm be it <code>true</code>, <code>false</code> or another lambda.</p>

<p>Looking at the examples it&#39;s reasonable to ask whether there&#39;s value in providing a grammar that looks a lot like it&#39;s own language. First, it maps the two different lambda forms to one form in the grammar, which makes reasoning about evaluation and types easier. Second, differentiating values (<code>true</code>, <code>false</code>, and <code>-&gt; t</code>) from other terms by calling them values is important for knowing when evaluation has finished.</p>

<h2 id="toc_22">Inference Rules</h2>

<p>With the grammar in place the next step is to define both the inference rules and evaluation strategy. Obviously it will use the call-by-value, left to right strategy [5] employed by CoffeeScript and JavaScript.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-inference-rules.png"></img>
</div>

<p>The only impact of the evaluation strategy (call-by-value l-to-r) is that arguments to lambda terms must be fully evaluated before application can take place. For example <code>(-&gt; true) (-&gt; false)()</code> would first evaluate to <code>(-&gt; true) false</code> as a result of the <code>()</code> operator.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-inference-rules-application.png"></img>
</div>

<p>The <code>v</code> in <em>e-app</em> means that any argument to a lambda term should be fully evaluated. In other words it should be a term in the meta variable set <code>v</code>. Once applied, the result is the lambda&#39;s unaltered subterm.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-inference-rules-application-argument.png"></img>
</div>

<p><em>e-arg-eval</em> stipulates in the premise (above the bar) that if the lambda argument term can take a step of evaluation it should. <em>e-app</em> informs the reader when lambda application can take place and <em>e-arg-eval</em> informs the reader how to get there. Taken together these three rules define how terms get evaluated.</p>

<h2 id="toc_23">Derivation Trees</h2>

<p>The inference rules in an operational semantics definition can be used in <em>derivation trees</em> to show how a terms will evaluate. Rules are &quot;stacked&quot; on one another to show how they work in succession to produce an evaluation result.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- parenthesis are supplied for clarity only</span>
<span class="c1">-- |     first/guard subterm     |      |       second subterm        |</span>
<span class="kr">if</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">false</span><span class="p">)</span> <span class="kr">then</span> <span class="p">(</span><span class="kr">if</span> <span class="n">false</span> <span class="kr">then</span> <span class="n">true</span> <span class="kr">else</span> <span class="n">false</span><span class="p">)</span> <span class="kr">else</span> <span class="n">false</span>
</code></pre>
</div>

<p>The derivation trees for the evaluation of this term result in <code>false</code>.</p>

<div class="center">
  <img class="wide" src="/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example.png"></img>
</div>

<p>Unfortunately the way these two &quot;trees&quot; are constructed isn&#39;t obvious. First, taking the second subterm and replacing it with a variable prevents the equations from getting too long. We already know that the second sub term isn&#39;t important in the final evaluation (see the introductory section on operational semantics) and it&#39;s easier to read the equations when they aren&#39;t squished</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example-simplify.png"></img>
</div>

<p>From the inference rules <em>e-true</em>, <em>e-false</em>, and <em>e-if</em> one will apply to begin simplifying the term. The obvious place to start is applying <em>e-true</em> to the first subterm <code>(if true then false else false)</code>, but the second subterm <code>(if false then true else false)</code> could just as easily have <em>e-false</em> applied to it. Recall that the third rule <em>e-if</em> tells the reader which will take precedence. It says that if the guard (first subterm) can be evaluated it should be, leaving us to evaluate the first subterm using <em>e-true</em> as the first part of the derivation tree.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/bool-derivation-tree-first-rule.png"></img>
</div>

<p>It&#39;s easy to see that this looks just like the &quot;raw&quot; form of the <em>e-true</em> rule. The only difference is the replacement of the last two subterms with <code>false</code> on the left side of the arrow and the resulting subterm with <code>false</code> on the right side of the arrow. It might look a little confusing with the bar resting on top of the <em>e-true</em> rule, but that signifies the applied rule has no premise/precondition. Next, since  <em>e-if</em> forced the application of <em>e-true</em>, it makes sense that it figures in to the derivation tree. Importantly <em>e-if</em> has a precondition, one which the application of <em>e-true</em> satisfies.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/bool-inference-rules-guard.png"></img>
</div>

<p><em>e-if</em>&#39;s precondition requires that the first subterm of an <code>if t then t else t</code> evaluate before the other two subterms. In other words it requires that <code>t -&gt; t&#39;</code> be replaced by some evaluation.</p>

<div class="center">
  <img class="wide" src="/assets/images/diagrams/math-envy-cs/bool-derivation-tree-second-rule.png"></img>
</div>

<p>Here, it&#39;s been replaced by <code>if true then false else false -&gt; false</code> from the application of <em>e-true</em>. The bottom/conclusion of the inference rule is replaced by the whole term evaluated to replace the first subterm with <code>false</code>. It&#39;s a &quot;stack&quot; of the two inference rules <em>e-true</em> and <em>e-if</em>. All that&#39;s left is to build a derivation tree for <code>if false then t else false</code>.</p>

<div class="center">
  <img class="wide" src="/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example-assoc.png"></img>
</div>

<p><em>e-false</em> is all that&#39;s needed for the second tree to complete the evaluation to <code>false</code>. At this point it may seem odd to call any part of this a derivation &quot;tree&quot;, but a more complex rule could have multiple terms in the premise resulting in a tree like structure.</p>

<h2 id="toc_24">Evaluating a Solution</h2>

<p>Finally we know enough to apply the operational semantics to our problem. First the least complex term that prevents evaluation.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span><span class="nf">() -&gt;</span> <span class="kc">false</span>
</code></pre>
</div>

<p>Translating this example into the grammar representation yields a form that will work with the inference rules.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-derivation-trees-stuck.png"></img>
</div>

<p><em>e-inv</em> is applied to <code>(-&gt; true)()</code> because <code>-&gt; false</code> can&#39;t evaluate any further (it&#39;s a value in <code>v</code>), but then what? After applying <em>e-inv</em> the first subterm is <code>true</code> and there are no evaluation rules that apply values to an arguement. Without any rules to apply to a term that isn&#39;t a value, it&#39;s &quot;stuck&quot;.</p>

<p>Here someone will say, &quot;We already knew that because there&#39;s a type error when you evaluate the JavaScript!&quot;. Consider a slightly more complex example.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">))</span><span class="nf">() -&gt;</span> <span class="kc">false</span>
</code></pre>
</div>

<p>And the derivation tree to match.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-derivation-trees-not-stuck.png"></img>
</div>

<p>The value returned by the first lambda <strong>can</strong> be applied to an argument with <em>e-app</em> so the result of evaluation is <code>true</code>. Viewing the accompanying term with an additional space will provide contrast.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">))</span> <span class="nf">() -&gt;</span> <span class="kc">false</span>
</code></pre>
</div>

<p>In this case, the derivation tree consists of a single inference rule, <em>e-app</em>.</p>

<div class="center">
  <img src="/assets/images/diagrams/math-envy-cs/cs-derivation-trees-not-stuck-with-space.png"></img>
</div>

<p>Clearly the two terms are syntactically similar but each has a very different meaning. This semantic differentiation makes it possible to think about a concrete notion of semantic ambiguity in a programming language. Informally, if two terms are <em>very similar</em> syntactically but have different derivation trees they are semantically ambiguous.</p>

<p>There are two problems with this definition if the goal is to come up with something useful for actual language implementers. First, &quot;very similar&quot; is nebulous. Luckily computer science is littered with string &quot;distance&quot; algorithms. Second, automatically generating derivation trees for terms is likely to be difficult.</p>

<p>It might be possible to just compare evaluation results instead of the derivation trees but there are problems with that approach. In the example boolean language it&#39;s extremely easy to define two terms that evaluate to an identical result but have different derivation trees.</p>
<div class="highlight"><pre><code class="haskell"><span class="c1">-- example one</span>
<span class="kr">if</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">true</span> <span class="kr">else</span> <span class="n">true</span><span class="p">)</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">true</span><span class="p">)</span>

<span class="c1">-- example two</span>
<span class="kr">if</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">true</span><span class="p">)</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">true</span> <span class="kr">then</span> <span class="n">false</span> <span class="kr">else</span> <span class="n">true</span><span class="p">)</span>
</code></pre>
</div>

<p>The fact that the evaluation path is very different gets lost in a forest of <code>true</code>&#39;s and <code>false</code>&#39;s. More concretely the string distance between the two terms is at most 5 characters out of 78, but the first example has a derivation tree with three rules (<em>e-true</em>, <em>e-if</em>, <em>e-false</em>) against the second&#39;s four (<em>e-true</em>, <em>e-if</em>, <em>e-false</em>, <em>e-true</em>). Again, this is in spite of the fact that the evaluation <em>result</em> is <code>false</code> in both cases. You really can&#39;t tell with the naked eye how different the evaluation is and in a language with side effects the difference could be critical. If the result of this work will be general it must account for this subtlety even if it doesn&#39;t crop up with the CoffeeScript guinea pig.</p>

<h2 id="toc_25">Next Time</h2>

<p>In the next post I&#39;ll take a look at how type information could replace the derivation trees as the semantic differentiator. Type information is often readily available even in languages like CoffeeScript that don&#39;t have type annotations. If finding a difference between two terms is simple enough maybe a tool can be built to automate the process of ferreting out confusing term pairings.</p>

<h3 id="toc_26">footnotes</h3>

<ol>
<li>An example is the confusion over Monads and Functors in Haskell. This is due in part to odd names and their relationship with mathematics.</li>
<li><a href="http://en.wikipedia.org/wiki/Denotational_semantics">Denotational Semantics</a> and <a href="http://en.wikipedia.org/wiki/Axiomatic_semantics">Axiomatic Semantics</a> are alternate ways to define language semantics.</li>
<li>This example language is borrowed almost verbatim from Types and Programming Languages but I&#39;ve added in my own explanation. I cannot over emphasize how much this book has contributed to my education over the last year or so.</li>
<li>This Theorem is referred to as Determinacy of Evaluation. I may go back and do some simple proofs for my own education after this post and a possible follow up.</li>
<li>Technically JavaScript uses a strategy known as Call by Sharing, which differs from Call by Value in how deals with objects. More information <a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/%20courtesy%20of%20%5B@raganwald%5D(https://twitter.com/raganwald">here</a>.</li>
</ol>

  </div>

  <div id="info" class="span2">
    
    <h4>Vote/Comment</h4>
    <ul id="vote">
      <li>
        <a id="hn" href="http://news.ycombinator.com/item?id=4848974" alt="Hacker News">Hacker News</a>
      </li>
    </ul>
    

    <h4>Published</h4>
    <div class="date">
      <span>27 Nov 2012</span>
    </div>

    
    <h4>Tags</h4>
    <ul class="tag_box">
      
      


  
    
    	<li><a href="/archive.html#coffeescript">coffeescript <span>4</span></a></li>
    
    	<li><a href="/archive.html#javascript">javascript <span>10</span></a></li>
    
    	<li><a href="/archive.html#math">math <span>12</span></a></li>
    
  



    </ul>
    
  </div>
</div>


      </div>

    <div class="pagination">
      <ul>
      
        <li class="prev disabled"><a>&larr; Previous</a></li>
      
        <li><a href="//johnbender.github.com/archive.html">Archive</a></li>
      
        <li class="next disabled"><a>Next &rarr;</a>
      
      </ul>
    </div>

    <footer>
      <p>&copy; John Bender 2012
        with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
      </p>
    </footer>

    </div>

    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21257360-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




  </body>
</html>

