<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>johnbender.us</title>
 <link href="http://johnbender.github.com/atom.xml" rel="self"/>
 <link href="http://johnbender.github.com"/>
 <updated>2013-11-04T23:33:06-08:00</updated>
 <id>http://johnbender.github.com</id>
 <author>
   <name>John Bender</name>
   <email>john.m.bender@gmail.com</email>
 </author>

 
 <entry>
   <title>A Better SQL, Part 1</title>
   <link href="http://johnbender.github.com/2013/11/04/a-better-sql"/>
   <updated>2013-11-04T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2013/11/04/a-better-sql</id>
   <content type="html">&lt;p&gt;The relational model for data is ubiquitous. That&amp;#39;s in part due to SQL&amp;#39;s declarative approach to manipulating and exploring data stored as relations. Unfortunately SQL has its warts. In particular schema changes made in the data definition subset of the language (DDL) [1] can be awkward for creating idempotent migrations. Enough so, that the responsibility is frequently delegated to the application layer where more expressive languages can be employed. In this, the first of two posts proposing improvements to SQL, I&amp;#39;ll lay out an alternate semantics for SQL DDL that embraces schema change and expands the expressive power of DDL&amp;#39;s declarative core.&lt;/p&gt;

&lt;h2 id=&quot;toc_59&quot;&gt;A Common Activity&lt;/h2&gt;

&lt;p&gt;To illustrate how schema changes break the initially declarative semantics of DDL, lets look at an example:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All tables start this way. The only piece of syntax that might otherwise alert a new user to the fact that this is not an entirely descriptive declarative language is &lt;code&gt;create&lt;/code&gt;. The definition is very much &amp;quot;what&amp;quot; is desired and not &amp;quot;how&amp;quot; to get it. This breaks down when anything about the table needs to change:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bak&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All together this will ensure the proper end-state whether the target database is at the initial state without the table &lt;code&gt;foo&lt;/code&gt; or at the second state where &lt;code&gt;foo&lt;/code&gt; lacks the column &lt;code&gt;bak&lt;/code&gt;. In this case it&amp;#39;s easy to understand the final state of the table because the example is very simple, but it&amp;#39;s acquired an imperative pall with the inclusion of the first &lt;code&gt;alter&lt;/code&gt;. As the schema definition grows more complex through many &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, and type cast changes, the final state of the table becomes less clear:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;exists&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bak&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bak&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baks&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It would be better to simply add columns to the original table definition, and then the shape of the resulting table would be immediately clear at a glance.&lt;/p&gt;

&lt;h2 id=&quot;toc_60&quot;&gt;Differential Semantics&lt;/h2&gt;

&lt;p&gt;In our toy example the desired table definition included a new column &lt;code&gt;bak&lt;/code&gt;. An entirely descriptive update to the table declaration would look like this (Note that the original alter statement is absent):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;baz&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bak&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Unfortunately the SQL runtime considers the syntax in isolation and makes no attempt to reconcile that with it&amp;#39;s internal representation. That makes perfect sense because a user is permitted to run small, ad hoc snippets in addition to full schema migration scripts. That is, the RDBMS can&amp;#39;t know where this declaration is coming from nor why it&amp;#39;s being run so it&amp;#39;s unsafe to assume it should do any reconciliation. In contrast a well outfitted user can provide exactly that information.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;diff&quot;&gt;&lt;span class=&quot;gu&quot;&gt;@@ -1,4 +1,5 @@&lt;/span&gt;
 create table foo (l;
   bar int,
&lt;span class=&quot;gd&quot;&gt;-  baz text&lt;/span&gt;
&lt;span class=&quot;gi&quot;&gt;+  baz text,&lt;/span&gt;
&lt;span class=&quot;gi&quot;&gt;+  bak text&lt;/span&gt;
 );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Looking at the diff, it&amp;#39;s clear that the intention is to add the column &lt;code&gt;bak&lt;/code&gt; to the table. What&amp;#39;s required then, is to assign some semantics to this diff. With that established a simple pre-processor could map this differential to the corresponding alter statement in DDL, namely the original alter statement.&lt;/p&gt;

&lt;p&gt;The key insight here is that we can permit schema migrations while retaining an entirely descriptive declarative syntax by appealing to the differential information available via source control tools.&lt;/p&gt;

&lt;h2 id=&quot;toc_61&quot;&gt;Value Proposition&lt;/h2&gt;

&lt;p&gt;The basic value proposition is reduced cognitive overhead when maintaining schemas using SQL DDL. In addition, DDL&amp;#39;s syntax is reduced by about half because alters and drops [2] can simply go away which should make it easier to learn [3].&lt;/p&gt;

&lt;p&gt;This could also be pushed up the stack to migration tools by an enterprising library or framework author. For example, Rails generates and maintains a &lt;code&gt;db/schema.rb&lt;/code&gt; file that is supposed to represent the state of the schema for the associated migrations. A similar technique could be applied there to divine the appropriate alterations when an change to that file is made in place of using migrations for schema changes.&lt;/p&gt;

&lt;p&gt;Finally, by associating meaning with syntactic change the user can more safely understand and execute post commit reverts to schema changes. That is, instead of manually defining the necessary steps to &amp;quot;undo&amp;quot; some previous schema change, the source control system can provide the exact information that is necessary.&lt;/p&gt;

&lt;h2 id=&quot;toc_62&quot;&gt;Pitfalls&lt;/h2&gt;

&lt;p&gt;Obviously, not every migration is just about the schema. Frequently the data has to be altered to conform to the target schema. This is actually an area of active research in the Database Systems community [4].&lt;/p&gt;

&lt;h2 id=&quot;toc_63&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For the interested reader, I started work on a &lt;a href=&quot;https://github.com/johnbender/sql-delta&quot;&gt;preprocessor&lt;/a&gt; implemented in Haskell. Unfortunately since I don&amp;#39;t have any plans to pursue this further I haven&amp;#39;t been working on it. Also, for comparison I&amp;#39;ve included two very simple sets of denotational semantics in the footnotes; one to represent the current implementation and one to represent the differential semantics [5]. They highlight the symmetry of this new approach to the language when compared with the current implementation.&lt;/p&gt;

&lt;p&gt;This technique can be extended to other languages that manage system state declaratively like configuration management DSLs or even HTML. Though in the case of configuration management, understanding the mapping between syntax and state is quite complex because system components frequently generate artifacts that are not explicitly declared.&lt;/p&gt;

&lt;p&gt;Broadly, the idea of differential semantics is to gather more information about intent from readily available sources so that language runtimes (declarative or otherwise) can make more informed decisions about user intent. The results need not be confined to accurate interpretation of the desired system state.&lt;/p&gt;

&lt;p&gt;In the next post we&amp;#39;ll look at how a type system applied to SQL might provide some useful safety properties during schema migration and beyond.&lt;/p&gt;

&lt;h3 id=&quot;toc_64&quot;&gt;Footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_definition_language&quot;&gt;http://en.wikipedia.org/wiki/Data_definition_language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;In our example a drop would be accomplished by removing the table definition completely.&lt;/li&gt;
&lt;li&gt;The mapping presumes feature parity in the create with the alter statements, but in my study of the standard and Postgres&amp;#39; implementation this appears to be the case.&lt;/li&gt;
&lt;li&gt;There&amp;#39;s a lot of interesting work and tooling around preventing issues resulting from schema migrations: &lt;a href=&quot;http://scholar.google.com/scholar?q=prism+schema+evolution&amp;amp;btnG=&amp;amp;hl=en&amp;amp;as_sdt=0%2C5&quot;&gt;schema evolution&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;A denotational semantics for both the current DDL semantics and the proposed semantics. Note that in the proposed section the &amp;quot;differential&amp;quot; semantics eval function is parameterized by the state of the syntax.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;p  style=&quot; margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block;&quot;&gt;   &lt;a title=&quot;View SQL DDL Differential Semantics on Scribd&quot; href=&quot;http://www.scribd.com/doc/181098166/SQL-DDL-Differential-Semantics&quot;  style=&quot;text-decoration: underline;&quot; &gt;SQL DDL Differential Semantics&lt;/a&gt;&lt;/p&gt;&lt;iframe class=&quot;scribd_iframe_embed&quot; src=&quot;//www.scribd.com/embeds/181098166/content?start_page=1&amp;view_mode=scroll&amp;show_recommendations=true&quot; data-auto-height=&quot;false&quot; data-aspect-ratio=&quot;undefined&quot; scrolling=&quot;no&quot; id=&quot;doc_64435&quot; width=&quot;100%&quot; height=&quot;600&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Why I'm Getting a PhD</title>
   <link href="http://johnbender.github.com/2013/09/16/why-im-getting-a-phd"/>
   <updated>2013-09-16T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2013/09/16/why-im-getting-a-phd</id>
   <content type="html">&lt;p&gt;The 26th is the first day of instruction in the first academic year of my PhD in Computer Science at UCLA. I have a two year old daughter, an incredibly supportive wife, and I just turned 30.&lt;/p&gt;

&lt;p&gt;Unsurprisingly, I&amp;#39;ve been asked many times why I want to get a PhD and I rarely get a chance to explain my thinking fully. This post is both a detailed account of my reasons and a counterpoint to the popular opinion that there isn&amp;#39;t much value in higher education in Computer Science.&lt;/p&gt;

&lt;h2 id=&quot;toc_52&quot;&gt;Why Bother?&lt;/h2&gt;

&lt;p&gt;Any confusion or surprise over my decision to go back to school can generally be reduced to a simple idea: the success I would otherwise have while getting my PhD is of greater absolute value than the education.&lt;/p&gt;

&lt;p&gt;This comes in many reasonable forms. Why are you leaving such a high paying job? Will you be able to speak at conferences? When will you find time to contribute to open source? Couldn&amp;#39;t you just work on those ideas in your free time? These questions are asked directly and without implication.&lt;/p&gt;

&lt;p&gt;In some cases there is a subtle suggestion that academia and higher education are losing their value. Why would someone pursue a PhD when there are people without any higher education earning comparable salaries and working on important projects? I never hear this asked explicitly, but it comes through in many conversations and the idea that education isn&amp;#39;t important is pervasive in the software &amp;quot;meritocracy&amp;quot;.&lt;/p&gt;

&lt;p&gt;In each case, I&amp;#39;m consistently left wanting more time to describe my thinking and the personal experiences that landed me in a PhD program.&lt;/p&gt;

&lt;h2 id=&quot;toc_53&quot;&gt;Career Path&lt;/h2&gt;

&lt;p&gt;When I got my first legitimate management position as the director of engineering at a consultancy/incubator it quickly became clear that management wasn&amp;#39;t for me. I enjoyed seeing my teammates succeed. I enjoyed building and refining Process. I enjoyed winning business. I enjoyed the subtleties of communicating complex technical ideas to people with all types of backgrounds and experience. By my own estimation I was even pretty good at all those things.&lt;/p&gt;

&lt;p&gt;The thing that got to me was the amount of time I spent staring at my email client. After a year I missed the technical aspects of the job, and I started to think about my long-term career options. At the time I saw three paths that didn&amp;#39;t route back through school.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Avoid titles and stick with engineering&lt;/strong&gt; This was, at least initially, the path I took. I left for Adobe and a position working full time on jQuery Mobile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Grab the title and climb the ladder&lt;/strong&gt; Management positions pay a lot of money, and there&amp;#39;s a lot of room for advancement. Not all require you to hand over your keyboard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Employee Number One or Co-Founder&lt;/strong&gt; First employee/Co-Founder positions are available for experienced &amp;quot;generalists&amp;quot; as far as I can tell. This is purely based on personal observations and conversation with friends who are better informed on the topic.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Of course, there are a lot of subtle variants to each of these, but this was my assessment. I can say with confidence that my move to Adobe put me in an ideal engineering position. Working on an OSS project full time gave me the freedom to pursue long term solutions to difficult problems and I still had access to the good parts of a large corporate support infrastructure.&lt;/p&gt;

&lt;p&gt;Unfortunately, the problems I gravitate towards are not normally assigned to engineers and attempts to marry my interests with my domain of expertise [1,2] have met with understandably tepid responses. The ideas are hard to follow in short presentations, most people don&amp;#39;t have time to read marathon blog posts, and the underlying work isn&amp;#39;t funded by my employer. All of that makes perfect sense but it means I can&amp;#39;t focus on the problems that I&amp;#39;m interested in.&lt;/p&gt;

&lt;h2 id=&quot;toc_54&quot;&gt;What Interests Me&lt;/h2&gt;

&lt;p&gt;The things that keep me up past midnight working and learning are technical. Problems both large and small that remain unsolved or problems where the solution seems unsatisfactory to me. A short and incomplete list in no particular order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Descriptive declarative languages that aren&amp;#39;t&lt;/li&gt;
&lt;li&gt;Correctness in dynamic languages&lt;/li&gt;
&lt;li&gt;System configuration and state management&lt;/li&gt;
&lt;li&gt;Adoption, understanding, and value of advanced type systems&lt;/li&gt;
&lt;li&gt;Direct applications of mathematics to programming languages&lt;/li&gt;
&lt;li&gt;Semantics based approaches to hot code loading&lt;/li&gt;
&lt;li&gt;Preventing language bugs/quirks during language creation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A few of these might align with a job posting somewhere but most don&amp;#39;t. More importantly, I&amp;#39;m not as interested in the implementation as I am in conceiving a solution and understanding its value. I&amp;#39;m sure that will sound like laziness to some, but the part I enjoy the most is thinking through the idea. Most of the time an implementation is an important part of that, and I enjoy hacking as much as anyone, but sometimes it&amp;#39;s not. Sometimes a more abstract representation of the problem is the best way to predict the relative value of a solution before committing time and effort to an implementation. Again, this isn&amp;#39;t the type of work that engineers get funded to do.&lt;/p&gt;

&lt;h2 id=&quot;toc_55&quot;&gt;On Academia&lt;/h2&gt;

&lt;p&gt;Perception of academia varies depending on the field and an individual&amp;#39;s cultural disposition. In the software community there is a certain sense of respect for the research and science on which our careers are built. People have even sort of deified greats like Alan Kay, Alonzo Church, and Alan Turing.&lt;/p&gt;

&lt;p&gt;More and more though, the word &amp;quot;academic&amp;quot; is being used as a pejorative to mean irrelevant, unimportant, or a wasted effort. It&amp;#39;s easy to wave this away as an issue of sloppy semantics but I think it highlights the suffering perception of academics. In my experience working on research projects and doing a lot of reading over the last few years, much of the stigma appears to result from two issues. The first is, what people think research should be for, and the second is the occasionally impenetrable nature of formalism.&lt;/p&gt;

&lt;p&gt;Computer Science research is frequently accompanied by proof of concept software. It might be poorly constructed, hard to get working, or even hard to find. In turn, that can lead to a poor opinion of the research and researchers, but the implementations are rarely the primary contribution of the work. The goal of the researcher is &lt;em&gt;not&lt;/em&gt; to provide implementations or information directly to industry, but rather to produce a solution to an outstanding problem. The work of translating that solution into something &amp;quot;well built&amp;quot; or even concrete is frequently left to the reader.&lt;/p&gt;

&lt;p&gt;Unfortunately, reading Computer Science papers can be hard work. The deluge of notation can be discouraging. It can even seem like unnecessary ceremony, but a lot of ground has to be covered in the limited space provided for conference publications. Moreover, formalism and logic are the most important tools we have when streamlining and finding consensus on a good solution. In a perfect world all the necessary context would be easily accessible, and the formal tools used to establish properties of a solution would be easy to understand. Sadly that&amp;#39;s not the case, but it doesn&amp;#39;t diminish the value of the &amp;quot;encoded&amp;quot; contribution.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s &lt;em&gt;because&lt;/em&gt; of these things and not in spite of them that I&amp;#39;m going back to school. I want to work in an environment that explicitly promotes a focus on the fundamentals of a problem and requires that the utmost care be taken when presenting a solution.&lt;/p&gt;

&lt;h2 id=&quot;toc_56&quot;&gt;The Fourth Path&lt;/h2&gt;

&lt;p&gt;I guess you could say I&amp;#39;m taking The Fourth Path™.&lt;/p&gt;

&lt;p&gt;While I may be new to the academic environment, I have taken efforts to ensure that my impressions are not naive. I have been working on research projects since last year with folks at UCLA and I have been attending regular reading groups. I also know what problems I want to work on; one of which I&amp;#39;m pursuing with a strong blessing from my adviser.&lt;/p&gt;

&lt;p&gt;Even if this doesn&amp;#39;t turn out as planned, at least I know that the &amp;quot;what&amp;quot; and &amp;quot;how&amp;quot; of my work will fit and that&amp;#39;s why I&amp;#39;m getting a PhD.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;toc_57&quot;&gt;Acknowledgments&lt;/h3&gt;

&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/keyist&quot;&gt;@keyist&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/melliebe&quot;&gt;@melliebe&lt;/a&gt; for their notes and revisions.&lt;/p&gt;

&lt;p&gt;Special thanks to &lt;a href=&quot;http://philipmjohnson.wordpress.com/&quot;&gt;Professor Philip M. Johnson&lt;/a&gt; who has helped me continuously since I graduated from the University of Hawaii more than seven years ago. His advice has been extremely important in my long and winding path back to academia.&lt;/p&gt;

&lt;h3 id=&quot;toc_58&quot;&gt;Footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2013/08/29/presentation-faster-javascript-through-category-theory/&quot;&gt;Presentation: Faster JavaScript through Category Theory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2013/07/19/presentation-math-envy-and-coffeescripts-foibles/&quot;&gt;Presentation: Math Envy and CoffeeScript&amp;#39;s Foibles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&amp;quot;Less&amp;quot; is not, &amp;quot;not at all&amp;quot;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I also have a short list of things I&amp;#39;m &lt;em&gt;not&lt;/em&gt; interested in. I intended to include this in the main body of the post but it seemed like a distraction.&lt;/p&gt;

&lt;p&gt;As a web developer and someone who&amp;#39;s worked almost exclusively on the client side for the last few years I have a fairly long list of things that do not interest me or are an active source of frustration. Nearly all of them would be impossible to describe as &amp;quot;general&amp;quot; problems.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Esoteric browser bugs (yes they still exist in abundance)&lt;/li&gt;
&lt;li&gt;The culture/necessity of JavaScript micro-libraries&lt;/li&gt;
&lt;li&gt;Effort required to provide broad access to web based content&lt;/li&gt;
&lt;li&gt;Dynamic programming languages as an industry default&lt;/li&gt;
&lt;li&gt;Non-transferable esoterica (e.g., how iptables works on CentOS, Chef&amp;#39;s attribute resolution order)&lt;/li&gt;
&lt;li&gt;Large JavaScript projects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;#39;m not above working on, or around, these problems. For a web developer many of these are simply facts of life. I&amp;#39;m just not content to let them bother me indefinitely which means contributing to solutions or moving on.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Presentation: Faster JavaScript through Category Theory</title>
   <link href="http://johnbender.github.com/2013/08/29/presentation-faster-javascript-through-category-theory"/>
   <updated>2013-08-29T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2013/08/29/presentation-faster-javascript-through-category-theory</id>
   <content type="html">&lt;p&gt;&lt;b&gt;Update&lt;/b&gt; My final presentation of the material from JQuery UK has been posted. On a personal note the venue and speakers made for an awesome setting to retire this talk.&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;http://player.vimeo.com/video/71132093&quot; width=&quot;610&quot; height=&quot;340&quot; frameborder=&quot;0&quot; webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://vimeo.com/album/2509484/video/71132093&quot; class=&quot;video-link&quot;&gt;View video on Vimeo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update&lt;/b&gt; My presentation of the revised material from JSCONFEU 2012 has been posted. Thanks again the &lt;a href=&quot;http://twitter.com/jsconfeu&quot;&gt;@jsconfeu&lt;/a&gt; crew for puting on one of the best conferences I've yet been to.&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&quot;610&quot; height=&quot;340&quot; src=&quot;http://www.youtube.com/embed/PtD-WKSC6ak&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://www.youtube.com/watch?v=PtD-WKSC6ak&quot; class=&quot;video-link&quot;&gt;View video on Youtube&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update&lt;/b&gt; My presentation of the same material at JQCON 2012 has been posted. Thanks again to the good folks from &lt;a href=&quot;http://twitter.com/confreaks&quot;&gt;@confreaks&lt;/a&gt; for all the hard work they do.&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&quot;610&quot; height=&quot;340&quot; src=&quot;http://www.youtube.com/embed/u-_lZ2G82Rk&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://www.youtube.com/watch?v=u-_lZ2G82Rk&quot; class=&quot;video-link&quot;&gt;View video on Youtube&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I'd like to give a big &quot;Thanks!&quot; to the folks at &lt;a href=&quot;http://js.la&quot;&gt;la.js&lt;/a&gt; for having me out, putting on a great meetup, and recording my presentation at the end of May. You can find the &lt;a href=&quot;https://github.com/johnbender/presentation-faster-js/blob/master/samples/scratch.js&quot;&gt;code samples&lt;/a&gt; and the &lt;a href=&quot;http://johnbender.github.com/presentation-faster-js&quot;&gt;presentation slides&lt;/a&gt; on Github.&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&quot;http://player.vimeo.com/video/44085271&quot; width=&quot;610&quot; height=&quot;340&quot; frameborder=&quot;0&quot; webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://player.vimeo.com/video/44085271&quot; class=&quot;video-link&quot;&gt;View video on Vimeo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The larger format presented on &lt;a href=&quot;http://vimeo.com/44085271&quot;&gt;the Vimeo site itself&lt;/a&gt; might be better viewing.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Presentation: Math Envy and CoffeeScript's Foibles</title>
   <link href="http://johnbender.github.com/2013/07/19/presentation-math-envy-and-coffeescripts-foibles"/>
   <updated>2013-07-19T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2013/07/19/presentation-math-envy-and-coffeescripts-foibles</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; Below I&amp;#39;ve included the recording of an extended and updated version of this talk that I gave at Future Insights Live in Las Vegas. You can also find a short Q &amp;amp; A that I did for the folks who ran the conference &lt;a href=&quot;http://www.futureinsights.com/home/math-envy-volleyball-and-why-academic-is-not-a-dirty-word.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;video x-webkit-airplay=&quot;allow&quot; src=&quot;http://wpc.0B0C.edgecastcdn.net/000B0C/carsons/events/2013/FILive2013/d3-r309-230pm-JB.mp4&quot; controls width=&quot;610&quot;&gt;&lt;/video&gt;&lt;/p&gt;

&lt;p&gt;I&amp;#39;d like to thank the good folks at &lt;a href=&quot;http://js.la&quot;&gt;js.la&lt;/a&gt; for putting on a great meetup and having me out to participate. You can see the slides at &lt;a href=&quot;http://johnbender.us/presentation-cs-foibles&quot;&gt;http://johnbender.us/presentation-cs-foibles&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;
&lt;iframe src=&quot;http://player.vimeo.com/video/58872586&quot; width=&quot;610&quot; height=&quot;340&quot; frameborder=&quot;0&quot; webkitAllowFullScreen mozallowfullscreen allowFullScreen&gt;&lt;/iframe&gt;
&lt;a href=&quot;http://vimeo.com/58872586&quot; class=&quot;video-link&quot;&gt;View video on Vimeo&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The larger format presented on &lt;a href=&quot;http://vimeo.com/58872586&quot;&gt;the Vimeo site itself&lt;/a&gt; might be better viewing.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Presentation: O'Hearn's Resources, Concurrency, and Local Reasoning</title>
   <link href="http://johnbender.github.com/2013/07/18/resources-local-reasoning"/>
   <updated>2013-07-18T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2013/07/18/resources-local-reasoning</id>
   <content type="html">&lt;p&gt;Below are the slides from my presentation at UCLA&amp;#39;s Programming Langauges Reading Group on Peter O&amp;#39;Hearn&amp;#39;s &lt;a href=&quot;http://www.eecs.qmul.ac.uk/%7Eohearn/papers/concurrency.pdf&quot;&gt;&lt;em&gt;Resources, Concurrency, and Local Reasoning&lt;/em&gt;&lt;/a&gt; [PDF].&lt;/p&gt;

&lt;iframe src=&quot;http://www.slideshare.net/slideshow/embed_code/24403394?rel=0&quot; width=&quot;597&quot; height=&quot;486&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot; style=&quot;border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px&quot; allowfullscreen webkitallowfullscreen mozallowfullscreen&gt; &lt;/iframe&gt;
</content>
 </entry>
 
 <entry>
   <title>Reasoning About the Heap in Rust</title>
   <link href="http://johnbender.github.com/2013/04/30/reasoning-about-the-heap-in-rust"/>
   <updated>2013-04-30T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2013/04/30/reasoning-about-the-heap-in-rust</id>
   <content type="html">&lt;p&gt;If you follow programming languages or web technologies closely it&amp;#39;s likely that you&amp;#39;ve heard of &lt;a href=&quot;http://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;. Rust is one part of a larger effort by &lt;a href=&quot;http://www.mozilla.org/en-US/research/&quot;&gt;Mozilla Research&lt;/a&gt; to build a new browser engine in &lt;a href=&quot;http://www.mozilla.org/en-US/research/projects/#servo&quot;&gt;Servo&lt;/a&gt;, but its value as a development tool certainly extends beyond that initial goal. In particular it has received attention for its memory model which, &amp;quot;encourages efficient data structures and safe concurrency patterns, forbidding invalid memory accesses that would otherwise cause segmentation faults&amp;quot; [&lt;a href=&quot;#footnotes&quot;&gt;1&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;In this post we&amp;#39;ll take a look at the basics of Hoare logic and an extension Separation logic which aid in reasoning about imperative program behavior and memory state. Then we&amp;#39;ll apply those tools to examine the impact that Rust&amp;#39;s &lt;a href=&quot;http://static.rust-lang.org/doc/0.6/tutorial.html#ownership&quot;&gt;memory ownership system&lt;/a&gt; has on the heap.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;While I was writing this post John Reynolds passed away. He was an incredible force in PL research and Separation logic was one of his most important works. There&amp;#39;s much more to it than is covered here so if you&amp;#39;re curious and you want to learn more please explore the links in the footnotes.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_45&quot;&gt;Hoare logic&lt;/h2&gt;

&lt;p&gt;In the late 1960s &lt;a href=&quot;http://en.wikipedia.org/wiki/C._A._R._Hoare&quot;&gt;Tony Hoare&lt;/a&gt; proposed a formal system for reasoning about programs which would eventually be referred to as &lt;a href=&quot;http://en.wikipedia.org/wiki/Hoare_logic&quot;&gt;Hoare logic&lt;/a&gt;. The central feature of Hoare logic is a triple &lt;code&gt;{P} C {Q}&lt;/code&gt; where &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are predicate logic assertions, referred to as the pre/post conditions, and &lt;code&gt;C&lt;/code&gt; is a command (reads: program/program fragment). The idea is that, outside of any guarantee of termination [&lt;a href=&quot;#footnotes&quot;&gt;2&lt;/a&gt;], if &lt;code&gt;P&lt;/code&gt; is true before &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; is true after &lt;code&gt;C&lt;/code&gt;, the triple proves partial correctness for &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt;. That is, it proves some property asserted by &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; about &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A simple example using C with the assertions in comments:&lt;/p&gt;

&lt;p&gt;Here the triple &lt;code&gt;{P} C {Q}&lt;/code&gt; asserts that if &lt;code&gt;x&lt;/code&gt; is equal to some &lt;code&gt;n&lt;/code&gt; before &lt;code&gt;x = x + 1&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; will be equal to &lt;code&gt;n + 1&lt;/code&gt; afterward.&lt;/p&gt;

&lt;p&gt;In addition to this basic structure it&amp;#39;s possible to define axioms for common programming constructs like assignment, branching, while loops, and for loops that allow for more general reasoning and manipulation of assertions. For assignment it takes the form &lt;code&gt;{P[E/V]} V=E {P}&lt;/code&gt;. That is, substituting &lt;code&gt;E&lt;/code&gt; for &lt;code&gt;V&lt;/code&gt; in &lt;code&gt;P&lt;/code&gt; before the assignment should hold and &lt;code&gt;P&lt;/code&gt; should hold afterward [&lt;a href=&quot;#footnotes&quot;&gt;3&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;Borrowing &lt;code&gt;Q&lt;/code&gt; from the earlier example here, &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;x == n + 1&lt;/code&gt;. Substituting &lt;code&gt;x + 1&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;x + 1 == n + 1&lt;/code&gt;, or &lt;code&gt;x == n&lt;/code&gt;, for the precondition.&lt;/p&gt;

&lt;p&gt;With the help of this and other axioms, established for each programming environment, Hoare logic allows the wielder to write specifications for programs. For most domains (especially those that my usual reader works in) the approach might be heavy handed, but there are many domains where this type of specification is necessary. In particular it&amp;#39;s often important to specify the behavior of a program with regards to memory.&lt;/p&gt;

&lt;h2 id=&quot;toc_46&quot;&gt;Separation Logic&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_logic&quot;&gt;Separation logic&lt;/a&gt; is an extension to Hoare logic that provides tools for specifying memory use and safety with new assertions for how a program will interact with the heap and stack [&lt;a href=&quot;#footnotes&quot;&gt;4&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;The four assertions that Separation logic adds for describing the heap are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;emp&lt;/code&gt; - for the empty heap. It asserts that the heap is empty, and it can be used to extend assertions about programs that don&amp;#39;t interact with the heap.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x |-&amp;gt; n&lt;/code&gt; - for the singleton heap. It asserts that there is a heap that contains one cell at address &lt;code&gt;x&lt;/code&gt; with contents &lt;code&gt;n&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P * Q&lt;/code&gt; - as a replacement for &lt;code&gt;∧&lt;/code&gt; with disjoint heaps. It asserts that, if there is a heap where &lt;code&gt;P&lt;/code&gt; holds and a &lt;em&gt;separate&lt;/em&gt; (disjoint) heap where &lt;code&gt;Q&lt;/code&gt; holds, both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; hold in the conjunction of those two heaps.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P -* Q&lt;/code&gt; - as a replacement for implication, &lt;code&gt;=&amp;gt;&lt;/code&gt;. It asserts that if there is a heap in which &lt;code&gt;P&lt;/code&gt; holds then &lt;code&gt;Q&lt;/code&gt; will hold in the current heap extended by the heap in which &lt;code&gt;P&lt;/code&gt; holds. An important point of clarity: &lt;code&gt;P -* Q&lt;/code&gt; holds for the &lt;em&gt;current heap&lt;/em&gt; and &lt;em&gt;not&lt;/em&gt; the current heap extended by the heap in which &lt;code&gt;P&lt;/code&gt; holds.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are also some shortcuts for common heap states that are built on top of these four assertions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x |-&amp;gt; n, o, p&lt;/code&gt; is equivalent to &lt;code&gt;x |-&amp;gt; n * x + 1 |-&amp;gt; o * x + 2 |-&amp;gt; p&lt;/code&gt;. That is, &lt;code&gt;x&lt;/code&gt; points to a series of memory cells that can be accessed by using &lt;code&gt;x&lt;/code&gt; and pointer arithmetic.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x -&amp;gt; n&lt;/code&gt; is a basic pointer assertion. It is equivalent to &lt;code&gt;x |-&amp;gt; n * true&lt;/code&gt;, that suggests there is a heap where &lt;code&gt;n&lt;/code&gt; is the value at &lt;code&gt;*x&lt;/code&gt; which is a part of a larger heap about which we can&amp;#39;t make any assertions.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Again we&amp;#39;ll turn to C to demonstrate how these assertions fit with common programs [&lt;a href=&quot;#footnotes&quot;&gt;5&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;The first assertions states that the heap is empty (&lt;code&gt;emp&lt;/code&gt;). After the &lt;code&gt;malloc&lt;/code&gt; call and assignment there exists a singleton heap with a single cell containing the value &lt;code&gt;5&lt;/code&gt; that is pointed to by &lt;code&gt;ptr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Adding &lt;code&gt;ptr2&lt;/code&gt; means the addition of another singleton heap and the connective &lt;code&gt;*&lt;/code&gt;. It&amp;#39;s possible to write this as &lt;code&gt;{ (ptr -&amp;gt; 5) ∧ (ptr2 -&amp;gt; 5) }&lt;/code&gt;, but this assertion provides no information about how the heap is arranged. It simply says that there are two pointers to the value 5 somewhere in a heap. They might be pointing to the same memory location. By using the singleton heap pointer &lt;code&gt;|-&amp;gt;&lt;/code&gt; and the connective &lt;code&gt;*&lt;/code&gt;, the new assertion makes clear that the two pointers are &lt;em&gt;not&lt;/em&gt; pointing to the same memory location.&lt;/p&gt;

&lt;p&gt;Here the comma separated list of values following the singleton pointer in &lt;code&gt;{ arry |-&amp;gt; 1,2,3 }&lt;/code&gt; denotes contiguous memory. It&amp;#39;s simply a shorthand notation for the pointer arithmetic.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s worth noting that separating implication, &lt;code&gt;P -* Q&lt;/code&gt; doesn&amp;#39;t appear to have any particularly useful or clear concrete examples. This seems to be the consequence of its relationship to logical implication in that the whole assertion is only false when &lt;code&gt;Q&lt;/code&gt; is false. Borrowing from Reynolds [&lt;a href=&quot;#footnotes&quot;&gt;6&lt;/a&gt;], something like &lt;code&gt;{ x |-&amp;gt; 1 -* Q }&lt;/code&gt; for some assertion &lt;code&gt;Q&lt;/code&gt; can be extended with the separating implication to show:&lt;/p&gt;

&lt;p&gt;The precondition here says that there are two disjoint heaps. One in which &lt;code&gt;x |-&amp;gt; 0&lt;/code&gt; holds and one in which &lt;code&gt;(x |-&amp;gt; 1 -* Q)&lt;/code&gt; holds. The implication on the right is, if second heap was extended so that &lt;code&gt;x&lt;/code&gt; &lt;em&gt;was&lt;/em&gt; pointing to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt; would hold. After the assignment &lt;code&gt;*x&lt;/code&gt; is no longer &lt;code&gt;0&lt;/code&gt; but rather the second heap has been extended so that &lt;code&gt;*x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; and as a result &lt;code&gt;Q&lt;/code&gt; holds [&lt;a href=&quot;#footnotes&quot;&gt;7&lt;/a&gt;].&lt;/p&gt;

&lt;h2 id=&quot;toc_47&quot;&gt;Rust Ownership&lt;/h2&gt;

&lt;p&gt;Rust provides two new type modifiers for dealing with pointers and memory management. Both have very specific semantics that are checked at &lt;em&gt;compile time&lt;/em&gt; to help prevent memory leaks.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; - provides a lexically scoped allocation on the heap. That is, when the newly assigned pointer variable goes out of scope the memory is freed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; - provides a garbage collected allocation on the heap. In Rust each &lt;a href=&quot;http://static.rust-lang.org/doc/tutorial-tasks.html&quot;&gt;task&lt;/a&gt; has its own garbage collector responsible for handling this type of heap allocation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A few simple examples borrowed in part from Rust&amp;#39;s tutorials will illustrate when the memory for each of these type modifiers is freed.&lt;/p&gt;

&lt;p&gt;With the tilde, the memory at &lt;code&gt;*a&lt;/code&gt; on the heap is freed when the variable to which it is assigned goes out of scope. Since &lt;code&gt;a&lt;/code&gt; is declared inside an explicit block it goes out of scope at the end of the block and the associated memory is freed.&lt;/p&gt;

&lt;p&gt;When the ownership of memory is transferred between variables the compiler prevents further reference to the original owner. In this example &lt;code&gt;a&lt;/code&gt; is the new owner and the compiler will prevent any further reference to &lt;code&gt;b&lt;/code&gt;. This concept of single ownership is the reason that the memory can be deallocated safely when the current owner goes out of scope.&lt;/p&gt;

&lt;p&gt;Alternately, the &lt;code&gt;@&lt;/code&gt; type modifier can be used to request that the run-time manage the allocated memory on a per-task basis. This presents some interesting issues when creating pointers to memory allocated as part of a record.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;x&lt;/code&gt; is declared as a mutable variable (Rust&amp;#39;s default is immutability). When a pointer is made to the field &lt;code&gt;f&lt;/code&gt; with &lt;code&gt;&amp;amp;x.f&lt;/code&gt; and then &lt;code&gt;x&lt;/code&gt; is reassigned, the memory at &lt;code&gt;*x&lt;/code&gt; would be subject to garbage collection. Luckily Rust does a bit of work for you and inserts a lexically scoped reference to the original record to prevent deallocation by the garbage collector.&lt;/p&gt;

&lt;p&gt;You might also wonder how Rust handles references to lexically scoped record fields. In this case the compiler raises an error and (rather nicely) highlights the discrepancy in scoping expectations.&lt;/p&gt;

&lt;p&gt;Here, &lt;code&gt;a&lt;/code&gt; is assigned the memory location of the field &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt;, but the scope of &lt;code&gt;a&lt;/code&gt; is larger than the scope of &lt;code&gt;b&lt;/code&gt; which means that &lt;code&gt;*b&lt;/code&gt; will be freed long before &lt;code&gt;*a&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;toc_48&quot;&gt;Formalizing Ownership&lt;/h2&gt;

&lt;p&gt;Rust&amp;#39;s memory management facilities exist mostly at compile time to prevent users from shooting themselves in the foot, but it&amp;#39;s still worth applying Separation logic to get a feel for what&amp;#39;s happening to the heap.&lt;/p&gt;

&lt;p&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are scoped to the explicit block and exist in disjoint parts of the heap. When they go out of scope the memory associated with both is deallocated leaving an empty heap.&lt;/p&gt;

&lt;p&gt;In this case if there was a reference to &lt;code&gt;b&lt;/code&gt; after the ownership of &lt;code&gt;*b&lt;/code&gt; was transferred to &lt;code&gt;a&lt;/code&gt; the compiler would complain. Since there is no reference we assume that &lt;code&gt;b&lt;/code&gt; is pointing to the same location until the pointer is removed at the close of the explicit block.&lt;/p&gt;

&lt;p&gt;Here we&amp;#39;ve re-purposed the managed memory example from earlier with the explicit addition of the reference that would otherwise be inserted by Rust to prevent GC, &lt;code&gt;x1&lt;/code&gt;. Let&amp;#39;s examine each expression and the associated assertions in turn.&lt;/p&gt;

&lt;p&gt;As before the allocation of managed memory creates a singleton heap pointer to the memory containing the record values [&lt;a href=&quot;#footnotes&quot;&gt;8&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;Adding an additional reference to that same memory means that we have two pointers to the same memory. As a result we &lt;em&gt;cannot&lt;/em&gt; use the &lt;code&gt;*&lt;/code&gt; connective or the the singleton heap pointer &lt;code&gt;|-&amp;gt;&lt;/code&gt; to represent the heap.&lt;/p&gt;

&lt;p&gt;A new reference to the memory location of the first record field in &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;x1&lt;/code&gt; adds another pointer that overlaps with the existing heap. It&amp;#39;s important to keep in mind that the basic conjunction simply says that the heap &lt;em&gt;may&lt;/em&gt; overlap. To the reader it may be obvious, but in terms of specifying program behavior it&amp;#39;s a weaker assertion that the equivalent made with the &lt;code&gt;*&lt;/code&gt; connective.&lt;/p&gt;

&lt;p&gt;Finally with the allocation of a wholly new record and pointer for &lt;code&gt;x&lt;/code&gt; we can employ the more powerful connective because the new record lives in a newly allocated section of memory on the heap. The remaining pointers to the original record and its first field remain ambiguous.&lt;/p&gt;

&lt;h2 id=&quot;toc_49&quot;&gt;Further Reading&lt;/h2&gt;

&lt;p&gt;Not covered here for brevity&amp;#39;s sake is an important part of Separation logic, the Frame Rule. The Frame Rule provides for rigorous local reasoning about the heap without concern for other possibly overlapping references to the same memory locations. That is, it allows each assertion to be correct in spite of the fact that the program fragments they pertain to are often operating in a larger application that manipulates the heap.&lt;/p&gt;

&lt;p&gt;Also, the concept of borrowed pointers is important reading if you&amp;#39;re interested in Rust. A common but effective memory efficiency is achieved in C by passing pointers to data structures instead of using the default pass-by-value semantics. Similarly one can &amp;quot;borrow&amp;quot; a pointer to a data structure in Rust, but because of the type level restrictions it&amp;#39;s both safer and more complex [&lt;a href=&quot;#footnotes&quot;&gt;9&lt;/a&gt;]. The borrowed pointers &lt;a href=&quot;http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html&quot;&gt;tutorial&lt;/a&gt; makes those complexities clear.&lt;/p&gt;

&lt;h2 id=&quot;toc_50&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hopefully this post has given you an initial sense of a portion of Rust&amp;#39;s memory management facilities and also the formalism of Separation logic.&lt;/p&gt;

&lt;p&gt;Special thanks goes to &lt;a href=&quot;https://twitter.com/steveklabnik&quot;&gt;@steveklabnik&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/evanphx&quot;&gt;@evanphx&lt;/a&gt;, and Matt Brown for reviewing various bits of my post.&lt;/p&gt;

&lt;h3 id=&quot;toc_51&quot;&gt;Footnotes&lt;/h3&gt;

&lt;p&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://static.rust-lang.org/doc/0.6/tutorial.html#introduction&quot;&gt;http://static.rust-lang.org/doc/0.6/tutorial.html#introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;When the program fragment can be shown to terminate the triple proves total correctness.&lt;/li&gt;
&lt;li&gt;There are actually two forms of the assignment axiom. The second proposed by Floyd is more complex but addresses issues that exist in common imperative languages the first cannot.&lt;/li&gt;
&lt;li&gt;More information on Separation logic &lt;a href=&quot;https://wiki.mpi-sws.org/star/cpl&quot;&gt;https://wiki.mpi-sws.org/star/cpl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The examples that follow assume that &lt;code&gt;malloc&lt;/code&gt; is always operating by allocating fresh memory not pointed to elsewhere.&lt;/li&gt;
&lt;li&gt;John C. Reynolds: &lt;a href=&quot;http://www.cs.cmu.edu/%7Ejcr/seplogic.pdf&quot;&gt;Separation Logic: A Logic for Shared Mutable Data Structures.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;It certainly feels convoluted but the separating implication is used as a powerful tool when reasoning about the execution of programs moving backwards (among other things). All the examples in this post start from some initial state and then move forward following the execution of the program. Doing this can produce useless assertions if the thing you are trying to prove isn&amp;#39;t affected by some of the program snippets. Many times it&amp;#39;s easier to reason from the end goal, that is from the final result of a set of commands/expressions/program snippets and work backwards. As you can see &lt;code&gt;{ x |-&amp;gt; _ * (x |-&amp;gt; 1 -* Q) } *x = 1 { Q }&lt;/code&gt; the final assertion can be anything. This means that you can start with some assertion you want to show for a program and move backward &amp;quot;over&amp;quot; a memory mutation!&lt;/li&gt;
&lt;li&gt;This assumes the memory allocated for a struct in Rust is sequential (for &lt;a href=&quot;http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#borrowing-unique-boxes&quot;&gt;reference&lt;/a&gt;). It also assumes that &lt;code&gt;x.f&lt;/code&gt; and &lt;code&gt;x.g&lt;/code&gt; aren&amp;#39;t explicitly scoped pointers but rather tranlate into an operation on the pointer &lt;code&gt;x&lt;/code&gt; at a low level (they aren&amp;#39;t represented in the assertions).&lt;/li&gt;
&lt;li&gt;Obviously this depends on your perspective and how complex the code is that uses the pointer. That is, it may be exceptionally hard to get the memory freed properly as result of passing around pointers in which case the compiler might be extremely valuable when writing the Rust equivalent.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>System F in CoffeeScript</title>
   <link href="http://johnbender.github.com/2013/01/15/system-f-in-coffeescript"/>
   <updated>2013-01-15T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2013/01/15/system-f-in-coffeescript</id>
   <content type="html">&lt;p&gt;System F and its variants are used frequently in the study of typed computation and an extended form, System FC, plays an important role in GHC&amp;#39;s compilation process [1]. This post will attempt to translate the grammars of the Lambda Calculus, Simply Typed Lambda Calculus, and finally System F into a small subset of CoffeeScript while covering the basics of application and abstraction in each. Hopefully, through studying the basics here, readers who are interested in learning more about type theory and the lambda calculi will feel a little less intimidated by the notation and concepts.&lt;/p&gt;

&lt;h2 id=&quot;toc_40&quot;&gt;Lambda Calculus&lt;/h2&gt;

&lt;p&gt;Representing the Lambda Calculus only requires a small subset of CoffeeScript&amp;#39;s total syntax. Let&amp;#39;s define both grammars side by side.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;slim&quot; src=&quot;/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-grammars.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;In both cases &lt;code&gt;x&lt;/code&gt; represents a variable and &lt;code&gt;t t&lt;/code&gt; represents application of one term to another. The only real difference is the lambda abstraction syntax (red).&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;slim&quot; style=&quot;width: 50%&quot; src=&quot;/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-abstraction-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;In the Lambda Calculus, abstraction involves preceding or wrapping a term &lt;code&gt;t&lt;/code&gt; with &lt;code&gt;λx.t&lt;/code&gt; which captures or binds the variable &lt;code&gt;x&lt;/code&gt; inside the term &lt;code&gt;t&lt;/code&gt;. In the example &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;λx.y&lt;/code&gt;, using the abstraction &lt;code&gt;λy.t&lt;/code&gt; creates a new term &lt;code&gt;λy.λx.y&lt;/code&gt; (otherwise known as the K-combinator). Note that the &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;λx.t&lt;/code&gt; shown in the grammar could be any variable like &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In CoffeeScript we can do that same thing with the term &lt;code&gt;(x) -&amp;gt; y&lt;/code&gt; by applying the CoffeeScript version of abstraction, yielding &lt;code&gt;(y) -&amp;gt; (x) -&amp;gt; y&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/system-f-cs/untyped-lambda-calculus-application-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The application of a term that shows two abstractions (&lt;code&gt;y&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;) to a single argument results in another term. The &lt;a href=&quot;http://coffeescript.org/#try:z%20%3D%20undefined%0A%0A((y)%20-%3E%20(x)%20-%3E%20y)%20z&quot;&gt;translation&lt;/a&gt; to JavaScript shows that a function object is returned ready for application. The concept of &lt;em&gt;application&lt;/em&gt; in the Lambda Calculus is really the idea of substitution. You can see that the &lt;code&gt;z&lt;/code&gt; is substituted for the instances of &lt;code&gt;y&lt;/code&gt; in the body of the inner lambda term. Similarly in CoffeeScript the outer lambda puts &lt;code&gt;y&lt;/code&gt; in scope and now all occurrences in the body of the lambda term will behave as &lt;code&gt;z&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The notion of &lt;em&gt;closed&lt;/em&gt; terms in the Lambda Calculus is a point of departure with CoffeeScript. A closed term has no free variables. For example, in &lt;code&gt;λx.y&lt;/code&gt; the &lt;code&gt;y&lt;/code&gt; variable is called &lt;em&gt;free&lt;/em&gt; because it hasn&amp;#39;t been bound by an enclosing abstractions. Adding an additional abstraction to get &lt;code&gt;λy.λx.y&lt;/code&gt; captures the &lt;code&gt;y&lt;/code&gt;. The JavaScript generated by the CoffeeScript &lt;code&gt;(x) -&amp;gt; y&lt;/code&gt; will throw a reference error without a definition for &lt;code&gt;y&lt;/code&gt; in scope, in contrast to the lambda term which will simply discard its argument and produce the &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;toc_41&quot;&gt;Simply Typed Lambda Calculus&lt;/h2&gt;

&lt;p&gt;The Simply Typed Lambda Calculus expands on the Lambda Calculus with type information in abstractions.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/system-f-cs/simply-typed-lambda-calculus-grammars.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;It adds a type requirement to the argument of abstractions. The CoffeeScript equivalent adds a function that compares a type argument to the argument term. To keep things simple, &lt;code&gt;ifft&lt;/code&gt; will throw an exception when the types don&amp;#39;t line up.&lt;/p&gt;

&lt;p&gt;This definition assumes that the browser&amp;#39;s &lt;code&gt;instanceof&lt;/code&gt; implementation is behaving properly but certainly serves the purpose of illustration here. Assuming the type &lt;code&gt;Foo&lt;/code&gt; is defined for the calculus and with &lt;code&gt;class Foo&lt;/code&gt; in the CoffeeScript, we can add types to a simple example.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;slim&quot; src=&quot;/assets/images/diagrams/system-f-cs/simply-typed-lambda-calculus-typing-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The types &lt;code&gt;τ&lt;/code&gt; can represent are an important part of the Simply Typed Lambda Calculus. Some definitions provide a set of base types like natural numbers or booleans. Along with that comes a set of base constant values that can represent those types. For natural numbers a base constant of &lt;code&gt;0&lt;/code&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Church_encoding&quot;&gt;church numerals&lt;/a&gt; allows users to represent all the natural numbers. Here we&amp;#39;ve assumed the simple case allowing only the function type &lt;code&gt;τ → τ&lt;/code&gt;, meaning every argument must be a lambda term.&lt;/p&gt;

&lt;p&gt;Unfortunately even the simple case throws a rather large monkey wrench into the works. That&amp;#39;s because there&amp;#39;s no way to write &lt;code&gt;ifft&lt;/code&gt; such that it can know or inspect the arguments type and return type of a lambda term (JavaScript function). In spite of that let&amp;#39;s proceed to see what we can learn about System F.&lt;/p&gt;

&lt;h2 id=&quot;toc_42&quot;&gt;System F&lt;/h2&gt;

&lt;p&gt;System F adds the notion of &lt;em&gt;polymorphic types&lt;/em&gt; to the Simply Typed Lambda Calculus. The term polymorphic carries a lot of baggage, but here it is &lt;em&gt;parametric polymorphism&lt;/em&gt; [3]. That is, the type of a term can change depending on the setting.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/system-f-cs/system-f-grammars.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;System F makes two extensions. &lt;code&gt;Λα.e&lt;/code&gt; is a type abstraction on the type variables in terms and &lt;code&gt;e [τ]&lt;/code&gt; is the application of a type to a term that has been wrapped by a type abstraction. Note that the abstraction uses &lt;code&gt;α&lt;/code&gt; to represent a type variable and &lt;code&gt;τ&lt;/code&gt; to represent types that may or may not contain type variables. Since CoffeeScript&amp;#39;s &amp;quot;types&amp;quot; are really constructor functions, all that&amp;#39;s needed is an enclosing lambda to pull the type argument to &lt;code&gt;ifft&lt;/code&gt; into scope and an application to a constructor function at runtime.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;slim&quot; src=&quot;/assets/images/diagrams/system-f-cs/system-f-type-abstraction-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;For System F the type abstraction is very specific. It works at the type level [4]. In CoffeeScript, on the other hand, it&amp;#39;s just another lambda abstraction that puts the constructor function in scope as a lambda argument. In both cases when the term is applied to a type a substitution of the type for the type variable &lt;code&gt;α&lt;/code&gt; takes place, just like regular (term) abstractions.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/system-f-cs/system-f-type-application-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Again there is an important exception with regards to the types permitted in System F that makes the &lt;code&gt;ifft&lt;/code&gt; even more inadequate than it was with the Simply Typed Lambda Calculus. Not only is there no way to write &lt;code&gt;ifft&lt;/code&gt; so that it can properly check against lambda types but in addition System F defines universally quantified types. This means that a lambda can be polymorphic and operate without knowing anything about the type of its argument.&lt;/p&gt;

&lt;p&gt;For example the identity combinator &lt;code&gt;Λα.λx:α.x&lt;/code&gt;, or in CoffeeScript &lt;code&gt;(α) -&amp;gt; (x) -&amp;gt; ifft(α, x); x&lt;/code&gt;, has the polymorphic type &lt;code&gt;∀α.α → α&lt;/code&gt;. That is, its type isn&amp;#39;t determined until a type application takes place or it &amp;quot;works&amp;quot; for all types. The issue arises when a combinator like identity is passed as an argument to another lambda term that expects a polymorphic function. Again, &lt;code&gt;ifft&lt;/code&gt; can&amp;#39;t check the types of a combinator if a type has been applied and it certainly can&amp;#39;t check that the combinator is type agnostic in its dealings (polymorphic).&lt;/p&gt;

&lt;h2 id=&quot;toc_43&quot;&gt;Strong and Normal&lt;/h2&gt;

&lt;p&gt;System F has some really neat properties. Most importantly System F is &lt;em&gt;strongly normalizing&lt;/em&gt;. That means that it always terminates and always reduces to a normal form when the terms are well typed (the types line up properly). That alone makes it worth studying.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s also possible to make the type abstraction a bit more robust in the CoffeeScript by verifying that the argument is at least a function. A more adventuresome individual might alter CoffeeScript to annotate constructor function objects with a property that could be used to set them apart and compare them [5].&lt;/p&gt;

&lt;p&gt;Even if we came up short of a really meaningful translation, hopefully it has demystified parts of how these calculi work. If you want to learn more I suggest reading &lt;a href=&quot;http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091&quot;&gt;&lt;em&gt;Types and Programming Languages&lt;/em&gt;&lt;/a&gt; by Pierce (not an affiliate link).&lt;/p&gt;

&lt;h3 id=&quot;toc_44&quot;&gt;Footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;There are some &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/&quot;&gt;interesting papers&lt;/a&gt; to read from Microsoft Research this particular extension of System F.&lt;/li&gt;
&lt;li&gt;This is a more &lt;a href=&quot;http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations&quot;&gt;intrinsic&lt;/a&gt; approach to the translation as we aren&amp;#39;t attempting to use types to reason about the terms/grammars.&lt;/li&gt;
&lt;li&gt;Specifically &lt;em&gt;rank-n&lt;/em&gt; polymorphism since the type variable &lt;code&gt;α&lt;/code&gt; can be replaced by a quantified type.&lt;/li&gt;
&lt;li&gt;This is actually captured in the reduction rules for System F.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Gasp!&lt;/em&gt; types in CoffeeScript.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Math Envy and CoffeeScript's Foibles, Part 2</title>
   <link href="http://johnbender.github.com/2013/01/09/math-envy-and-coffeescripts-foibles-2"/>
   <updated>2013-01-09T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2013/01/09/math-envy-and-coffeescripts-foibles-2</id>
   <content type="html">&lt;p&gt;In the &lt;a href=&quot;/2012/11/27/math-envy-and-coffeescripts-foibles/&quot;&gt;previous post&lt;/a&gt; I presented the basics of operational semantics and showed how derivations trees can be used to differentiate two terms that are syntactically similar. This post develops the closing thoughts further with the introduction of type rules, example tools for automating evaluation and type derivation, and a concrete definition of semantic ambiguity. The primary goal is to establish the best way to detect ambiguous term pairings and then outline what will work for a tool that can be generalized beyond the CoffeeScript subset.&lt;/p&gt;

&lt;h2 id=&quot;toc_27&quot;&gt;Type Rules&lt;/h2&gt;

&lt;p&gt;Type rules are similar in construction to evaluation rules, consisting of a premise and conclusion. As with evaluation rules the premise establishes the preconditions for the conclusion. Again, each rule is tagged with a name for reference but preceded by a &lt;em&gt;t-&lt;/em&gt; in this case to distinguish them from inference rules (&lt;em&gt;e-&lt;/em&gt;).&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-rules.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Type rules without a premise like &lt;em&gt;t-true&lt;/em&gt; and &lt;em&gt;t-false&lt;/em&gt; are taken to be true out of hand. That is, the terms &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; both have the type &lt;code&gt;Bool&lt;/code&gt;. The others are more complicated.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-term.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;t-lambda&lt;/em&gt; illustrates how to determine the type of a lambda term like &lt;code&gt;(-&amp;gt; true)&lt;/code&gt;. The premise above the line states that if the subterm &lt;code&gt;t&lt;/code&gt; has the &lt;em&gt;concrete&lt;/em&gt; type &lt;code&gt;T&lt;/code&gt;, then the conclusion &lt;code&gt;λt&lt;/code&gt; has the type &lt;code&gt;X -&amp;gt; T&lt;/code&gt;. Here &lt;code&gt;X&lt;/code&gt; is a &lt;em&gt;type variable&lt;/em&gt; because we don&amp;#39;t know whether the lambda will be evaluated with the invocation operator &lt;code&gt;()&lt;/code&gt; or applied to an argument. &lt;code&gt;T&lt;/code&gt; will be concrete because it can be determined from the body of the lambda expression. For example, in &lt;code&gt;(-&amp;gt; true)&lt;/code&gt; the subterm &lt;code&gt;true&lt;/code&gt; has the type &lt;code&gt;Bool&lt;/code&gt; so the lambda term has the type &lt;code&gt;X -&amp;gt; Bool&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-invocation.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;t-inv&lt;/em&gt; shows how to determine the type of lambda invocation like &lt;code&gt;(-&amp;gt; true)()&lt;/code&gt;. The premise states if the lambda term has the type &lt;code&gt;X -&amp;gt; T&lt;/code&gt; the term &lt;code&gt;λt()&lt;/code&gt; has the type &lt;code&gt;T&lt;/code&gt;. For example, &lt;code&gt;(-&amp;gt; true)()&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; and has the type &lt;code&gt;Bool&lt;/code&gt;. It&amp;#39;s worth noting that &lt;code&gt;X&lt;/code&gt; is constrained to be the &lt;code&gt;Unit&lt;/code&gt; or empty type since no argument is used.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-rules-lambda-application.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;t-app&lt;/em&gt; is the type rule for lambda applications, e.g. &lt;code&gt;(-&amp;gt; true) false&lt;/code&gt;. The premise says that if the lambda term &lt;code&gt;λt&lt;/code&gt; on the left has the type &lt;code&gt;X -&amp;gt; T&lt;/code&gt; the conclusion is that the application will have the result type of the lambda term. Again, the type of an application, like invocation, is only concerned with the type of the &lt;em&gt;first&lt;/em&gt; lambda&amp;#39;s subterm &lt;code&gt;t&lt;/code&gt; and it ignores the type of the argument that it&amp;#39;s applied to.&lt;/p&gt;

&lt;h2 id=&quot;toc_28&quot;&gt;Type Rule Stacking&lt;/h2&gt;

&lt;p&gt;This notation makes it easy to establish the type of a term by stacking the type rules on one another in the same fashion as evaluation rules. Taking a very simple example, some diagrams will illustrate how this works:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-derivation-simple.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;This highlights how to derive the type at the bottom from its subterms. Typing the innermost subterm &lt;code&gt;true&lt;/code&gt; with &lt;em&gt;t-true&lt;/em&gt; can be &amp;quot;stacked&amp;quot; by using it to replace the premise of type rule &lt;em&gt;t-lambda&lt;/em&gt;. The type derivation expands from the subterm to establish each subsequent parent term&amp;#39;s type. Another more complex derivation:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 300px&quot; src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-derivation-complex.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The second subterm of the application is unimportant where the type of the term is concerned and as a result it&amp;#39;s wholly ignored. Working on the left term, the tree extends upward until it reaches the atomic value type, &lt;code&gt;false : Bool&lt;/code&gt;. The complexity of nested lambdas and invocation make for a taller stack of type rules to reach the atomic &lt;code&gt;false&lt;/code&gt; when compared with the previous example.&lt;/p&gt;

&lt;h2 id=&quot;toc_29&quot;&gt;Not Quite There&lt;/h2&gt;

&lt;p&gt;At this point the type rules can describe the original issue. A derivation tree based on the typing rules highlights that the term is untypable. Taking our canonical example, &lt;code&gt;(-&amp;gt; true)() -&amp;gt; false&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 300px&quot; src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-derivation-original-issue.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Once the derivation tree reaches the outermost term it breaks. There is no type rule for the application of something with type &lt;code&gt;Bool&lt;/code&gt; to something with type &lt;code&gt;X -&amp;gt; Bool&lt;/code&gt; since &lt;em&gt;t-app&lt;/em&gt; requires the first term have the type &lt;code&gt;X -&amp;gt; T&lt;/code&gt; in its premise. It&amp;#39;s a type error.&lt;/p&gt;

&lt;p&gt;Previously we saw that this would result in a type error under evaluation by the CoffeeScript interpreter. We also saw that it was easy to construct a term that suffered the same semantic confusion without the type error &lt;code&gt;(-&amp;gt; (-&amp;gt; true))() -&amp;gt; false&lt;/code&gt;. This issue applies to the type derivation as well.&lt;/p&gt;

&lt;p&gt;In addition we saw that it&amp;#39;s possible to construct terms, albeit in the boolean example language, that might produce the same value through different evaluation paths. That is, they had different derivation trees in the evaluation relation but the same evaluation result. This issue also applies to type derivations.&lt;/p&gt;

&lt;p&gt;In both cases useful information is lost when the derivation is discarded in favor of the final value or type. The advantage with the type information is obviously that no evaluation is required to determine if two terms are &amp;quot;different&amp;quot; in some way other than their syntax. The disadvantage is that not all languages make determining type information easy.&lt;/p&gt;

&lt;p&gt;Ultimately the type information provides a second way to differentiate syntactically similar terms. Indeed there are cases where both the evaluation and type information are necessary to distinguish terms. For example &lt;code&gt;((x, y) -&amp;gt; x + y)(1, 1)&lt;/code&gt; has a type derivation identical to &lt;code&gt;((x, y) -&amp;gt; x * y)(1, 2)&lt;/code&gt; and the same evaluation result, but it clearly takes a different evaluation path [1].&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note: The next five sections cover an implementation of a lexer, parser, evaluator and mechanisms for type/evaluation derivation. If you&amp;#39;d rather just read about how the generated evaluation and type derivations are used to find confusing term pairings you can skip to Detecting Ambiguity&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_30&quot;&gt;Happy Parsing&lt;/h2&gt;

&lt;p&gt;It&amp;#39;s time to build something concrete from the formal notion of evaluation and types. An AST for this CoffeeScript subset will provide enough information to perform evaluation and establish derivation trees for both evaluation and types. I&amp;#39;ve chosen Haskell along with the &lt;a href=&quot;http://www.haskell.org/alex/&quot;&gt;Alex&lt;/a&gt; and &lt;a href=&quot;http://www.haskell.org/happy/&quot;&gt;Happy&lt;/a&gt; tools to implement a simple lexer and parser. As you would expect the parser grammar definition looks very similar to the grammar definition presented in the previous post:&lt;/p&gt;

&lt;p&gt;You can view the full lexer and parser implementations &lt;a href=&quot;https://gist.github.com/8d7db37e8a6dc99e1ea3&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two differences from the original grammar definition. Lambda terms in parentheses are just a convenience for readability. More importantly a correction must be made to application of two terms, allowing for any term as the left side (the &lt;em&gt;applicand&lt;/em&gt;) [2]. This enables the grammar to reproduce the original issue, since &lt;code&gt;(-&amp;gt; true)() -&amp;gt; false&lt;/code&gt; translates to an invocation applied to a lambda term. The corrected grammar:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 200px;&quot; src=&quot;/assets/images/diagrams/math-envy-cs/cs-grammar-corrected.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Also, a correction and an addition must be made to the inference rules presented in the previous post. This will ensure that any term type is permitted as the left half of an application, and that it is fully evaluated before applying it.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-inference-rules-corrected.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Where &lt;em&gt;e-arg-eval&lt;/em&gt; ensures that the argument of an application is fully evaluated, &lt;em&gt;e-app-eval&lt;/em&gt; ensures that the applicand is fully evaluated before the application takes place.&lt;/p&gt;

&lt;h2 id=&quot;toc_31&quot;&gt;Matching Rules&lt;/h2&gt;

&lt;p&gt;The abstract representation produced by the parser is a simple tree structure built with Haskell types. Pattern matching can be used with the type and inference rules to produce evaluation and derivation results. To start let&amp;#39;s look at a simple evaluator and derivation builder.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;InfRule&lt;/code&gt; Haskell type is a simple enumeration of the tags belonging to each inference rule. &lt;em&gt;e-inv&lt;/em&gt; corresponds to &lt;code&gt;Inv&lt;/code&gt; and so on.&lt;/p&gt;

&lt;p&gt;Both the evaluator and the derivation builder will operate based on the inference rules that apply to each term and its subterms. The function &lt;code&gt;matchRule&lt;/code&gt; takes an expression, &lt;code&gt;Expr&lt;/code&gt;, and provides three pieces of information in a &lt;code&gt;RuleMatch&lt;/code&gt; result: the inference rule that applies to the term, an optional term for the premise of an inference rule pulled from the body of the parent term, and a term for the conclusion of the inference rule also pulled from the body of the parent term. There are pattern matching definitions for each rule.&lt;/p&gt;

&lt;p&gt;The value terms &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;(-&amp;gt; x)&lt;/code&gt; are the base case of &lt;code&gt;matchRule&lt;/code&gt;. That is, whenever another function requests a rule match on the value terms &lt;code&gt;None&lt;/code&gt; is provided to signal that the term has been fully evaluated.&lt;/p&gt;

&lt;p&gt;Invocation can only be applied to a lambda term and the result of the invocation is the lambda&amp;#39;s subterm, e.g. &lt;code&gt;(-&amp;gt; true)()&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. An invocation on anything else will simply drop through this match and ultimately to the catch all &lt;code&gt;error&lt;/code&gt; case. For example the CoffeeScript &lt;code&gt;true()&lt;/code&gt; is invalid. Its abstract representation from the parser is &lt;code&gt;Invoke (BooleanExpr True)&lt;/code&gt; which clearly won&amp;#39;t match here. On a match, the &lt;code&gt;RuleMatch&lt;/code&gt; result contains the rule tag for invocation &lt;code&gt;Inv&lt;/code&gt;, nothing for an inference rule premise since there isn&amp;#39;t one for &lt;em&gt;e-inv&lt;/em&gt; and the subterm &lt;code&gt;t&lt;/code&gt; for further derivation in the conclusion.&lt;/p&gt;

&lt;p&gt;Like invocation &lt;em&gt;e-app&lt;/em&gt; only works with lambda terms, but it carries the addition requirement that the argument be a value term. The grammar shows that the only &lt;code&gt;v&lt;/code&gt; (value) terms are lambdas and boolean values so there&amp;#39;s a match for those cases here. When there&amp;#39;s a match the rule tag is &lt;code&gt;App&lt;/code&gt; and the lambda subterm is again provided for possible further inspection/operation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;e-arg-eval&lt;/em&gt; and &lt;em&gt;e-app-eval&lt;/em&gt; are more complicated than either &lt;em&gt;e-inv&lt;/em&gt; or &lt;em&gt;e-app&lt;/em&gt; which makes sense when comparing them as inference rules. Both &lt;em&gt;e-arg-eval&lt;/em&gt; and &lt;em&gt;e-app-eval&lt;/em&gt; carry a premise.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-inference-rules-app-argeval.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Both rules require that some evaluation take place on one of the subterms. More importantly the shape of the term remains the same. Neither &lt;em&gt;e-arg-eval&lt;/em&gt; or &lt;em&gt;e-app-eval&lt;/em&gt; change the shape of the term to which they apply, only the shape of the sub terms. This is in contrast to &lt;em&gt;e-inv&lt;/em&gt; and &lt;em&gt;e-app&lt;/em&gt; which discard the invocation operator and second term respectively. As a result the &lt;code&gt;RuleMatch&lt;/code&gt; contains the subterm that needs to be evaluated further and the other subterm that remains stagnant. Note that in the function definition the &lt;em&gt;e-arg-eval&lt;/em&gt; rule is matched first so that the &lt;em&gt;e-app-eval&lt;/em&gt; rule can ignore the second subterm under the assumption that it&amp;#39;s a value term (not &lt;code&gt;Invoke&lt;/code&gt; or &lt;code&gt;Apply&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Finally, in situations like &lt;code&gt;true()&lt;/code&gt; or &lt;code&gt;true (-&amp;gt; true)&lt;/code&gt; where no rule applies, an error is raised.&lt;/p&gt;

&lt;h2 id=&quot;toc_32&quot;&gt;Evaluating the Options&lt;/h2&gt;

&lt;p&gt;The information contained in a &lt;code&gt;RuleMatch&lt;/code&gt; instance can be used to evaluate or derive a given term. Evaluation is a simple matter of applying the rules recursively.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eval&lt;/code&gt; performs a single step of evaluation according the the inference rules. The first case match returns the original term &lt;code&gt;t&lt;/code&gt; because &lt;code&gt;None&lt;/code&gt; is the match for fully evaluated value terms like &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;(-&amp;gt; x)&lt;/code&gt;. The second match handles both the &lt;code&gt;Inv&lt;/code&gt; and &lt;code&gt;App&lt;/code&gt; by returning the subterm of the invoked or applied lambda term. The &lt;code&gt;matchRule&lt;/code&gt; function does a bit of evaluation for these two rules by stripping the applied lambda term. For example, &lt;code&gt;(-&amp;gt; true) true&lt;/code&gt; and &lt;code&gt;(-&amp;gt; true)()&lt;/code&gt; become &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;ArgEval&lt;/code&gt; and its cousin &lt;code&gt;AppEval&lt;/code&gt; the subterm that needs further evaluation gets it and then the whole term is reassessed. The order of which evaluation happens first is preserved here by recursion. If the argument in an application needs more than one evaluation step, &lt;code&gt;eval&lt;/code&gt; will continue to work on it until the result is returned to the original invocation. Subsequently if the applicand needs evaluation it will do the same. For example, in &lt;code&gt;(-&amp;gt; true) (-&amp;gt; true)()&lt;/code&gt; the second term is evaluated with an &lt;code&gt;Inv&lt;/code&gt; and then the boolean result is the argument to the first lambda term.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fullEval&lt;/code&gt; simply applies &lt;code&gt;eval&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; until it reaches a value term.&lt;/p&gt;

&lt;h2 id=&quot;toc_33&quot;&gt;Automating Evaluation Derivation&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;RuleMatch&lt;/code&gt; instance is primarily geared toward building derivation trees. That&amp;#39;s why the structure appears so awkward in use with &lt;code&gt;eval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Derivation&lt;/code&gt; data type is comprised of a tag from the &lt;code&gt;InfRule&lt;/code&gt; enumeration, one &lt;em&gt;possible&lt;/em&gt; derivation as a premise, the final derivation as the conclusion, and the expression representing the state of evaluation at a given moment. Taking the derivation tree of a simple example &lt;code&gt;(-&amp;gt; (-&amp;gt; true))() false&lt;/code&gt; which is parsed to:&lt;/p&gt;

&lt;p&gt;In english, the application of an invocation of a lambda with a lambda subterm to a boolean value. The resulting tree in the original notation takes the form:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-derivation-trees-ast-example.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Derivation&lt;/code&gt; instance has to work from the outside in so it&amp;#39;s much harder to read than the notation, but it contains the same information&lt;/p&gt;

&lt;p&gt;It&amp;#39;s clear that the applicand &lt;code&gt;(-&amp;gt; (-&amp;gt; true)()&lt;/code&gt; needs evaluation using &lt;em&gt;e-app-eval&lt;/em&gt; before it can be applied to the argument &lt;code&gt;false&lt;/code&gt;. The premise of &lt;em&gt;e-app-eval&lt;/em&gt; requires that the applicand take a step and here that means an invocation with &lt;em&gt;e-inv&lt;/em&gt;. Finally the result of the invocation &lt;code&gt;(-&amp;gt; true)&lt;/code&gt; is applied to the &lt;code&gt;false&lt;/code&gt; with &lt;em&gt;e-app&lt;/em&gt; as the &amp;quot;conclusion&amp;quot; of the &lt;em&gt;e-app-eval&lt;/em&gt;. In reality, &lt;em&gt;e-app&lt;/em&gt; is applied to the result of the first derivation tree as it is with the logic notation.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;derive&lt;/code&gt; function works in a similar fashion to &lt;code&gt;eval&lt;/code&gt;. For a value/&lt;code&gt;None&lt;/code&gt; result from &lt;code&gt;matchRules&lt;/code&gt; there are no inference rules that apply. For &lt;em&gt;e-inv&lt;/em&gt; or &lt;em&gt;e-app&lt;/em&gt;, &lt;code&gt;derive&lt;/code&gt; can recurse and build a derivation from the lambda&amp;#39;s subterm. For &lt;em&gt;e-arg-eval&lt;/em&gt; or &lt;em&gt;e-app-eval&lt;/em&gt; the premise must be further derived and the conclusion is a derivation for the original term &lt;code&gt;t&lt;/code&gt; with one evaluation step applied. That is, evaluating the subterm &lt;code&gt;t1&lt;/code&gt; once inside the original term &lt;code&gt;t&lt;/code&gt;. The use of &lt;code&gt;eval&lt;/code&gt; to do that may look funny but it&amp;#39;s just a convenience.&lt;/p&gt;

&lt;h2 id=&quot;toc_34&quot;&gt;Automating Type Derivation&lt;/h2&gt;

&lt;p&gt;Deriving the type for a term in the CoffeeScript subset is slightly less complex than deriving the evaluation. Again, a type rule is matched to each valid AST construction.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;RuleMatch&lt;/code&gt; definition for types requires one less &lt;code&gt;Expr&lt;/code&gt;. The &lt;code&gt;derive&lt;/code&gt; and &lt;code&gt;fixType&lt;/code&gt; definitions for types only require the first subterms in each expression. This is in contrast to &lt;code&gt;eval&lt;/code&gt; which required both the conclusion and premise terms.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Apply&lt;/code&gt; matches capture only valid applicands and let the rest fall through to the error case. It&amp;#39;s also worth noting that each of the &lt;code&gt;Apply&lt;/code&gt; matches discards the argument term because it&amp;#39;s unnecessary to the type of the expression. This fits with the definition of the type rules.&lt;/p&gt;

&lt;p&gt;Fixing the type of a given expression is a simple recursive effort on applications. The &lt;code&gt;Type&lt;/code&gt; data type captures both the &lt;code&gt;Bool&lt;/code&gt; result, and the recursive &lt;code&gt;Arrow&lt;/code&gt; type. For example &lt;code&gt;(-&amp;gt; (-&amp;gt; true))&lt;/code&gt; has the type &lt;code&gt;Arrow (Arrow Bool)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The type of an invocation is determined by the lambda&amp;#39;s subterm, so &lt;code&gt;matchRule&lt;/code&gt; provides that as &lt;code&gt;t1&lt;/code&gt; here for further type information. The type of an application is dependent on the type of it&amp;#39;s first argument, so we cheat a bit here and use the single step &lt;code&gt;eval&lt;/code&gt; to get at the result of the application.&lt;/p&gt;

&lt;p&gt;The type rules are much easier to apply, they simply descend into the terms to build up the type, providing the fixed type at each step as the conclusion. Taking the same example from the evaluation rules earlier &lt;code&gt;(-&amp;gt; (-&amp;gt; true))() false&lt;/code&gt; which is parsed to:&lt;/p&gt;

&lt;p&gt;The type derivation using logic notation looks like:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 300px&quot; src=&quot;/assets/images/diagrams/math-envy-cs/cs-type-derivation-ast-example.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Derivation&lt;/code&gt; instance corresponding the the logic notation is again much larger but captures the same information (formatting added after the fact):&lt;/p&gt;

&lt;p&gt;As noted in the comments each step in the derivation resolves the type at that step based on the inference rules.&lt;/p&gt;

&lt;h2 id=&quot;toc_35&quot;&gt;Detecting Ambiguity&lt;/h2&gt;

&lt;p&gt;So far we&amp;#39;ve seen that it&amp;#39;s possible to build an understanding of evaluation and typing that provides more information than just the evaluation result or the fixed type for a term. Capturing that extra information, a term can be represented by a triple &lt;code&gt;(S, E, T)&lt;/code&gt;, where &lt;code&gt;S&lt;/code&gt; is the syntax string of the term, &lt;code&gt;E&lt;/code&gt; is the evaluation derivation, and &lt;code&gt;T&lt;/code&gt; is the type derivation. This triple can be used to determine whether two terms will cause confusion.&lt;/p&gt;

&lt;p&gt;One approach is to first compare the &lt;code&gt;S&lt;/code&gt; values for two terms and then determine if the &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; values match. Terms with &amp;quot;similar&amp;quot; &lt;code&gt;S&lt;/code&gt; values but different &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt; values might be ambiguous and could be flagged for review. Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;Levenshtein Distance&lt;/a&gt; to keep the calculation for similarity simple:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-dist.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;lev&lt;/em&gt; is the Levenshtein distance function and &lt;em&gt;dist&lt;/em&gt; is just the ratio of the distance between the two strings and the maximum length of both. This is sometimes referred to as the Levenshtein Ratio. For &lt;code&gt;(-&amp;gt; true)() -&amp;gt; false&lt;/code&gt; and &lt;code&gt;(-&amp;gt; true) () -&amp;gt; false&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 300px&quot; src=&quot;/assets/images/diagrams/math-envy-cs/cs-dist-example.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;A relative value for string distance that can be used as a threshold &amp;quot;setting&amp;quot; makes building a tool for automating the process easier. That is, if two terms are deemed &amp;quot;close enough&amp;quot; by virtue of their &lt;em&gt;dist&lt;/em&gt; value being below a predetermined threshold and they have different information in either &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt; then they might be flagged [3].&lt;/p&gt;

&lt;h2 id=&quot;toc_36&quot;&gt;Fuzzy Search&lt;/h2&gt;

&lt;p&gt;We now have enough information to define a system that will automate the exploration of the &amp;quot;term space&amp;quot; (all term combinations), and run a check against existing known terms for ambiguous pairs for each generated term.&lt;/p&gt;

&lt;p&gt;Storing the triple of known terms for comparison is fairly easy with the text search capabilities available in most modern databases. One might even &lt;a href=&quot;http://www.artfulsoftware.com/infotree/qrytip.php?id=552&quot;&gt;implement&lt;/a&gt; the Levenshtein Distance function and use it to check a new term against known terms. It may be that a purpose built data structure for the storage and retrieval based on a text search algorithm would perform better, but a good all purpose RDBMS would be fine for a first pass.&lt;/p&gt;

&lt;p&gt;More interesting is the generation of terms for a non-trivial language. A &lt;em&gt;term generator&lt;/em&gt; would start with atomic types and successively wrap them in terms defined to have subterms. That part can likely be performed with nothing more than knowledge of the grammar. There are two issues with this.&lt;/p&gt;

&lt;p&gt;First, the complexity of many programming languages makes re-examining the same terms an enormous waste of time. Tracking the explored terms and &amp;quot;resuming&amp;quot; the exploration process would have a lot of value. Second, generating the derivations to store and compare along with the syntax is an involved effort. Again, it&amp;#39;s easy to tag a piece of syntax with the result of execution or typing but information is lost.&lt;/p&gt;

&lt;h2 id=&quot;toc_37&quot;&gt;Quick and Dirty&lt;/h2&gt;

&lt;p&gt;A less complicated representation of a term might still be effective, and could avoid extra effort required of the language creator in generating the evaluation and type derivations. For example the tuple &lt;code&gt;(S, A)&lt;/code&gt;, where &lt;code&gt;S&lt;/code&gt; remains the syntax of the term and &lt;code&gt;A&lt;/code&gt; is the AST representation.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s obvious that the abstract representations capture the issue at hand even if there is some information lost [4]. Best of all the AST for a term is available regardless of the host language and serialization is the only extra requirement. Having a term generator that works with a (E)BNF, a way to generate the AST for a term (presumably through the language parser), and a database equipped with the ability to find like terms it seems entirely possible to alert the language creator of complex or convoluted pairings.&lt;/p&gt;

&lt;h2 id=&quot;toc_38&quot;&gt;Further Work&lt;/h2&gt;

&lt;p&gt;First I have to apologize for not building out a tool for generating terms or a schema for term storage. I wanted to do the automated evaluation and type derivations to get a feel for the effort involved and the result was an exceptionally long post. If I find the time to return to this I&amp;#39;d like to build out the term generator and couple it with a simple database. I think that going through the process of building a BNF parser would be a lot of fun by itself.&lt;/p&gt;

&lt;p&gt;In the course of these two posts we&amp;#39;ve seen what it looks like to formalize both the evaluation and type semantics of a simple programming language. We&amp;#39;ve also come to a relatively satisfying formalization of semantic ambiguity that could be used in conjunction with a common language definition form (BNF, EBNF) to alert a language designer of potential issues [5] [6].&lt;/p&gt;

&lt;h3 id=&quot;toc_39&quot;&gt;footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;It might be that when a function identifier is the only difference between terms, here &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;, it&amp;#39;s reasonable to ignore ambiguous terms. In this case because the total string length for both terms is small it might be that a single character difference is enough to break some arbitrary threshold. I&amp;#39;m leaving this for further consideration.&lt;/li&gt;
&lt;li&gt;The implementation in Haskell forced these issues out into the open. I&amp;#39;m curious if proving progress and preservation would have pointed out the flaws in my approach (this may be obvious one way or another to a better educated reader).&lt;/li&gt;
&lt;li&gt;Assuming it&amp;#39;s possible, it&amp;#39;s interesting to think about what the inverse result means. That is, when two terms are very syntactically different but have identical types/evaluation derivations. This might signal the two terms or the parent language as antithetical to Python&amp;#39;s slogan of &amp;quot;one and only one way to do it&amp;quot;.&lt;/li&gt;
&lt;li&gt;For example, the AST doesn&amp;#39;t capture the type of lambda form that was used. This may be useful information even if this particular example doesn&amp;#39;t require it.&lt;/li&gt;
&lt;li&gt;Though it would be infinitely more satisfying if we could build a tool based on the ideas and arrive at that same conclusions about this CoffeeScript subset and a few other BNF friendly languages.&lt;/li&gt;
&lt;li&gt;It&amp;#39;s worth pointing out that the CoffeeScript issue with lambdas and invocation &lt;a href=&quot;http://news.ycombinator.com/item?id=4849151&quot;&gt;has been/was known to Jeremy&lt;/a&gt;. It was simply a choice in favor of flexibility. I like to think that the hypothetical tool presented here would be useful in cases where ambiguous term pairings are less obvious and for people who may want less flexibility.&lt;/li&gt;
&lt;li&gt;A special thanks to &lt;a href=&quot;http://twitter.com/keyist&quot;&gt;keyist&lt;/a&gt; for proofreading.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Math Envy and CoffeeScript's Foibles, Part 1</title>
   <link href="http://johnbender.github.com/2012/11/27/math-envy-and-coffeescripts-foibles"/>
   <updated>2012-11-27T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2012/11/27/math-envy-and-coffeescripts-foibles</id>
   <content type="html">&lt;p&gt;At Strange Loop 2011 in a &lt;a href=&quot;http://www.infoq.com/presentations/Language-Panel&quot;&gt;language panel (5:06)&lt;/a&gt;, Jeremy Ashkenas was asked, &amp;quot;What is the worst idea that was ever introduced into programming languages that continues to afflict us today?&amp;quot; He responded, &amp;quot;... mathematics envy&amp;quot;. I agree with Mr. Ashkenas in part. Math appears to get in the way on occasion [1]. Even so it struck me as an odd response given that much of computing is built on the work of great mathematicians. For a modern example look no further than the &lt;a href=&quot;http://wingolog.org/archives/2011/08/02/a-closer-look-at-crankshaft-v8s-optimizing-compiler&quot;&gt;inner workings&lt;/a&gt; of V8&amp;#39;s optimizing compiler that runs a lot of Jeremy&amp;#39;s code.&lt;/p&gt;

&lt;p&gt;Fast forward a year and issues with CoffeeScript&amp;#39;s flexible syntax start popping up in &lt;a href=&quot;http://surana.wordpress.com/2011/02/08/coffeescript-oddities/&quot;&gt;blog&lt;/a&gt; &lt;a href=&quot;http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/&quot;&gt;posts&lt;/a&gt;. Interactions between whitespace, operators, comprehensions, and lambda declarations appear to be a source of confusion. To be fair, it sounds like these examples rarely cause serious problems, but it left me wondering if they could have been avoided during the creation of the language. That is, could the timely application of mathematics have prevented these problems early in CoffeeScript&amp;#39;s creation?&lt;/p&gt;

&lt;p&gt;What follows is the first of two posts aimed at answering that question. This post provides an introduction to operational semantics, a description of one semantic issue in CoffeeScript, and the operational semantics for a CoffeeScript subset capable of reproducing said issue. The second post will introduce type derivations, define them for the same CoffeeScript subset, and attempt to formalize semantic ambiguity more completely. The background needed to understand the math is covered, but the post generally follows my thought process.&lt;/p&gt;

&lt;h2 id=&quot;toc_19&quot;&gt;CoffeeScript Confusion&lt;/h2&gt;

&lt;p&gt;I&amp;#39;ve chosen to address the lambda syntax cited by both of the linked posts. Specifically the option to omit parenthesis in lambda declarations and how that interacts with 0-arity lambdas as arguments. Here&amp;#39;s an example borrowed from Manuel Cerón&amp;#39;s &lt;a href=&quot;http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/&quot;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first invocation of &lt;code&gt;doSomething&lt;/code&gt; applies it to the inline lambda. The second invokes it directly with the &lt;code&gt;()&lt;/code&gt; operator and then attempts to apply the result &lt;code&gt;true&lt;/code&gt; to a lambda defined with &lt;code&gt;-&amp;gt; false&lt;/code&gt;. This results in a type error. For clarity here&amp;#39;s the equivalent in JavaScript.&lt;/p&gt;

&lt;p&gt;It&amp;#39;s easy to see where this might cause issues given that the only difference between the two expressions is a single whitespace character. The goal then is to apply some formalism to this part of CoffeeScript. Ideally the formalism will result in an approach, technique, or tool that can highlight problems like this for a language designer &lt;em&gt;during&lt;/em&gt; language creation.&lt;/p&gt;

&lt;h2 id=&quot;toc_20&quot;&gt;Operational Semantics&lt;/h2&gt;

&lt;p&gt;Operational Semantics is one way [2] to formalize the semantics of a programming language. We&amp;#39;ll build a basic understanding of how it works by borrowing an example language from Pierce&amp;#39;s book &lt;em&gt;Types and Programming Languages&lt;/em&gt; [3].&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img style=&quot;width: 40%; min-width: 200px;&quot; src=&quot;/assets/images/diagrams/math-envy-cs/bool-grammar.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The grammar definition is made of up of two &amp;quot;meta variables&amp;quot; &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;. Assigned to those meta variables is a set of possible terms each separated by a &lt;code&gt;|&lt;/code&gt;. &lt;code&gt;t&lt;/code&gt; represents all of the ways to construct terms (see example below). &lt;code&gt;v&lt;/code&gt; is the set of terms that are acceptable as the final result of evaluation. &lt;code&gt;v&lt;/code&gt; is a subset of &lt;code&gt;t&lt;/code&gt;, as witnessed by its inclusion in &lt;code&gt;t&lt;/code&gt;, but it is distinct for a reason.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v&lt;/code&gt;&amp;#39;s distinction means that any term like the second and third in the example has to eventually evaluate to a term in &lt;code&gt;v&lt;/code&gt;, either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Any other result means that something is &amp;quot;stuck&amp;quot; (a definition for &amp;quot;stuck&amp;quot; will be covered later). It also means that &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; cannot evaluate further.&lt;/p&gt;

&lt;p&gt;Notice that that the only other construct in the grammar, &lt;code&gt;if t then t else t&lt;/code&gt;, has subterms represented with the meta variable &lt;code&gt;t&lt;/code&gt;. This captures the ability to use &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, or another &lt;code&gt;if t then t else t&lt;/code&gt; for each subterm (eg, second and third examples).&lt;/p&gt;

&lt;p&gt;With the building blocks in place the next step is to establish a set of rules that will define the way terms are evaluated. That is, what steps should be used to reduce any term to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, and in what order they should be taken. Superficially this language seems extremely simple, but there are some subtle details of term evaluation that need to be captured.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/bool-inference-rules.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;These equations are collectively referred to as the &lt;em&gt;evaluation relation&lt;/em&gt; and individually as &lt;em&gt;inference rules&lt;/em&gt;. Each of them plays an important role in the &lt;em&gt;evaluation strategy&lt;/em&gt; of the example which instructs the reader in how to evaluate a term in the language. All of them are tagged with a name preceded by an &amp;quot;&lt;em&gt;e-&lt;/em&gt;&amp;quot; for evaluation. The tags will be helpful when referring to the rules and later to keep them visually distinct from type rules.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;e-true&lt;/em&gt; and &lt;em&gt;e-false&lt;/em&gt; are fairly simple. They represent the expected evaluation results for the different guard values in an &lt;code&gt;if t then t else t&lt;/code&gt; term. With &lt;code&gt;true&lt;/code&gt; you get the first subterm and with &lt;code&gt;false&lt;/code&gt; you get the second subterm. Also, notice that there are no rules for either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; by themselves. This further reinforces that &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are values and that there&amp;#39;s no way to evaluate them further. &lt;em&gt;e-if&lt;/em&gt; is more interesting in its construction and how it captures an important part of the evaluation strategy.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/bool-inference-rules-guard.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;There are two parts to this rule. Above the line is the &lt;em&gt;premise&lt;/em&gt; and below is the &lt;em&gt;conclusion&lt;/em&gt;. The premise establishes a requirement or precondition for applying the conclusion to a given term. Later we&amp;#39;ll see how the premise is replaced by the conclusion of another rule. For &lt;em&gt;e-if&lt;/em&gt; the premise says that if the first subterm &lt;code&gt;t&lt;/code&gt; can be evaluated to &lt;code&gt;t&amp;#39;&lt;/code&gt; then the parent term &lt;code&gt;if t then t else t&lt;/code&gt; should evaluate to &lt;code&gt;if t&amp;#39; then t else t&lt;/code&gt;. The importance is that evaluation will focus on the guard term and not the other subterms. A different evaluation strategy might fully evaluate the second or third subterms before evaluating the first subterm.&lt;/p&gt;

&lt;p&gt;This term could take two different evaluation paths without &lt;em&gt;e-if&lt;/em&gt;. An alternative strategy would first evaluate the second subterm &lt;code&gt;if false then true else false&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, then evaluate the guard &lt;code&gt;if true then false else false&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, and finally the full term to &lt;code&gt;false&lt;/code&gt;. Obviously the evaluation of the second subterm is unnecessary because the guard term evaluates to &lt;code&gt;false&lt;/code&gt; and the second subterm is ignored completely.&lt;/p&gt;

&lt;p&gt;There is enough information here for an interested party to implement this language without wondering about how to construct terms or how those terms should be evaluated. Additionally there are interesting properties that can be proved inductively using the inferences rules. For example it&amp;#39;s possible to show that there is one and only one way to evaluate each term at each step [4]. The next step then is to turn back to CoffeeScript and begin apply operational semantics to see if anything interesting happens.&lt;/p&gt;

&lt;h2 id=&quot;toc_21&quot;&gt;CoffeeScript Grammar&lt;/h2&gt;

&lt;p&gt;The grammar will cover the subset of CoffeeScript necessary to reproduce the aforementioned ambiguity. In the original example, the overhead of assignment and identifiers can be avoided by using lambda expressions directly.&lt;/p&gt;

&lt;p&gt;This translates into JavaScript like the original example:&lt;/p&gt;

&lt;p&gt;Note that the use of atomic boolean values alleviates the need for arguments in the lambda syntax. Again, simplicity in reproducing the issue is preferred for the sake of brevity. Next is a precise definition of terms in the form of a language grammar.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-grammar.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;To reiterate, the left hand side of each &lt;code&gt;::=&lt;/code&gt; assignment is a meta variable that can be used in other parts of the grammar. In the case of &lt;code&gt;\t&lt;/code&gt; it was easier to create a meta term than to repeat each possible lambda form in &lt;code&gt;t&lt;/code&gt;. &lt;code&gt;v&lt;/code&gt; on the other hand is the set of acceptable final results of evaluation. Finally &lt;code&gt;t&lt;/code&gt; is complete set of forms used to build terms. Notable among them is the invocation and application of lambda terms, &lt;code&gt;\t&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-grammar-examples.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The most important part to note is that lambda terms capture the subterm be it &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or another lambda.&lt;/p&gt;

&lt;p&gt;Looking at the examples it&amp;#39;s reasonable to ask whether there&amp;#39;s value in providing a grammar that looks a lot like it&amp;#39;s own language. First, it maps the two different lambda forms to one form in the grammar, which makes reasoning about evaluation and types easier. Second, differentiating values (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;-&amp;gt; t&lt;/code&gt;) from other terms by calling them values is important for knowing when evaluation has finished.&lt;/p&gt;

&lt;h2 id=&quot;toc_22&quot;&gt;Inference Rules&lt;/h2&gt;

&lt;p&gt;With the grammar in place the next step is to define both the inference rules and evaluation strategy. Obviously it will use the call-by-value, left to right strategy [5] employed by CoffeeScript and JavaScript.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-inference-rules.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The only impact of the evaluation strategy (call-by-value l-to-r) is that arguments to lambda terms must be fully evaluated before application can take place. For example &lt;code&gt;(-&amp;gt; true) (-&amp;gt; false)()&lt;/code&gt; would first evaluate to &lt;code&gt;(-&amp;gt; true) false&lt;/code&gt; as a result of the &lt;code&gt;()&lt;/code&gt; operator.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-inference-rules-application.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;v&lt;/code&gt; in &lt;em&gt;e-app&lt;/em&gt; means that any argument to a lambda term should be fully evaluated. In other words it should be a term in the meta variable set &lt;code&gt;v&lt;/code&gt;. Once applied, the result is the lambda&amp;#39;s unaltered subterm.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-inference-rules-application-argument.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;e-arg-eval&lt;/em&gt; stipulates in the premise (above the bar) that if the lambda argument term can take a step of evaluation it should. &lt;em&gt;e-app&lt;/em&gt; informs the reader when lambda application can take place and &lt;em&gt;e-arg-eval&lt;/em&gt; informs the reader how to get there. Taken together these three rules define how terms get evaluated.&lt;/p&gt;

&lt;h2 id=&quot;toc_23&quot;&gt;Derivation Trees&lt;/h2&gt;

&lt;p&gt;The inference rules in an operational semantics definition can be used in &lt;em&gt;derivation trees&lt;/em&gt; to show how a terms will evaluate. Rules are &amp;quot;stacked&amp;quot; on one another to show how they work in succession to produce an evaluation result.&lt;/p&gt;

&lt;p&gt;The derivation trees for the evaluation of this term result in &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;wide&quot; src=&quot;/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Unfortunately the way these two &amp;quot;trees&amp;quot; are constructed isn&amp;#39;t obvious. First, taking the second subterm and replacing it with a variable prevents the equations from getting too long. We already know that the second sub term isn&amp;#39;t important in the final evaluation (see the introductory section on operational semantics) and it&amp;#39;s easier to read the equations when they aren&amp;#39;t squished&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example-simplify.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;From the inference rules &lt;em&gt;e-true&lt;/em&gt;, &lt;em&gt;e-false&lt;/em&gt;, and &lt;em&gt;e-if&lt;/em&gt; one will apply to begin simplifying the term. The obvious place to start is applying &lt;em&gt;e-true&lt;/em&gt; to the first subterm &lt;code&gt;(if true then false else false)&lt;/code&gt;, but the second subterm &lt;code&gt;(if false then true else false)&lt;/code&gt; could just as easily have &lt;em&gt;e-false&lt;/em&gt; applied to it. Recall that the third rule &lt;em&gt;e-if&lt;/em&gt; tells the reader which will take precedence. It says that if the guard (first subterm) can be evaluated it should be, leaving us to evaluate the first subterm using &lt;em&gt;e-true&lt;/em&gt; as the first part of the derivation tree.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/bool-derivation-tree-first-rule.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;It&amp;#39;s easy to see that this looks just like the &amp;quot;raw&amp;quot; form of the &lt;em&gt;e-true&lt;/em&gt; rule. The only difference is the replacement of the last two subterms with &lt;code&gt;false&lt;/code&gt; on the left side of the arrow and the resulting subterm with &lt;code&gt;false&lt;/code&gt; on the right side of the arrow. It might look a little confusing with the bar resting on top of the &lt;em&gt;e-true&lt;/em&gt; rule, but that signifies the applied rule has no premise/precondition. Next, since  &lt;em&gt;e-if&lt;/em&gt; forced the application of &lt;em&gt;e-true&lt;/em&gt;, it makes sense that it figures in to the derivation tree. Importantly &lt;em&gt;e-if&lt;/em&gt; has a precondition, one which the application of &lt;em&gt;e-true&lt;/em&gt; satisfies.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/bool-inference-rules-guard.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;e-if&lt;/em&gt;&amp;#39;s precondition requires that the first subterm of an &lt;code&gt;if t then t else t&lt;/code&gt; evaluate before the other two subterms. In other words it requires that &lt;code&gt;t -&amp;gt; t&amp;#39;&lt;/code&gt; be replaced by some evaluation.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;wide&quot; src=&quot;/assets/images/diagrams/math-envy-cs/bool-derivation-tree-second-rule.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Here, it&amp;#39;s been replaced by &lt;code&gt;if true then false else false -&amp;gt; false&lt;/code&gt; from the application of &lt;em&gt;e-true&lt;/em&gt;. The bottom/conclusion of the inference rule is replaced by the whole term evaluated to replace the first subterm with &lt;code&gt;false&lt;/code&gt;. It&amp;#39;s a &amp;quot;stack&amp;quot; of the two inference rules &lt;em&gt;e-true&lt;/em&gt; and &lt;em&gt;e-if&lt;/em&gt;. All that&amp;#39;s left is to build a derivation tree for &lt;code&gt;if false then t else false&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img class=&quot;wide&quot; src=&quot;/assets/images/diagrams/math-envy-cs/bool-derivation-tree-example-assoc.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;e-false&lt;/em&gt; is all that&amp;#39;s needed for the second tree to complete the evaluation to &lt;code&gt;false&lt;/code&gt;. At this point it may seem odd to call any part of this a derivation &amp;quot;tree&amp;quot;, but a more complex rule could have multiple terms in the premise resulting in a tree like structure.&lt;/p&gt;

&lt;h2 id=&quot;toc_24&quot;&gt;Evaluating a Solution&lt;/h2&gt;

&lt;p&gt;Finally we know enough to apply the operational semantics to our problem. First the least complex term that prevents evaluation.&lt;/p&gt;

&lt;p&gt;Translating this example into the grammar representation yields a form that will work with the inference rules.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-derivation-trees-stuck.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;e-inv&lt;/em&gt; is applied to &lt;code&gt;(-&amp;gt; true)()&lt;/code&gt; because &lt;code&gt;-&amp;gt; false&lt;/code&gt; can&amp;#39;t evaluate any further (it&amp;#39;s a value in &lt;code&gt;v&lt;/code&gt;), but then what? After applying &lt;em&gt;e-inv&lt;/em&gt; the first subterm is &lt;code&gt;true&lt;/code&gt; and there are no evaluation rules that apply values to an arguement. Without any rules to apply to a term that isn&amp;#39;t a value, it&amp;#39;s &amp;quot;stuck&amp;quot;.&lt;/p&gt;

&lt;p&gt;Here someone will say, &amp;quot;We already knew that because there&amp;#39;s a type error when you evaluate the JavaScript!&amp;quot;. Consider a slightly more complex example.&lt;/p&gt;

&lt;p&gt;And the derivation tree to match.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-derivation-trees-not-stuck.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;The value returned by the first lambda &lt;strong&gt;can&lt;/strong&gt; be applied to an argument with &lt;em&gt;e-app&lt;/em&gt; so the result of evaluation is &lt;code&gt;true&lt;/code&gt;. Viewing the accompanying term with an additional space will provide contrast.&lt;/p&gt;

&lt;p&gt;In this case, the derivation tree consists of a single inference rule, &lt;em&gt;e-app&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;center&quot;&gt;
  &lt;img src=&quot;/assets/images/diagrams/math-envy-cs/cs-derivation-trees-not-stuck-with-space.png&quot;&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;p&gt;Clearly the two terms are syntactically similar but each has a very different meaning. This semantic differentiation makes it possible to think about a concrete notion of semantic ambiguity in a programming language. Informally, if two terms are &lt;em&gt;very similar&lt;/em&gt; syntactically but have different derivation trees they are semantically ambiguous.&lt;/p&gt;

&lt;p&gt;There are two problems with this definition if the goal is to come up with something useful for actual language implementers. First, &amp;quot;very similar&amp;quot; is nebulous. Luckily computer science is littered with string &amp;quot;distance&amp;quot; algorithms. Second, automatically generating derivation trees for terms is likely to be difficult.&lt;/p&gt;

&lt;p&gt;It might be possible to just compare evaluation results instead of the derivation trees but there are problems with that approach. In the example boolean language it&amp;#39;s extremely easy to define two terms that evaluate to an identical result but have different derivation trees.&lt;/p&gt;

&lt;p&gt;The fact that the evaluation path is very different gets lost in a forest of &lt;code&gt;true&lt;/code&gt;&amp;#39;s and &lt;code&gt;false&lt;/code&gt;&amp;#39;s. More concretely the string distance between the two terms is at most 5 characters out of 78, but the first example has a derivation tree with three rules (&lt;em&gt;e-true&lt;/em&gt;, &lt;em&gt;e-if&lt;/em&gt;, &lt;em&gt;e-false&lt;/em&gt;) against the second&amp;#39;s four (&lt;em&gt;e-true&lt;/em&gt;, &lt;em&gt;e-if&lt;/em&gt;, &lt;em&gt;e-false&lt;/em&gt;, &lt;em&gt;e-true&lt;/em&gt;). Again, this is in spite of the fact that the evaluation &lt;em&gt;result&lt;/em&gt; is &lt;code&gt;false&lt;/code&gt; in both cases. You really can&amp;#39;t tell with the naked eye how different the evaluation is and in a language with side effects the difference could be critical. If the result of this work will be general it must account for this subtlety even if it doesn&amp;#39;t crop up with the CoffeeScript guinea pig.&lt;/p&gt;

&lt;h2 id=&quot;toc_25&quot;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;In the next post I&amp;#39;ll take a look at how type information could replace the derivation trees as the semantic differentiator. Type information is often readily available even in languages like CoffeeScript that don&amp;#39;t have type annotations. If finding a difference between two terms is simple enough maybe a tool can be built to automate the process of ferreting out confusing term pairings.&lt;/p&gt;

&lt;h3 id=&quot;toc_26&quot;&gt;footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;An example is the confusion over Monads and Functors in Haskell. This is due in part to odd names and their relationship with mathematics.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Denotational_semantics&quot;&gt;Denotational Semantics&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Axiomatic_semantics&quot;&gt;Axiomatic Semantics&lt;/a&gt; are alternate ways to define language semantics.&lt;/li&gt;
&lt;li&gt;This example language is borrowed almost verbatim from Types and Programming Languages but I&amp;#39;ve added in my own explanation. I cannot over emphasize how much this book has contributed to my education over the last year or so.&lt;/li&gt;
&lt;li&gt;This Theorem is referred to as Determinacy of Evaluation. I may go back and do some simple proofs for my own education after this post and a possible follow up.&lt;/li&gt;
&lt;li&gt;Technically JavaScript uses a strategy known as Call by Sharing, which differs from Call by Value in how deals with objects. More information &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/%20courtesy%20of%20%5B@raganwald%5D(https://twitter.com/raganwald&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Splitting jQuery in Two, A Proposal</title>
   <link href="http://johnbender.github.com/2012/07/19/splitting-jquery-in-two-a-proposal"/>
   <updated>2012-07-19T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2012/07/19/splitting-jquery-in-two-a-proposal</id>
   <content type="html">&lt;p&gt;Previously I&amp;#39;ve described applications of Category Theory in JavaScript and with jQuery. An earlier post, &lt;a href=&quot;http://johnbender.us/2012/02/29/faster-javascript-through-category-theory/&quot;&gt;Faster JavaScript with Category Theory&lt;/a&gt;, identified a possible performance benefit where composition could be shown to hold for a Functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;. This post follows up with a more concrete look at that optimization and suggests an additional, farther reaching, implication for the two categories.&lt;/p&gt;

&lt;h2 id=&quot;toc_10&quot;&gt;Quick Recap&lt;/h2&gt;

&lt;p&gt;Previously we defined the categories &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;, providing a concrete mathematical representation of DOM manipulations in raw form and their counterparts used inside the jQuery library.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Html&lt;/strong&gt; is the category of all DOM elements and JavaScript functions that manipulate them. It represents the basic building blocks of client side web applications that most web developers are familiar with, eg&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setFoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;where &lt;code&gt;elem&lt;/code&gt; is any object implementing the &lt;code&gt;HTMLElement&lt;/code&gt; interface.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Jqry&lt;/strong&gt; is the category of jQuery objects (sets of DOM elements) and jQuery methods, eg&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Where the jQuery &amp;quot;object-set&amp;quot; of divs selected from the DOM is an example object in &lt;strong&gt;Jqry&lt;/strong&gt; and &lt;code&gt;addClass&lt;/code&gt; is an example morphism.&lt;/p&gt;

&lt;p&gt;We also saw that defining a mapping (Functor) from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt; and proving that composition is preserved suggests a possible performance win in the form of loop fusion. The two components of the mapping turned out to be jQuery&amp;#39;s dollar function and &lt;code&gt;$.map&lt;/code&gt; for objects and morphisms respectively. The important equivalence, preserving composition:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cmps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;which is an equivalence of two approaches (one of which requires one less iteration to accomplish the same task). This, viewed in the light of &amp;quot;interesting results from math&amp;quot;, is relatively exciting but the performance implications warranted some further exploration, which takes us to the meat of this post.&lt;/p&gt;

&lt;h2 id=&quot;toc_11&quot;&gt;Performance Reality&lt;/h2&gt;

&lt;p&gt;The most obvious and the least labor-intensive candidates for profiling loop fusion are jQuery methods that already rely on an &lt;em&gt;abstracted&lt;/em&gt; &lt;strong&gt;Html&lt;/strong&gt; morphism. They represent a real use case for that separation of functionality within the library.&lt;/p&gt;

&lt;p&gt;The one I chose was &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt;. It relies on &lt;code&gt;jQuery.removeAttr&lt;/code&gt; (note that this is not defined on the jQuery object prototype &lt;code&gt;jQuery.fn&lt;/code&gt;) for its DOM manipulations and uses the &lt;code&gt;jQuery.fn.each&lt;/code&gt; method to iterate over the set of elements.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Current jQuery.fn.removeAttr implementation in jQuery Core&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Testing a set of chained calls to &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; against a single loop with three inlined invocations of &lt;code&gt;jQuery.removeAttr&lt;/code&gt; &lt;a href=&quot;http://jsperf.com/remove-attr-composed-vs-chained-simple-methods/2&quot;&gt;yielded&lt;/a&gt; a fairly consistent 5-10 percent performance increase (blue bars). This was an &lt;a href=&quot;http://johnbender.github.com/presentation-faster-js/#24&quot;&gt;incentive&lt;/a&gt; of sorts that I used to keep people from running for the exits during my JQCON talk.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/alVRh.png&quot; alt=&quot;incentive&quot;&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately this doesn&amp;#39;t accurately represent the reality of most jQuery methods. The majority of the performance benefit appears to arise from the reduction in the number of function calls when a single loop with many invocations is used in place of multiple loop callbacks and function invocations. In the majority of jQuery methods the DOM alterations are actually inlined. That is, they don&amp;#39;t live in an abstracted &lt;strong&gt;Html&lt;/strong&gt; morphism at all -- the DOM elements are manipulated inside the loop and then returned to the jQuery &amp;quot;object-set&amp;quot;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// More likely/performant version with inlined dom manipulation&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// attr removal in jQuery.removeAttr&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Running a similar test but with an inlined implementation of &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; for the chained version resulted in a &lt;a href=&quot;http://jsperf.com/chained-sequence-or-composition-removeattr/2&quot;&gt;performance profile&lt;/a&gt; mostly indistinguishable from the manually fused alternative (blue and yellow bars in the graph below). While this might require more investigation it was fair to conclude that fusion isn&amp;#39;t compelling enough to warrant further work. Luckily a fruitful conversation with some of the attendees at my talk gave me a few ideas that might ultimately provide more value in terms of library architecture and performance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Qtq7Q.png&quot; alt=&quot;performance profile&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_12&quot;&gt;Even My Presentation had Side Effects&lt;/h2&gt;

&lt;p&gt;Most of the jQuery Core team was at the breakout session doing dramatic readings of bugs when I gave my presentation&lt;sup&gt;1&lt;/sup&gt; but there was a notable attendee in the front row, Yehuda Katz. He asked after my talk if the test methods were implemented using actual composition or simply invoked directly in serial (they were), alluding to the fact that the additional function call added with &lt;code&gt;cmps&lt;/code&gt; would negate the reduced loop iteration operations.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cmps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// the closure creates an additional function call&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As we saw earlier, even when DOM manipulation is abstracted into a function and invoked directly it&amp;#39;s likely in the best case to perform at/near parity with a jQuery method built on inlined DOM manipulation code. Consequently, adding the extra function wrapper and call to the execution path with &lt;code&gt;cmps&lt;/code&gt; may result in a slowdown (red bars in the previous graph).&lt;/p&gt;

&lt;p&gt;Yehuda subsequently also expressed interest in the idea of clearly separating the &lt;strong&gt;Html&lt;/strong&gt; morphisms from the &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that rely on them. That is, every jQuery method that manipulates the DOM has some form of an &lt;strong&gt;Html&lt;/strong&gt; morphism living inside it, be it inlined or abstracted into its own function (like &lt;code&gt;removeAttr&lt;/code&gt;). To illustrate we&amp;#39;ll take a naive implementation of &lt;code&gt;jQuery.fn.addClass&lt;/code&gt; and separate the DOM manipulation out. First, the current norm as inlined functionality:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Jqry morphism&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// !! Inlined DOM element manipulation&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldClassVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldClassVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then, abstracted:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Jqry morphism&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// !! Abstracted manipulation. Too expensive?&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Html morphism&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldClassVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;class&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setAttribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;oldClassVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;He rightly pointed out that from an architectural standpoint, this is a fairly compelling idea, so long as the extra function call doesn&amp;#39;t affect performance too drastically. Taking &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; as the test subject again, I inlined the contents of &lt;code&gt;jQuery.removeAttr&lt;/code&gt; and compared it to the original. For small sets it appears that the extra function call is negligible&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6XOM0.png&quot; alt=&quot;extra function call&quot;&gt;&lt;/p&gt;

&lt;p&gt;Just to be sure, it&amp;#39;s worth checking against larger jQuery object-sets. For large sets, as with loop fusion, the DOM manipulations outweigh something as fundamental as function invocation.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/cTeMr.png&quot; alt=&quot;extra function call larger set&quot;&gt;&lt;/p&gt;

&lt;p&gt;You can see in both cases that the overhead of abstracting the DOM manipulation into a function is mostly tenable, the notable exception being smaller sets of elements in Opera. If that small additional overhead in the common case is acceptable it exposes some benefits that the library can provide to framework authors and performance-minded developers.&lt;/p&gt;

&lt;h2 id=&quot;toc_13&quot;&gt;Architecture Benefits&lt;/h2&gt;

&lt;p&gt;Clearly, there are benefits from a clean separation for both the library itself and for advanced users relying on jQuery&amp;#39;s inbuilt &amp;quot;experience&amp;quot; with browser compatibility. If the two sides are kept separate jQuery Core could provide a build target that only includes the DOM manipulation and reduces the overall size of the gzipped include. Mobile devices have made file size a serious concern (belaboring the obvious) not just because of wire weight but also parsing time, and the reduction of code in this case could be significant.&lt;/p&gt;

&lt;p&gt;What&amp;#39;s more, external framework authors and other advanced users would have a more foundational building block to make use of without the commitment to the entire jQuery source. For example users who are happy to rely on &lt;code&gt;querySelectorAll&lt;/code&gt; (which enjoys relatively broad support) and who don&amp;#39;t need selectors/effects/etc could simply use the distilled knowledge in this hypothetical DOM manipulation core.&lt;/p&gt;

&lt;p&gt;Less interesting for end-users is the benefit to the Core team in terms of separating concerns and testing. For the DOM manipulations this change delineates &lt;code&gt;jQuery.fn&lt;/code&gt; methods as a usability layer on top of the underlying &lt;strong&gt;Html&lt;/strong&gt; morphism. If you ascribe to the ideas that fall out of the dependency between the two categories then &lt;strong&gt;Jqry&lt;/strong&gt; has always had this role. Also, where testing is concerned, the DOM manipulation methods can be tested in isolation from the code that makes jQuery easy to use (with stubbing in the latter case).&lt;/p&gt;

&lt;h2 id=&quot;toc_14&quot;&gt;Performance Benefits&lt;/h2&gt;

&lt;p&gt;Assuming a perfect world where every jQuery method involved in DOM element manipulation is built on an &lt;strong&gt;Html&lt;/strong&gt; morphism there are a couple of possible performance benefits. First, and least impactful is that it makes rewrapping DOM elements using the &lt;code&gt;$&lt;/code&gt;/&lt;code&gt;jQuery&lt;/code&gt; function unnecessary in many cases.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;.foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;click&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Current popular idiom&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// - In favor of -&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Using the underlying morphism&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Rewrapping DOM objects with a jQuery object in event and loop callbacks to get access to jQuery methods is common practice. If the same functionality on jQuery objects can be used to directly manipulate DOM elements, the rewrapping can be avoided all together. This isn&amp;#39;t likely to be a huge win, but the reduction in setup for iterating over jQuery objects cannot be overlooked.&lt;/p&gt;

&lt;p&gt;Much more interesting though is the possibility of stripping down the functionality provided by the DOM element manipulations. That is, removing the user-friendly layer associated with many jQuery methods and only providing the cross platform working core of each manipulation could have a serious performance and size impact. Again, looking at the &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; implementation, it&amp;#39;s built to accept a whitespace-delimited list for the attribute name value as a concession to terse manipulations.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Friendly&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;#foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;foo bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Not-friendly?&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;#foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeAttr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The performance benefits of using the manipulations directly without this additional feature are real. Simply stripping the split and loop from &lt;code&gt;jQuery.fn.removeAttr&lt;/code&gt; provided nearly a 25% gain&lt;sup&gt;3&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wA8wf.png&quot; alt=&quot;friendliness&quot;&gt;&lt;/p&gt;

&lt;p&gt;Again, the jQuery method would retain all its old functionality. The proposed underlying morphism is a new API. It can stick to what it does best: cross-platform manipulation of DOM elements. When a user is concerned about performance they can start looking at the ways their application uses jQuery and leverage a less friendly but still beautiful &amp;quot;low-level&amp;quot; API for DOM manipulations to save execution time.&lt;/p&gt;

&lt;h2 id=&quot;toc_15&quot;&gt;Beautiful API Design&lt;/h2&gt;

&lt;p&gt;Given the benefits in library size reduction a separate set of methods can provide, these methods should all be available on some top level namespace. &lt;code&gt;$&lt;/code&gt;/&lt;code&gt;jQuery&lt;/code&gt; may be the most obvious choice but this requires some consideration due to compatibility concerns with existing methods like &lt;code&gt;jQuery.removeAttr&lt;/code&gt; and &lt;code&gt;jQuery.css&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;More importantly it might be useful, as suggested in the previous posts, to provide the method as an attribute of its associated jQuery method. That is, &lt;code&gt;jQuery.removeAttr&lt;/code&gt; would exist on the &lt;code&gt;jQuery&lt;/code&gt; object and also as something like &lt;code&gt;jQuery.fn.removeAttr.domManip&lt;/code&gt; or &lt;code&gt;jQuery.fn.removeAttr.alterOne&lt;/code&gt;&lt;sup&gt;4&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;To illustrate, let&amp;#39;s look at an example with two conversions of a simple method chain assuming the jQuery function as the pure DOM manipulation namespace:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 1. Unoptimized&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;data-foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;background-color&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;red&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 2. Optimized with jQuery.fn.each&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// without check for null to remove, and hooks&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;data-foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// without hook&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;background-color&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;red&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 3. Optimized in a while loop to avoid extra calls&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$divs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;div&amp;quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$divs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$divs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// without check for null to remove, and hooks&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;data-foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// without hook&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;background-color&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;red&amp;#39;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;toc_16&quot;&gt;What happened to the Math?&lt;/h2&gt;

&lt;p&gt;Long story short: I&amp;#39;m looking into it. There is certainly a dependent relationship between the set of &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that operate on the contents of &lt;strong&gt;Jqry&lt;/strong&gt; objects (remember there are &lt;strong&gt;Jqry&lt;/strong&gt; morphisms that don&amp;#39;t, eg. &lt;code&gt;jQuery.fn.first&lt;/code&gt; only alters the container) and the underlying &lt;strong&gt;Html&lt;/strong&gt; morphisms. That subset of morphisms and all jQuery objects may form a subcategory &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/tTwkz.png&quot; alt=&quot;jquery sub h equation&quot;&gt;&lt;/p&gt;

&lt;p&gt;Where &lt;em&gt;F&lt;/em&gt; is the functor previously defined (eq 1), the objects of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are the objects of &lt;strong&gt;Jqry&lt;/strong&gt; (eq 3) and the morphisms of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are &lt;strong&gt;Html&lt;/strong&gt; morphisms lifted into &lt;strong&gt;Jqry&lt;/strong&gt; with &lt;em&gt;F&lt;/em&gt; (eq 3). Do note that morphisms of &lt;strong&gt;Jqry&lt;/strong&gt;&lt;sub&gt;h&lt;/sub&gt; are a proper subset of &lt;strong&gt;Jqry&lt;/strong&gt; because of methods like &lt;code&gt;jQuery.fn.first&lt;/code&gt; (eq 4).&lt;/p&gt;

&lt;p&gt;I&amp;#39;m sure there&amp;#39;s a more elegant way to represent the two sets, objects and morphisms, of this subcategory but this works for me now. Also, it&amp;#39;s not clear that there are useful practical implications for the dependency aside from how it might otherwise affect our perception of jQuery as a library. I intend to look into this a bit more when I have time.&lt;/p&gt;

&lt;h2 id=&quot;toc_17&quot;&gt;Further Investigation Required&lt;/h2&gt;

&lt;p&gt;If the goals presented here turn out to be of real value there&amp;#39;s a lot of work left to do. Most importantly the performance overhead of an extra function call in so many jQuery methods needs to be examined thoroughly, not just in jQuery Core but in dependent projects like UI, Mobile, and possibly plugins. Hopefully the initial impression of fast function calls bears out in further testing.&lt;/p&gt;

&lt;p&gt;It would also be useful to examine the conversion of some complex applications to the &lt;strong&gt;Html&lt;/strong&gt; morphisms to see what kind of cognitive overhead is incurred. If no one wants to use the underlying functions because they are a pain, then the exercise would be futile. This examination should includes aspects like namespacing and how each function is made available to the end user in both the full and &amp;quot;stripped down&amp;quot; builds.&lt;/p&gt;

&lt;p&gt;Ultimately the ideas here are a rough sketch.&lt;/p&gt;

&lt;h3 id=&quot;toc_18&quot;&gt;Footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;To be totally clear this isn&amp;#39;t a jab at the core team. I&amp;#39;m under the impression that the readings are really entertaining. Moreover the talks at conferences are rarely really interesting to the presenters in my experience. Most of the time you can find them chatting/hacking in the halls, which might indicate some level of boredom with the material and may even be a leading indicator of when someone is ready to start submitting talk proposals in terms of experience/content knowledge.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Appears&lt;/em&gt; is the key word here. More testing in varied situations is really required to make sure this small sample set is consistent with other jQuery methods.&lt;/li&gt;
&lt;li&gt;The benefits here will vary widely depending on the complexity of the &amp;quot;user-friendliness&amp;quot; built into a given jQuery method. Disclaim all the things!&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alterOne&lt;/code&gt; was, again, suggested by Yehuda during our discussion.&lt;/li&gt;
&lt;li&gt;The reader will have noted the conspicuous absence of IE in my performance test results. For whatever reason there was a consistent exception raised when executing the test code in IE that I haven&amp;#39;t had time to investigate. For serious consideration of the content in this post those numbers need to be included.&lt;/li&gt;
&lt;li&gt;perf links: &lt;a href=&quot;http://jsperf.com/chained-sequence-or-composition-removeattr/2&quot;&gt;chained, sequence, or composed&lt;/a&gt;, &lt;a href=&quot;http://jsperf.com/user-friendliness-overhead-for-remove-attr/2&quot;&gt;user friendlyness overhead&lt;/a&gt;, &lt;a href=&quot;http://jsperf.com/additional-function-call-overhead-for-remove-attr/3&quot;&gt;additional function call overhead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Special thanks to &lt;a href=&quot;http://twitter.com/keyist&quot;&gt;Tim Goh&lt;/a&gt; for reviewing this post.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Presentation: Middleware as a General Purpose Abstraction</title>
   <link href="http://johnbender.github.com/2012/04/28/middleware-as-a-general-purpose-abstraction"/>
   <updated>2012-04-28T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2012/04/28/middleware-as-a-general-purpose-abstraction</id>
   <content type="html">It was my pleasure to give this presentation at LARubyConf in February. You can find the &lt;a href=&quot;https://github.com/johnbender/presentation-middleware/tree/master/samples&quot;&gt;code samples&lt;/a&gt; and the &lt;a href=&quot;http://johnbender.github.com/presentation-middleware&quot;&gt;presentation slides&lt;/a&gt; on Github and a big thanks to the fine folks at &lt;a href=&quot;http://confreaks.com&quot;&gt;Confreaks&lt;/a&gt; for posting the video.

&lt;iframe width=&quot;610&quot; height=&quot;340&quot; src=&quot;http://www.youtube.com/embed/fcNaiP5tea0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
</content>
 </entry>
 
 <entry>
   <title>A Natural Transformation in JavaScript</title>
   <link href="http://johnbender.github.com/2012/03/22/a-natural-transformation-in-javascript"/>
   <updated>2012-03-22T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2012/03/22/a-natural-transformation-in-javascript</id>
   <content type="html">Natural transformations are a foundational construct in category theory, so it seems fitting to follow up my &lt;a href=&quot;/2012/02/29/faster-javascript-through-category-theory/&quot;&gt;last post&lt;/a&gt; by describing one using the categories &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;. As a result this post assumes the reader has covered the material from the last post. Also, as much as I wish that I could claim a similarly exciting result this will remain mostly an exercise in clarifying what natural transformations are and how they behave. If it's any consolation I've borrowed some very attractive TeX diagrams from Wikipedia to help illustrate.

&lt;h2&gt;Natural Transformations&lt;/h2&gt;

Natural transformations are actually fairly simple once you have an example you can comprehend. One way to describe them is - a set of morphisms&lt;sup&gt;1&lt;/sup&gt; that reconcile the way two functors from the same source to the same target categories alter morphisms of the source category&lt;sup&gt;2&lt;/sup&gt;. Unfortunately the written descriptions seems to fall short in aiding comprehension, but as promised there are pretty pictures:

&lt;div style=&quot;text-align: center;&quot;&gt;
&lt;img src=&quot;/../../../assets/images/transform/equation.png&quot; alt=&quot;n sub x compose F applied to f is equal to G applied to f compose n sub y&quot; /&gt;
&lt;/div&gt;

This equation is simple and captures the expected behavior of the natural transformation &lt;code&gt;N&lt;/code&gt; (used in place of &lt;code&gt;η&lt;/code&gt; hereafter). Namely, it must &quot;prepare&quot; input objects for a morphism transformed with &lt;code&gt;G&lt;/code&gt;, ie &lt;code&gt;G(f)&lt;/code&gt;, such that the result will be identical to that of &quot;repairing&quot; the output objects from a morphism transformed with &lt;code&gt;F&lt;/code&gt;, ie &lt;code&gt;F(f)&lt;/code&gt;. Again, this assumes that both &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; share that same source and target categories. Also it helps to remember that the input and output objects of &lt;code&gt;F(f)&lt;/code&gt; and &lt;code&gt;G(f)&lt;/code&gt; are in the target category, so if &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are both from categories &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;jQuery&lt;/strong&gt; we're just dealing with objects in &lt;strong&gt;Jqry&lt;/strong&gt;. If the notation is confusing recall that &lt;code&gt;○&lt;/code&gt; is the operator form of &lt;code&gt;$.compose&lt;/code&gt; and that &lt;code&gt;F(f)&lt;/code&gt; is that same as &lt;code&gt;$.Functor(f)&lt;/code&gt; from the previous post, both of which result in JavaScript functions/morphisms. While this equation gives us an understanding of how the transformation should function, it doesn't help with comprehending the transformations directionality and purpose.

&lt;div style=&quot;text-align: center&quot;&gt;
&lt;img src=&quot;/../../../assets/images/transform/diagram.png&quot; alt=&quot;diagram of composition&quot;/&gt;
&lt;/div&gt;

Diagrams are used to clarify composition of morphisms, a (the?) key operation in category theory. This diagram represents the same concept as the equation but it makes the goal more obvious: from &lt;code&gt;F(X)&lt;/code&gt; whether you take the road to the east - &lt;code&gt;Ny ○ F(f)&lt;/code&gt; or the road to the south - &lt;code&gt;G(f) ○ Nx&lt;/code&gt; - the result has to be the same. Again, the purpose of the natural tranformation is get the results to look like &lt;code&gt;G(f)&lt;/code&gt; results whether the operation started with &lt;code&gt;F(f)&lt;/code&gt; or ended with &lt;code&gt;G(f)&lt;/code&gt;.

If, at this point, it's still unclear don't worry the JavaScript examples should help.

&lt;h2&gt;Two Functors&lt;/h2&gt;

Since natural transformations are defined for two functors we'll borrow the &lt;code&gt;$.Functor&lt;/code&gt; from the last post and then try to find another. As a quick refresher the &lt;code&gt;$.Functor&lt;/code&gt; functor maps from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt; using the &lt;code&gt;$.fn.map&lt;/code&gt; method. We'll rename it &lt;code&gt;F&lt;/code&gt; so that it's easier to reconcile with the diagram/equation.

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;F&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map( a );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

The new functor obviously has to be different, so let's tweek the way that it operates on the functions from &lt;strong&gt;Html&lt;/strong&gt;. In this case the function it returns only applys the &lt;code&gt;html.morphism&lt;/code&gt; to the first member of the jQuery object's set. Note that it retains the same operation on objects in &lt;strong&gt;Html&lt;/strong&gt;, the application of &lt;code&gt;$()&lt;/code&gt;.

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;G&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      a( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;[0] );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

An alternate implementation that forwards the arguments down to the &lt;code&gt;html.morphism&lt;/code&gt; is a bit more complex but much more useful&lt;sup&gt;3&lt;/sup&gt;:

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;G&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;args&lt;/span&gt; = [].slice.call(arguments);

      args.unshift( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;[0] );
      a.apply( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, args );
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

At first this may seem like defining an alternate functor for the sake of it, but there are already methods in jQuery Core that behave in this fashion. For example a naive implementation of the &lt;code&gt;$.fn.css&lt;/code&gt; method using the argument-forwarding form of our new functor&lt;sup&gt;4&lt;/sup&gt;:

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.newCss = G(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;value&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;style&quot;&lt;/span&gt;,  key + &lt;span class=&quot;string&quot;&gt;&quot;: &quot;&lt;/span&gt; + value );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
});

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$foo&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$foo.newCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Now we've got two functors that satisfy the basics needed to define a natural transformation. They both have the same source and target categories, &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt; respectively, but they are distinct in the way that they achieve the goal of translating the functions/morphisms from &lt;strong&gt;Html&lt;/strong&gt; into functions/morphisms in &lt;strong&gt;Jqry&lt;/strong&gt;. Now we just need to find a way to make results from &lt;code&gt;F&lt;/code&gt; look like results from &lt;code&gt;G&lt;/code&gt;.

&lt;h2&gt;Finding the Transformation&lt;/h2&gt;

Recall from the diagram that the natural transformation must produce the same result whether it's composed &quot;in front of&quot; a &lt;code&gt;$.fn&lt;/code&gt; method defined with &lt;code&gt;G&lt;/code&gt; or after a &lt;code&gt;$.fn&lt;/code&gt; method defined with &lt;code&gt;F&lt;/code&gt;. Lets look at an example of two methods built with &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; using the css function in the previous example to see if that points us in the right direction. For completeness' sake we need to modify &lt;code&gt;F&lt;/code&gt; so that the function it returns accepts arguments:

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism | HTMLElement} -&amp;gt; {jqry.morphism | jQuery} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;F&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$this&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;,
          &lt;span class=&quot;variable-name&quot;&gt;args&lt;/span&gt; = [].slice.call(arguments);

      &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ) {
        args.unshift( elem );
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.apply( $this, args );
      });
    };
  }

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
}
&lt;/pre&gt;

Having squared that let's look at an example definition of two &lt;code&gt;$.fn&lt;/code&gt; methods using the Functors.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;alterCss&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;key&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;value&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;style&quot;&lt;/span&gt;,  key + &lt;span class=&quot;string&quot;&gt;&quot;: &quot;&lt;/span&gt; + value );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.mapCss = F(alterCss);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.oneCss = G(alterCss);

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$foo&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$foo.mapCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$bar&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; );           &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot;&amp;gt;&amp;lt;/div&amp;gt;, &amp;lt;span class=&quot;bar&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;$bar.oneCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;,
&lt;/span&gt;                                  &lt;span class=&quot;comment&quot;&gt;//  &amp;lt;span class=&quot;foo&quot;&amp;gt;&amp;lt;/span&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Here &lt;code&gt;$.fn.mapCss&lt;/code&gt; is equivelant to &lt;code&gt;F(f)&lt;/code&gt; and &lt;code&gt;$.fn.oneCss&lt;/code&gt; is equivelant to &lt;code&gt;G(f)&lt;/code&gt; in the equation and diagram. As you would expect the method created using &lt;code&gt;G&lt;/code&gt; only alters the first element in the jQuery object set where as the method created with &lt;code&gt;F&lt;/code&gt; alters all the elements. So our hypothetical natural transformation could simply reduce the jQuery object set to the first element in which case both results would be the same. The &lt;code&gt;$.fn.first&lt;/code&gt; method should serve. Borrowing the &lt;code&gt;$.compose&lt;/code&gt; function, again from the previous post, we can verify that it matches the equation.

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.FtoNy = $.compose( $.fn.first, F(alterCss) );
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.NxToG = $.compose( G(alterCss), $.fn.first );

$( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; ).FtoNy( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; ).NxToG( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

If you replace the application of &lt;code&gt;$.compose&lt;/code&gt; with the infix operator &lt;code&gt;○&lt;/code&gt; it looks just like the equation:

&lt;div style=&quot;text-align: center&quot;&gt;
  &lt;img src=&quot;/../../../assets/images/transform/equation.png&quot; alt=&quot;n sub x compose F applied to f is equal to G applied to f compose n sub y&quot; /&gt;
&lt;/div&gt;

With the order reversed we can use the more idiomatic fluent invocation:

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.mapCss = F(alterCss);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.oneCss = G(alterCss);

$( &lt;span class=&quot;string&quot;&gt;&quot;.foo&quot;&lt;/span&gt; ).mapCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ).first(); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;foo&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt; ).first().oneCss( &lt;span class=&quot;string&quot;&gt;&quot;display&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;none&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;div class=&quot;bar&quot; style=&quot;display: none&quot;&amp;gt;&amp;lt;/div&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

Let's alter the diagram to use the new method names:

&lt;div style=&quot;text-align: center&quot;&gt;
  &lt;img src=&quot;/../../../assets/images/transform/svg-methods.png&quot; alt=&quot;altered diagram&quot; title=&quot;svg-methods&quot; width=&quot;200&quot; height=&quot;162&quot; class=&quot;aligncenter size-full wp-image-1695&quot; /&gt;
&lt;/div&gt;

As you can see the southerly route first limits the jQuery object set and then applys the method that only operates on the first object, whereas the easterly route first applys the method that opperates on all the functions in the jQuery object set and then limits the set to one result. Most of the time you'll want to head South to save yourself some execution time.

&lt;h2&gt;Naturally&lt;/h2&gt;

The result of our work is a trivial optimization that most users should be able spot, ie. they might be creating a method chain that invokes &lt;code&gt;$.fn.first&lt;/code&gt; too late. In any case, the fact that we can arrive at this conclusion by viewing the JavaScript through the lense of mathematics continues to astound me and it makes me wonder what interesting things I might find by examining Monoids and Cartesion Closed categories.

&lt;ol&gt;
&lt;li&gt;Thanks to Dan Peebles, otherwise known as &lt;a href=&quot;http://twitter.com/copumpkin&quot;&gt;copumpkin&lt;/a&gt;, for reviewing the introduction to natural transformations and suggesting this addition.&lt;/li&gt;
&lt;li&gt;This is far from rigorous. For a more concrete definition checkout the &lt;a href=&quot;http://en.wikipedia.org/wiki/Natural_transformation&quot;&gt;wikipedia page&lt;/a&gt; and &lt;a href=&quot;http://www.haskell.org/haskellwiki/Category_theory/Natural_transformation&quot;&gt;haskell wiki page&lt;/a&gt; pages. My attempt to rephrase the definition comes from my experiences learning abstract concepts like this where I've often been aided by many different renderings of the same idea.&lt;/li&gt;
&lt;li&gt;It's important to keep in mind that, as a result of forwarding the arguments, we've technically changed the type signature of the &lt;strong&gt;Html&lt;/strong&gt; morphism from &lt;code&gt;HTMLElement -&amp;gt; HTMLElement&lt;/code&gt; to &lt;code&gt;HTMLElement, String, String -&amp;gt; HTMLElement&lt;/code&gt;. For the purposes of our discussion I thought it was usefull to pull an existing example from jQuery to illustrate how the second functor works. Also if the jQuery object is empty this will `unshift` undefined as the first argument. Again, clarity proved to be more important.&lt;/li&gt;
&lt;li&gt;This implementation omits even simple style persistence for the sake of focusing the reader on the subject matter.&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Leveraging Your Insecurities</title>
   <link href="http://johnbender.github.com/2012/02/22/leveraging-your-insecurities"/>
   <updated>2012-02-22T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2012/02/22/leveraging-your-insecurities</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;update&lt;/strong&gt;: This article has been &lt;a href=&quot;http://news.ycombinator.com/item?id=3621425&quot; title=&quot;Hacker News Discussion&quot;&gt;posted to Hacker News&lt;/a&gt;. If you enjoy it and are a member there please upvote/comment.&lt;/p&gt;

&lt;p&gt;I believe mine is a fairly common condition as a software developer. I know, or at least believe, that I&amp;#39;m smart enough to be paid well for the work that I do, but the state of my intelligence relative to the &amp;quot;great minds&amp;quot; in the communities of which I&amp;#39;m a part (JavaScript and Ruby) is an unknown. My tendency is to assume, as a baseline, that nearly any developer I don&amp;#39;t know is smarter and more capable than I am.&lt;/p&gt;

&lt;p&gt;This manifests as a whole host of negative behaviors, everything from grasping wildly at straws on subjects in which I have little or no background, to simply feeling left out of conversations that I would kill to participate in. As bad as the action might be, the self loathing that comes later is far worse and can haunt me long after. Oddly, even after viewing the same situations from the other side, that of the knowledgeable participant, the most endearing quality in those less knowledgeable is honesty and enthusiasm!&lt;/p&gt;

&lt;h2&gt;How then?&lt;/h2&gt;

&lt;p&gt;So, aside from attempting to correct these behaviors, what am I to make of all the nervous energy generated by the shame of my social and intelectual failings? For one, I&amp;#39;ve taken up public speaking at conferences and meetups as a means through which to prove to my peers and myself that I am a capable speaker and thoughtful developer. I like to think of it as a sort of act in defiance of my own, well documented, shortcomings. And while this clearly exposes an ugly character flaw in the need to repair my ego, a well thought out and executed presentation has many benefits where confidence, or its absence, is concerned.&lt;/p&gt;

&lt;p&gt;First, it forces me, as the presenter, to fully realize and enumerate an idea from start to finish. This includes branching out into little corners and dark areas of the topic from which a question might be raised. The fear of being caught out without a response to an obvious question drives me, as much as possible, to gather a comprehensive knowledge of what I&amp;#39;m presenting on. This may not be the case for all presenters but I feel compelled to become something of a topic expert before even submitting the proposal.&lt;/p&gt;

&lt;p&gt;Second, it requires that I accept not everyone will care about the material or agree with the premise. Even in a room of 30 people, the best technical presentation, no matter how funny, relevant, and inspiring is likely to lose someone. They didn&amp;#39;t have enough coffee, their lunch gave them gas, they&amp;#39;re already a topic expert, or their pager simply went off and they have to struggle to diagnose a production issue over the spotty conference Wi-Fi. Learning to accept the imperfect nature of your presentation is a good start to accepting that the things you say will not always be ground breaking/thoughtful/witty.&lt;/p&gt;

&lt;p&gt;Last, public speaking requires that you ... speak in public. The confidence that repeated speaking engagements builds in the presenter is not to be underestimated and it translates directly into other social interactions. Meetings, performance reviews, and virtually any expository conversation will benefit directly from the ease with words that one develops.&lt;/p&gt;

&lt;h2&gt;(Bumb|Stumb|Fumb)ling Into The Endzone&lt;/h2&gt;

&lt;p&gt;Another particularly interesting behavior that appears to be closely correlated with my involvement in the jQuery Mobile project is a desire to be extremely(+/-) thorough in responses to my teammates and external developers on technical issues.&lt;/p&gt;

&lt;p&gt;I should mention that, for internal team issues, this is not always the case. The sad truth is that the people I work with day to day already have a sense, positive or negative, for my capabilities as a developer and expending large amounts of effort to sway their opinion would be a waste. This seems to suggest that the reason for the enormous effort I put in where external developers interact with the project is, in many cases, the conversation on github over an issue or a pull request will be the only interaction that these people ever have with me. As a result I do my best to be careful about presenting intelligent and thoughtful answers to their questions/requests in the hopes of cultivating a positive perception of me in the broader developer community.&lt;/p&gt;

&lt;p&gt;For instance last year, before jQuery Mobile went 1.0, one of our users (&lt;a href=&quot;https://github.com/jammus&quot; title=&quot;Jammus on Github&quot;&gt;jammus&lt;/a&gt;) logged an &lt;a href=&quot;https://github.com/jquery/jquery-mobile/issues/1579&quot; title=&quot;jQuery Mobile Issue 1579&quot; target=&quot;_blank&quot;&gt;issue&lt;/a&gt; he was experiencing while using the appcache on iOS. After some discussion and proposed workarounds Todd Parker (our team lead) asked me to take a look. A short time later, once I felt understood the issues at hand, I &lt;a href=&quot;https://github.com/jquery/jquery-mobile/issues/1579#issuecomment-2374186&quot; title=&quot;jQuery Mobile Issue 1579 Comment&quot; target=&quot;_blank&quot;&gt;voiced my concerns&lt;/a&gt; about the solutions that other user&amp;#39;s were offering in the thread. If you scroll down you can almost watch me sweat as I reread my response and correct with additional comments. There&amp;#39;s a &lt;a href=&quot;https://github.com/jquery/jquery-mobile/issues/1579#issuecomment-2374321&quot; title=&quot;jQuery Mobile Issue 1579 Comment 2&quot;&gt;follow up&lt;/a&gt; noting that CORS requests won&amp;#39;t work, which I later correct after realizing that appcache requests can&amp;#39;t be cross domain according &lt;a href=&quot;http://dev.w3.org/html5/spec/offline.html#appcache&quot; title=&quot;Appcache w3 Spec&quot;&gt;the spec&lt;/a&gt;. My comment just below that is &lt;em&gt;edited out&lt;/em&gt;, and while it&amp;#39;s not totally obvious what I was thinking I do remember being at least mildly embarrassed.&lt;/p&gt;

&lt;p&gt;The ultimate result of that interaction was positive: we decided that the hacks suggested would suffice for now and that the issue should be left open for developers experiencing the same problem. I like to believe that is at least in part due to how much effort I expended not just in attempting to help but also in making sure I didn&amp;#39;t look silly.&lt;/p&gt;

&lt;h2&gt;You Can't Always Be Right&lt;/h2&gt;

&lt;p&gt;Before I close this post I would like to address at least one common symptom of being insecure about your intelligence, that is the need to always be right. Again, I have to believe that this is a common issue among developers, especially because we are consistently debating very technical ideas and because I&amp;#39;ve seen it so often in myself and others. You can spot it in your own behavior if you, like me, tend to get agitated or excited when someone doesn&amp;#39;t agree with you. For my part the fix is so small as to seem insignificant:&lt;/p&gt;

&lt;p&gt;Speak your ideas in the form of a question.&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;What a difference the inflection at the end of a sentence can make in the tone of a discussion! So often when leading with &amp;quot;You should ...&amp;quot; or &amp;quot;We should ...&amp;quot;, especially in a text medium, it presents an unapproachable front and stifles conversation. Instead, leading with &amp;quot;Can we ...&amp;quot; or &amp;quot;Should we ...&amp;quot; leaves the door open for others to freely express concerns or offer totally different approaches. By asking a question you invite discussion and criticism, and position yourself in direct opposition to your insecurity.&lt;/p&gt;

&lt;h2&gt;Don't Forget To Take Out The Trash&lt;/h2&gt;

&lt;p&gt;Generally, being insecure is not a positive thing. It&amp;#39;s at the root of jealousy, resentment, and other Dark Side behavior. Even so, I don&amp;#39;t think it&amp;#39;s necessary to let your insecurities, or more specifically the motivating force they can provide, go to waste. Just don&amp;#39;t forget that while using them to motivate you, addressing the actual problems they represent has to take center stage.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;How do I know this works? I have the distinct pleasure of interacting with &lt;a href=&quot;https://twitter.com/scottjehl&quot; title=&quot;Scott Jehl on Twitter&quot;&gt;Scott Jehl&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/toddmparker&quot; title=&quot;Todd Parker on Twitter&quot;&gt;Todd Parker&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/kinblas&quot; title=&quot;Kin Blas on Twitter&quot;&gt;Kin Blas&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/wilto&quot; title=&quot;Mat Marquis on Twitter&quot;&gt;Mat Marquis&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/gseguin&quot; title=&quot;Ghislain Seguin on Twitter&quot;&gt;Ghislain Seguin&lt;/a&gt; every day while working on the jQuery Mobile project and this approach to collaboration is always the order of the day. Obviously one sample does not a tautology make, but it's one of the very best teams/environments I've ever worked with/in.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Special thanks to &lt;a href=&quot;https://twitter.com/kinblas&quot; title=&quot;Kin Blas on Twitter&quot;&gt;Kin Blas&lt;/a&gt; for his feedback on the article.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Faster Javascript Through Category Theory</title>
   <link href="http://johnbender.github.com/2012/02/09/faster-javascript-through-category-theory"/>
   <updated>2012-02-09T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2012/02/09/faster-javascript-through-category-theory</id>
   <content type="html">&lt;p&gt;This post started out as a &lt;a href=&quot;https://gist.github.com/7242a7434195565b4a9d&quot;&gt;gist&lt;/a&gt; that I was using to work through what I&amp;#39;ve learned about category theory by applying it to something I already know: JavaScript. The surprising result was a clearly defined set of JavaScript functions and jQuery helpers that could be optimized to reduce execution time.&lt;/p&gt;

&lt;p&gt;In the course of this post we&amp;#39;ll define two categories: one for HTMLElements and the other for jQuery objects. We&amp;#39;ll then construct a Functor that maps from the category of HTMLElements to the category of jQuery objects. At the end we&amp;#39;ll see how jQuery plugin authors can help user&amp;#39;s speed up their JavaScript.&lt;/p&gt;

&lt;h3 id=&quot;toc_0&quot;&gt;Asumptions/Requirements&lt;/h3&gt;

&lt;p&gt;Some things to know before getting started:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; is treated as an implicit parameter to jQuery helper functions, later referred to as &lt;strong&gt;Jqry&lt;/strong&gt; morphisms.&lt;/li&gt;
&lt;li&gt;Type guarantees are made by the closure compiler JSDoc type annotations and custom &lt;code&gt;@sig&lt;/code&gt; type signature annotation. Don&amp;#39;t worry if this is new to you -- it only adds a bit more rigor to the discussion.&lt;/li&gt;
&lt;li&gt;My examples do not constitute proofs but I&amp;#39;m fairly confident that both categories and the functor satisfy their respective laws.&lt;sup&gt;1&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;Categories&lt;/h3&gt;

&lt;p&gt;If you&amp;#39;re perfectly happy taking the category definitions at face value, feel free to skip ahead to the next section.&lt;/p&gt;

&lt;p&gt;A category consists of two things, a set of objects and a set of morphisms sometimes referred to as arrows that relate two of those objects. In layman&amp;#39;s terms, a category is a consistent set of things (objects) and operations on those things (morphisms/arrows). The abstract nature of both is exactly what gives categories and category theory power, because you can define a wide range of systems in terms of a categories. A few examples, including the two defined later in the post, will help to build an intuition for the forms that objects and morphisms can take.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category&quot;&gt;Hask&lt;/a&gt; is the category where Haskell types are the objects and functions are the morphisms.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Category_of_sets&quot;&gt;Set&lt;/a&gt; is the category where objects are sets and the morphism are, again, functions between those sets.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Additionally each and every category must satisfy three laws.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Identity: The morphisms in a category must include an identity morphism. In terms of the category Set or Hask and those defined here, the identity morphism is just a function that return it&amp;#39;s first and only argument.&lt;/li&gt;
&lt;li&gt;Composition: The composition of morphisms, which is itself a requirement, must be associative. For Hask, Set, and the following categories this is simply function composition (eg &lt;code&gt;.&lt;/code&gt; for Hask) and we&amp;#39;ll explicitly define a composition function for &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt;. Function application is always associative&lt;sup&gt;2&lt;/sup&gt; so for Hask, Set and the categories to follow this can be assumed.&lt;/li&gt;
&lt;li&gt;Closed Under Composition: When composing two morphisms in a category the result must also be in the set of morphisms in the category. For Hask this means that the output of composing two functions must be another function that takes a Haskell type and returns a Haskell type which is the criteria for the function being in the set of Hask&amp;#39;s morphisms.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These laws are important for understanding the conclusions drawn from the rest of the post and we&amp;#39;ll cover how both the &lt;strong&gt;Html&lt;/strong&gt; and &lt;strong&gt;Jqry&lt;/strong&gt; categories satisfies each.&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;Html&lt;/h3&gt;

&lt;p&gt;The Category &lt;strong&gt;Html&lt;/strong&gt; is extremely simple and, if you&amp;#39;re still interested in understanding categories more generally, it will help in building an intuition for them. The objects in &lt;strong&gt;Html&lt;/strong&gt; are the HTMLElements that you&amp;#39;re familiar with from JavaScript (eg, HTMLDivElement, HTMLAnchorElement). The morphisms are JavaScript functions that opperate on those objects, and &lt;em&gt;only&lt;/em&gt; those objects.&lt;/p&gt;

&lt;p&gt;The next step is to make sure that &lt;strong&gt;Html&lt;/strong&gt; satisfies the three category laws:&lt;/p&gt;

&lt;p&gt;Identity:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {HTMLElement} -&amp;gt; {HTMLElement} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;id&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;
}
&lt;/pre&gt;

&lt;p&gt;Composition:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @typedef {function(HTMElement): HTMElement} */&lt;/span&gt;
html.morphism;

&lt;span class=&quot;doc&quot;&gt;/** @sig {html.morphism}, {html.morphism} -&amp;gt; {html.morphism} */&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;compose&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;f&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;g&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ) {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f(g(a));
  };
}
&lt;/pre&gt;

&lt;p&gt;Sample use of &lt;code&gt;compose&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;elem&lt;/span&gt; = document.getElementById( &lt;span class=&quot;string&quot;&gt;&quot;example-anchor&quot;&lt;/span&gt; );
elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;
elem = compose( a, b )( elem );
elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;elem.getAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The identity function is trivial and, as noted before, function composition is always associative. We know that the functions in &lt;strong&gt;Html&lt;/strong&gt; are closed under composition because of the type guarantees we&amp;#39;ve placed on them. That is, all the functions accept as their only argument HTMLElements and return only HTMLElements so there&amp;#39;s no way to compose two of them that doesn&amp;#39;t also have the same type signature. Having met the three requirements for a category with &lt;strong&gt;Html&lt;/strong&gt; we can move on to the second, and more complex category &lt;strong&gt;Jqry&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;Jqry&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jqry&lt;/strong&gt; is the category of &lt;code&gt;jQuery&lt;/code&gt; objects and functions from &lt;code&gt;jQuery&lt;/code&gt; objects to &lt;code&gt;jQuery&lt;/code&gt; objects.&lt;sup&gt;3&lt;/sup&gt; It&amp;#39;s only slightly more complex than &lt;strong&gt;Html&lt;/strong&gt; because the reader must accept &lt;code&gt;this&lt;/code&gt; as an implicit parameter to the JavaScript functions that are the category&amp;#39;s morphisms. Also, these morphisms must be defined on the &lt;code&gt;$.fn&lt;/code&gt; object to guarantee the value of &lt;code&gt;this&lt;/code&gt; is a &lt;code&gt;jQuery&lt;/code&gt; object. Otherwise the objects are simply jQuery objects as you know them from day to day use, ie the result of something like &lt;code&gt;$(&amp;quot;div&amp;quot;)&lt;/code&gt;, and the functions are JavaScript functions that retun jQuery objects.&lt;/p&gt;

&lt;p&gt;Identity:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @this {jQuery}
    @return {jQuery} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){ &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;return this&lt;/span&gt;&lt;/span&gt; };
&lt;/pre&gt;

&lt;p&gt;Sample use of &lt;code&gt;$.fn.id&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$elem&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );

assert($elem.id() == $elem); &lt;span class=&quot;comment&quot;&gt;// true
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the value of &lt;code&gt;this&lt;/code&gt;, and therefore the constraint that the morphisms must be defined on &lt;code&gt;$.fn&lt;/code&gt;, plays an important roll in the way that the functions behave in the &lt;strong&gt;Jqry&lt;/strong&gt; category. If it&amp;#39;s unclear why that is, remember that &lt;code&gt;this&lt;/code&gt; is whatever object the method is invoked on using dot notation in JavaScript. Also recall that &lt;code&gt;$.fn == $.prototype&lt;/code&gt;, meaning when you call &lt;code&gt;$(&amp;quot;div&amp;quot;).foo()&lt;/code&gt; it finds &lt;code&gt;foo&lt;/code&gt; on the &lt;code&gt;$.fn&lt;/code&gt; by following the prototype chain.&lt;/p&gt;

&lt;p&gt;Composition:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @typedef {function(this:jQuery): jQuery} */&lt;/span&gt;
jqry.morphism;

&lt;span class=&quot;doc&quot;&gt;/** @sig {jqry.morphism}, {jqry.morphism} -&amp;gt; {jqry.morphism} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;compose&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;f&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;g&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
    &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;return f.apply(g.apply(this, arguments), arguments)&lt;/span&gt;&lt;/span&gt;
  };
};
&lt;/pre&gt;

&lt;p&gt;Defining composition is a bit more complex for &lt;strong&gt;Jqry&lt;/strong&gt; than it is for &lt;strong&gt;Html&lt;/strong&gt; if only because forcing the value that &lt;code&gt;this&lt;/code&gt; will represent in the composed functions takes more work than just passing in the values as parameters. The first function, &lt;code&gt;g&lt;/code&gt;, is invoked by forwarding the arguments and explicitly defining its &lt;code&gt;this&lt;/code&gt; value using the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply&quot;&gt;apply&lt;/a&gt; method common to all JavaScript functions. The value returned by applying &lt;code&gt;g&lt;/code&gt; is a jQuery object, as required by membership in the category &lt;strong&gt;Jqry&lt;/strong&gt;, which is used to explicitly define &lt;code&gt;this&lt;/code&gt; in the application of &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Sample use:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
    elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
  });
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
    elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
  });
};

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$elem&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );
$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.aAndB = $.compose( $.fn.a, $.fn.b );

$elem.aAndB().attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt; );         &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Please direct your attention to the fact that you could substitute the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; functions from the &lt;strong&gt;Html&lt;/strong&gt; &lt;code&gt;compose&lt;/code&gt; example here for the functions that are mapped using &lt;code&gt;this.map&lt;/code&gt; (&lt;code&gt;$.fn.map&lt;/code&gt;) over the set of elements in the jQuery object (represented by &lt;code&gt;this&lt;/code&gt;). This will be important when defining the Functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Again, we know that the morphisms of &lt;strong&gt;Jqry&lt;/strong&gt; are closed under composition because each accepts and returns only jQuery objects.&lt;/p&gt;

&lt;h3 id=&quot;toc_4&quot;&gt;$() ∉ Functors&lt;/h3&gt;

&lt;p&gt;Functors are a &lt;em&gt;single&lt;/em&gt; morphism from one category to another. Another way to think about them is a an operation that can take either an object or a morphism from one category and translate it so that it exists or &amp;quot;works&amp;quot; in another category. This obvioulsy means that a given functor handles both morphisms and objects. Evaluating &lt;code&gt;$()&lt;/code&gt; as a functor from &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;, shows that it translates the objects in the category &lt;strong&gt;Html&lt;/strong&gt; (HTMLElements) properly to the objects in &lt;strong&gt;Jqry&lt;/strong&gt; (instances of jQuery) but turns the morphisms (functions) into dom ready callbacks. So &lt;code&gt;$()&lt;/code&gt; is not, strictly speaking, a category theoretic functor.&lt;/p&gt;

&lt;p&gt;On the other hand it&amp;#39;s quite easy to define a function that handles both objects functions properly. As I noted in a previos post and in an earlier in this post, &lt;code&gt;$.fn.map&lt;/code&gt; provides an easy way to change functions in &lt;strong&gt;Html&lt;/strong&gt; to &lt;strong&gt;Jqry&lt;/strong&gt;. So, this new functor just needs to check if it&amp;#39;s operating on an object or a function from the &lt;strong&gt;Html&lt;/strong&gt; category and respond accordingly.&lt;/p&gt;

&lt;p&gt;For the Haskell fans out there (and ciaranm in ##categorytheory) it&amp;#39;s better to define a seperate function to handle the translation of morphisms from one category to another in the spirit of &lt;code&gt;fmap&lt;/code&gt;, but since this is flexible ol&amp;#39; JavaScript, it&amp;#39;s possible to use type unions in the closure compiler type constraints, and I think it makes the mapping from theory to Javascript a bit easier to understand, I&amp;#39;ve chosen to deal with both in a single function.&lt;/p&gt;

&lt;h3 id=&quot;toc_5&quot;&gt;Functor Html -&amp;gt; Jqry&lt;/h3&gt;

&lt;pre&gt;
&lt;span class=&quot;doc&quot;&gt;/** @sig {HTMLElement | html.morphism} -&amp;gt; {jQuery | jqry.morphism} */&lt;/span&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;Functor&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; a == &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; ){
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(a);
    };
  } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $( a );
  }
};
&lt;/pre&gt;

&lt;p&gt;Sample use for objects:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;elem&lt;/span&gt;&lt;/span&gt; = document.getElementsById( &lt;span class=&quot;string&quot;&gt;&quot;example&quot;&lt;/span&gt; );
elem.nodeName;                        &lt;span class=&quot;comment&quot;&gt;// &quot;A&quot;
&lt;/span&gt;$.Functor( elem ).prop( &lt;span class=&quot;string&quot;&gt;&quot;nodeName&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;A&quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Sample use for functions:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.myMorphism = $.Functor(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt; ){
  a.setAttribute(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a;
});

$( &lt;span class=&quot;string&quot;&gt;&quot;#example&quot;&lt;/span&gt; ).attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; );              &lt;span class=&quot;comment&quot;&gt;// undefined
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;#example&quot;&lt;/span&gt; ).myMorphism().attr( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt; ); &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;In the first example it takes an HTMLElement, the objects onf &lt;strong&gt;Html&lt;/strong&gt;, and translates it into a jQuery object by using the &lt;code&gt;$()&lt;/code&gt; function. In the second example it takes a function from HTMLElements to HTMLElements, a morpishm in &lt;strong&gt;Html&lt;/strong&gt;, and translates it to a function from jQuery objects to jQuery objects.&lt;/p&gt;

&lt;p&gt;Having establish how the functor will operate it too has laws we must adhear to. First it must preserve identity:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; = document.getElementById( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );

assert($.Functor(id(a)) == id($.Functor(a)));

a;                 &lt;span class=&quot;comment&quot;&gt;// &amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/span&gt;
id(a);             &lt;span class=&quot;comment&quot;&gt;// &amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/span&gt;$.Functor(id(a));  &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;
$.Functor(a);      &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;$.Functor(a).id(); &lt;span class=&quot;comment&quot;&gt;// [&amp;lt;a id=&quot;example-anchor&quot;&amp;gt;&amp;lt;/a&amp;gt;]
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Whether the identity function is applied before or after the Functor the result should be the same. As you can see the return value of the two expressions is idenitcal. The second law states the the Functor must preserve composition. Assuming a and b from the html compose example:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;$elem&lt;/span&gt;&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;#example-anchor&quot;&lt;/span&gt; );
assert($.Functor(compose(a, b)) == $.compose($.Functor(a), $.Functor(b)));

&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;aAndB&lt;/span&gt; = compose(a, b);
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.fstAB = $.Functor(aAndB);                       &lt;span class=&quot;comment&quot;&gt;// function() { this.map(aAndB); }
&lt;/span&gt;$elem.fstAB().attr(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;);                           &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr(&lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);                                   &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;
$elem = $( &lt;span class=&quot;string&quot;&gt;&quot;#second-example-anchor&quot;&lt;/span&gt; );
$.Functor(a);                                        &lt;span class=&quot;comment&quot;&gt;// function() { this.map(a) };
&lt;/span&gt;$.Functor(b);                                        &lt;span class=&quot;comment&quot;&gt;// function() { this.map(b) };
&lt;/span&gt;&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.sndAB = $.compose( $.Functor(a), $.Functor(b) );
$elem.sndAB().attr(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;);                           &lt;span class=&quot;comment&quot;&gt;// &quot;bar&quot;
&lt;/span&gt;$elem.attr(&lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;);                                   &lt;span class=&quot;comment&quot;&gt;// &quot;bak&quot;
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;This means that composing the functions and then applying the Functor should create a function that behaves identically to a function created by composing two functions that have had the Functor applied already. Essentially, for all input values the output will be the same. We&amp;#39;ll see in a second why that distinction is important.&lt;/p&gt;

&lt;p&gt;The assertion at the top will fail of course because the functions are not the same object. More importantly it would fail even if the functions were compared as strings, because they using different internal mechanisms. Ultimately though the functionality is the same and that&amp;#39;s what we care about. In each case both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be allowed to alter each element in the jQuery object&amp;#39;s set and apply the attribute values &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;While they have the same outcome, the underlying machinery is very different. &lt;code&gt;$.fn.fstAB&lt;/code&gt; is &lt;em&gt;one&lt;/em&gt; iteration over the set of HTMLElements in the jQuery set and &lt;code&gt;$.fn.sndAB&lt;/code&gt; is &lt;em&gt;two&lt;/em&gt;. That is &lt;code&gt;$.fn.sndAB&lt;/code&gt; is applying two seperate &lt;code&gt;$.fn&lt;/code&gt; methods which is equivelant to &lt;code&gt;$(&amp;quot;foo&amp;quot;).a().b()&lt;/code&gt;, where as &lt;code&gt;$.fn.fstAB&lt;/code&gt; is calling &lt;code&gt;$.fn.map&lt;/code&gt; only once and piping each element through two composed functions that operate on HTMLElements, &lt;code&gt;$(&amp;quot;foo&amp;quot;).map(aAndB)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt; They get the same results but &lt;code&gt;$.fn.sndAB&lt;/code&gt; requires twice as many iterations over the jQuery set!&lt;/p&gt;

&lt;p&gt;You might recognize the optimization as &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_fusion&quot;&gt;loop fusion&lt;/a&gt;. By ensuring that the functor satisfies the requsite laws we&amp;#39;ve stumbled upon an interesting relationship. That is, any time we use n &amp;gt; 1 iterative &lt;code&gt;$.fn&lt;/code&gt; methods that exist in &lt;strong&gt;Jqry&lt;/strong&gt; it&amp;#39;s possible to extract the pure HTMLElement-altering functions that &lt;em&gt;might&lt;/em&gt; underly them, compose those functions, and save n-1 full iterations in the process.&lt;/p&gt;

&lt;h3 id=&quot;toc_6&quot;&gt;Loop Fusing Hipster&lt;/h3&gt;

&lt;p&gt;It&amp;#39;s clear that someone using &lt;code&gt;$(&amp;quot;foo&amp;quot;).a().b()&lt;/code&gt; could, entirely indepdendent of this rigmarole, arrive at the same conclusion that the loops underlying &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be unified to speed up execution and subsequently point out they&amp;#39;ve been fusing loops since before it was cool. What&amp;#39;s not clear is how to know in other cases when it&amp;#39;s possible to extract the underlying functions from the &lt;code&gt;$.fn&lt;/code&gt; methods for composition. Because of the Functor laws we&amp;#39;ve unambiguously defined a specific subset of functions -- the set of &lt;strong&gt;Html&lt;/strong&gt; morphisms with &lt;code&gt;$.fn.map&lt;/code&gt; applied -- that we &lt;em&gt;know&lt;/em&gt; can be fused and will produce the same result. Put differently:&lt;/p&gt;

&lt;p&gt;As long as the &lt;em&gt;n&lt;/em&gt; functions being mapped over the jQuery object&amp;#39;s contents individually are all from HTMLElements to HTMLElements, we can compose them, map the resulting composed function over the jQuery object set &lt;em&gt;once&lt;/em&gt;, and be asured the resulting jQuery object will be the same.&lt;/p&gt;

&lt;h3 id=&quot;toc_7&quot;&gt;Package it up&lt;/h3&gt;

&lt;p&gt;Now that we know which functions can be composed to save some execution time it would be nice to know how use this to improve jQuery plugins. One way is to get jQuery plugin authors provide the underlying DOM manipulation functions as attributes on the plugin methods. This would allow users to do the fusing when it makes sense. Lets use our two composition examples from the &lt;strong&gt;Jqry&lt;/strong&gt; category to see what this might look like.&lt;/p&gt;

&lt;p&gt;Plugin one:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;setFoo&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;a&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(setFoo);
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.a.pure = setFoo;
&lt;/pre&gt;

&lt;p&gt;Plugin two:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;setBaz&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  elem.setAttribute( &lt;span class=&quot;string&quot;&gt;&quot;baz&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bak&quot;&lt;/span&gt; );
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
}

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.map(setBaz);
};

&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.b.pure = setBaz;
&lt;/pre&gt;

&lt;p&gt;Now both the function from &lt;strong&gt;Html&lt;/strong&gt; and the function from &lt;strong&gt;Jqry&lt;/strong&gt; are available to the end user. Should they end up using them in serial it&amp;#39;s trivial to fuse the two loops:&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;comment&quot;&gt;// two full iterations
&lt;/span&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;).a().b();

&lt;span class=&quot;comment&quot;&gt;// one full iteration
&lt;/span&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;).map(compose($.fn.a.pure, $.fn.b.pure));
&lt;/pre&gt;

&lt;p&gt;Obviously these two examples are tiny and could easily be consolidated by hand, but two plugins with more complex DOM manipulations would be much harder to classify as &amp;quot;fusable&amp;quot;. By puting the onus on the plugin developer it gives the end user a better guarantee that it&amp;#39;s safe.&lt;/p&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;Did you make it?&lt;/h3&gt;

&lt;p&gt;And there you have it. After defining a mathematical framework in which to view DOM alterations with jQuery and JavaScript we identified an important set of characteristics to use for speeding up our client side code. Maybe this isn&amp;#39;t enough to get you interested, but for me it&amp;#39;s an afirmation that, even this far from the its ivory towers, math has a role to play.&lt;/p&gt;

&lt;h3 id=&quot;toc_9&quot;&gt;Footnotes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Thanks again to edwardk and xplat from #haskell-blah and ciaranm from ##categorytheory for reviewing my categories and providing feedback. I&amp;#39;d also like to thank &lt;a href=&quot;http://twitter.com/keyist&quot;&gt;Tim Goh&lt;/a&gt; for taking the time to enhance my terrible writting.&lt;/li&gt;
&lt;li&gt;Function composition is always associative, even for impure functions. You&amp;#39;ll have to google around a bit for a proof but this appears to be a &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;generally excepted truth&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;If you&amp;#39;re interested in digging a bit further into this topic &lt;strong&gt;Jqry&lt;/strong&gt; is actually a monoidal category. Credit to both edwardk and xplat in #haskell-blah for pointing this out. As far as I can tell, the morphisms (&lt;code&gt;$.fn&lt;/code&gt; methods) are muplication as they map from jQuery to jQuery and the unit element is &lt;code&gt;[]&lt;/code&gt; since using it with &lt;code&gt;$()&lt;/code&gt; as the unit morphism yields an empty jQuery object.&lt;/li&gt;
&lt;li&gt;Haskellers will recognize this, and the ultimate conclusion that the rest of the post draws as a degenerate version of &lt;code&gt;(fmap a) . (fmap b) == fmap (a . b)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery is just a browser API</title>
   <link href="http://johnbender.github.com/2011/11/25/jquery-is-just-a-browser-api"/>
   <updated>2011-11-25T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2011/11/25/jquery-is-just-a-browser-api</id>
   <content type="html">&lt;p&gt;[Update] Thanks to Charlie in the comments for pointing me to jQuery&amp;#39;s &lt;code&gt;$.fn.proxy&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Developers have traditionally used JavaScript for relatively simple DOM manipulations and XHR, but as more functionality moves to the client, the techniques used by those developers have been slow to evolve. One consequence of this slow evolution is systems comprised entirely of jQuery and a series of nested event bindings. While jQuery is an extremely effective browser API, hiding the clumsy and often bug ridden out of the box equivelants, developers need effective solutions for organizing and reusing their code.&lt;/p&gt;

&lt;h2&gt;Nested Closures&lt;/h2&gt;

&lt;p&gt;Relegating code to event bindings breaks down in even very simple situations for a few important reasons. First the state that&amp;#39;s closed over is often hard to track and bindings can easily be shadowed.&lt;/p&gt;

&lt;pre&gt;
(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;other&lt;/span&gt;() {
    &lt;span class=&quot;comment&quot;&gt;// ...
&lt;/span&gt;  }

  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;header&lt;/span&gt;() {
    &lt;span class=&quot;comment&quot;&gt;//...
&lt;/span&gt;  }

&lt;/span&gt;
  $(&lt;span class=&quot;string&quot;&gt;&quot;.bar&quot;&lt;/span&gt;).click(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;header&lt;/span&gt; = $( &lt;span class=&quot;string&quot;&gt;&quot;header&quot;&lt;/span&gt; );

    &lt;span class=&quot;comment&quot;&gt;// ...
&lt;/span&gt;  });
})( jQuery );&lt;/pre&gt;

&lt;p&gt;Developers altering the &lt;code&gt;click&lt;/code&gt; callback are required to know all the bindings in the current and parent scopes or face the possibility of attempting something unfortunate like using the invocation operator on a jQuery object. Second the inclusion of the state in each callback is implicit which means everything in the enclosing scope is carried with the callback. This is the beauty of the closure when used properly, but here it only adds complexity and possibly memory bloat. Third, and most importantly, the code tied up in the functions and callbacks is entirely unusable outside that context.&lt;/p&gt;

&lt;h2&gt;Objects Not Functions&lt;/h2&gt;

&lt;p&gt;As far as alternatives go, it is possible to write JavaScript in a functional style. Sadly JavaScript lacks many language features that make functional programming easy and elegant. Partial application, pattern matching, tail call optimization, and simple composition are all missing. It&amp;#39;s also a style of programming that is unfamiliar to the vast majority of front end developers. For now objects appear to be the best means of code reuse and organization where JavaScript is concerned.&lt;/p&gt;

&lt;p&gt;With that in mind there are a number of options worth considering. Many JavaScript libraries provide a class system to emulate similar systems in other languages. &lt;a href=&quot;http://mootools.net/&quot; title=&quot;MooTools&quot;&gt;MooTools&lt;/a&gt; is a prime example in that it&amp;#39;s &lt;a href=&quot;http://mootools.net/docs/core/Class/Class&quot; title=&quot;class system&quot;&gt;Class&lt;/a&gt; constructor supports classical inheritance, mixins, and more. This approach has the obvious benefit of being relatively familiar to developers without a lot of JavaScript experience and if you prefer to work with the DOM via jQuery you can even discard the MooTools DOM API with the download builder.&lt;/p&gt;

&lt;p&gt;Additionally a lot of client side software involves state management between JavaScript objects and some DOM representation. Libraries like &lt;a href=&quot;http://documentcloud.github.com/backbone/#Model&quot; title=&quot;Backbone Model&quot;&gt;Backbone&lt;/a&gt; and &lt;a href=&quot;http://docs.sproutcore.com/#doc=SC.Object&amp;src=false&quot; title=&quot;Sproutcore Object&quot;&gt;Sproutcore&lt;/a&gt; provide models in one form or another that can act as a class replacement. As Yehuda Katz pointed out in his &lt;a href=&quot;http://vimeo.com/22687694&quot; title=&quot;Getting Truth from the DOM&quot;&gt;presentation&lt;/a&gt; &amp;quot;Getting Truth Out of the DOM&amp;quot;, attempting to manage complex state between the the DOM and JavaScript is best left to an existing solution. Taken with the need to better organize an application these libraries can be invaluable.&lt;/p&gt;

&lt;p&gt;Finally, you can use the (gasp) prototype system provided by JavaScript. The aversion to JavaScript&amp;#39;s object model appears to be an unfortunate side effect of the overall lack of experience with the language, but by creating a constructor and then defining methods on it&amp;#39;s prototype you can group, organize, and reuse common functionality quite easily&lt;sup&gt;1&lt;/sup&gt;. Even when choosing another solution, neglecting to understand JavaScript at this level is an unfortunate misstep.&lt;/p&gt;

&lt;p&gt;Operating under the assumption that jQuery will remain the primary means of interacting with the DOM for most developers it&amp;#39;s necessary to address binding context (ie &lt;code&gt;this&lt;/code&gt;) as it becomes necessary when using object methods as arguments to higher order functions (eg event handlers).&lt;/p&gt;

&lt;h2&gt;jQuery and Function.prototype.bind&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;One conspicuous absence from jQuery is a helper for function context binding&lt;/del&gt; jQuery&amp;#39;s answer for context binding is the &lt;code&gt;$.proxy&lt;/code&gt; method. That is, it provides a way to guarantee the value of &lt;code&gt;this&lt;/code&gt; during the invocation of a given function. &lt;code&gt;this&lt;/code&gt; becomes important very quickly in even simple attempts to reconcile DOM events with code organization through objects. Here we&amp;#39;ll build a library agnostic version.&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;AlertArea&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$domElement&lt;/span&gt; ){
  &lt;span class=&quot;comment&quot;&gt;// bind to the instances onCloseClick
&lt;/span&gt;  $domElement.find( &lt;span class=&quot;string&quot;&gt;&quot;div.close&quot;&lt;/span&gt; ).click(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.onCloseClick);

  &lt;span class=&quot;comment&quot;&gt;// if the alert area has text on creation show it
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( $domElement.text() ) {
    $domElement.show();
  }

  &lt;span class=&quot;comment&quot;&gt;// track the dom element for
&lt;/span&gt;  &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$domElement = $domElement;
}

AlertArea.prototype.&lt;span class=&quot;function-name&quot;&gt;onCloseClick&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
  &lt;span class=&quot;comment&quot;&gt;// BOOM!!!
&lt;/span&gt;  &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$domElement.hide();
};&lt;/pre&gt;

&lt;p&gt;In this example when the constructor is invoked with some jQuery wrapped DOM object, if that object has text, it&amp;#39;s displayed. It also binds the prototype method &lt;code&gt;onCloseClick&lt;/code&gt; to clicks on child elements matching the &lt;code&gt;div.close&lt;/code&gt; selector. The problem here is that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;onCloseClick&lt;/code&gt; won&amp;#39;t be the &lt;code&gt;AlertArea&lt;/code&gt; object when the click event is triggered but rather the DOM element on which the event was triggered (a feature of jQuery). To guarantee the &lt;code&gt;this&lt;/code&gt; value upon invocation a binding function is required.&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;bindContext&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;newThis&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;fn&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
    fn.apply(newThis, arguments);
  };
}&lt;/pre&gt;

&lt;p&gt;This function takes as arguments a context (&lt;code&gt;newThis&lt;/code&gt;) and a function (&lt;code&gt;fn&lt;/code&gt;). It then creates a new function that, when invoked, will use the &lt;code&gt;apply&lt;/code&gt; method of the original function to invoke it with the new context. More commonly this is defined on the function prototype.&lt;/p&gt;

&lt;p&gt;Function.prototype.&lt;span class=&quot;function-name&quot;&gt;bind&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;newThis&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;self&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
    self.apply(newThis, arguments);
  };
};&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;With that in place the &lt;code&gt;this&lt;/code&gt; value of the &lt;code&gt;onCloseClick&lt;/code&gt; method can be guaranteed by altering the click binding&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;comment&quot;&gt;// bind to the instances onCloseClick
&lt;/span&gt;
$domElement.find( &lt;span class=&quot;string&quot;&gt;&quot;a.close&quot;&lt;/span&gt; ).click(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.onCloseClick.bind(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;));
&lt;/pre&gt;

&lt;p&gt;&lt;del&gt;The fact that jQuery lacks this core function is telling. It isn&amp;#39;t attempting to facilitate your code organization because that&amp;#39;s not what it&amp;#39;s for. I like to think that at least part of jQuery&amp;#39;s success is due to it&amp;#39;s focus on a very specific set of problems, but that leaves the developer to choose their preferred method of code organization. Sadly many developers fail to take that step though it can easily be accomplished with JavaScript&amp;#39;s prototype system&lt;/del&gt;.&lt;/p&gt;

&lt;h2&gt;Getting Comfortable With &lt;code&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A simple library for managing textareas should serve to illustrate how the prototype system is an easy win over nested closures both early on and as application complexity grows. We&amp;#39;ll start with the more common approach:&lt;/p&gt;

&lt;pre&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;textarea&quot;&lt;/span&gt; ).each(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$textArea&lt;/span&gt; = $(elem);

  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;grow&lt;/span&gt;(){
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;scrollHeight&lt;/span&gt; = $textArea[ 0 ].scrollHeight,
        &lt;span class=&quot;variable-name&quot;&gt;clientHeight&lt;/span&gt; = $textArea[ 0 ].clientHeight;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( clientHeight &amp;lt; scrollHeight ) {
      $textArea.height(scrollHeight + 20);
    }
  }

  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;limitWarn&lt;/span&gt;() {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( $textArea.val().length &amp;gt; 10 ) {
      $textArea.css( &lt;span class=&quot;string&quot;&gt;'background-color'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'red'&lt;/span&gt; );
    }
  }

  $textArea.keyup(grow).keyup(limitWarn);
  $(window).load(grow).load(limitWarn);
});
&lt;/pre&gt;

&lt;p&gt;For all textarea elements in the DOM the &lt;code&gt;grow&lt;/code&gt; and &lt;code&gt;limitWarn&lt;/code&gt; functions are bound to &lt;code&gt;keyup&lt;/code&gt; for user input and &lt;code&gt;$(window).load&lt;/code&gt; for text included in the markup. &lt;code&gt;grow&lt;/code&gt; does a simple calculation to determine if the text exceeds the textarea&amp;#39;s rendered height and then increases it where necessary. &lt;code&gt;limitWarn&lt;/code&gt; changes the background color of the textarea when the content length exceeds a given threshold. Already there are three references bleeding into &lt;code&gt;grow&lt;/code&gt; and &lt;code&gt;limitWarn&lt;/code&gt; (ie, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;elem&lt;/code&gt;, and &lt;code&gt;limitWarn&lt;/code&gt;/&lt;code&gt;grow&lt;/code&gt;). Now, the equivalent using the prototype system.&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;TextArea&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$textArea&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;limit&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;grow&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.grow.bind(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;),
      &lt;span class=&quot;variable-name&quot;&gt;limitWarn&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.limitWarn.bind(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;);

  $textArea.keyup(grow).keyup(limitWarn);
  $(window).load(grow).load(limitWarn);

  &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea = $textArea;
  &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.limit = limit;
}

TextArea.prototype.&lt;span class=&quot;function-name&quot;&gt;grow&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;scrollHeight&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea[ 0 ].scrollHeight,
      &lt;span class=&quot;variable-name&quot;&gt;clientHeight&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea[ 0 ].clientHeight;

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( clientHeight &amp;lt; scrollHeight ) {
    &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea.height(scrollHeight + 20);
  }
};

TextArea.prototype.&lt;span class=&quot;function-name&quot;&gt;limitWarn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea.val().length &amp;gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.limit ) {
    &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea.css( &lt;span class=&quot;string&quot;&gt;'background-color'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'red'&lt;/span&gt; );
  }
};

$(&lt;span class=&quot;string&quot;&gt;&quot;textarea&quot;&lt;/span&gt;).each(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt;) {
  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TextArea( $(elem), 10 );
});
&lt;/pre&gt;

&lt;p&gt;The only additional overhead is the function context bindings&lt;sup&gt;2&lt;/sup&gt;, typing &lt;code&gt;TextArea&lt;/code&gt; and &lt;code&gt;prototype&lt;/code&gt;, and the instantiation. The upshot is a purpose built constructor where the &lt;code&gt;each&lt;/code&gt; closure served before and a very specific portal through which state contained in the object is accessed (&lt;code&gt;this&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Now consider another developer working on the same project needs to manage textareas in a different context with a minor alteration. The closure based solution requires something of an overhaul, but the &lt;code&gt;TextArea&lt;/code&gt; prototype can remain nearly untouched while it&amp;#39;s repurposed elsewhere.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;DialogWarnTextArea&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$textArea&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;limit&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;$dialog&lt;/span&gt; ) {
  TextArea.apply(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, arguments);&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$dialog = $dialog;
}&lt;/p&gt;

&lt;p&gt;&lt;/span&gt;DialogWarnTextArea.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TextArea();&lt;/p&gt;

&lt;p&gt;&lt;/span&gt;DialogWarnTextArea.prototype.&lt;span class=&quot;function-name&quot;&gt;limitWarn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea.val().length &amp;gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.limit ) {
    &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$dialog.text(&lt;span class=&quot;string&quot;&gt;&amp;quot;Too much text!&amp;quot;&lt;/span&gt;).show();
  }
};&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;A few things to take note of. First, an application of the original &lt;code&gt;TextArea&lt;/code&gt; constructor to &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;DialogWarnTextArea&lt;/code&gt; constructor makes sure the original attributes are set up properly (ie &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;$textArea&lt;/code&gt;). You can think of this as an explicit &lt;code&gt;super&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;
&lt;/span&gt;TextArea.apply(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, arguments);
&lt;/pre&gt;

&lt;p&gt;Second, assigning the prototype to a new instance of &lt;code&gt;TextArea&lt;/code&gt; places the methods and attributes defined on it&amp;#39;s prototype in the chain above those defined (later) on the &lt;code&gt;DialogWarnTextArea&lt;/code&gt; prototype. This is referred to by most JavaScript developer&amp;#39;s as &amp;quot;prototypal inheritance&amp;quot; for the way it emulates method/attribute lookup in languages with classical inheritance&lt;sup&gt;3&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;
&lt;/span&gt;DialogWarnTextArea.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TextArea();
&lt;/pre&gt;

&lt;p&gt;Third, defining a &lt;code&gt;limitWarn&lt;/code&gt; attribute on the &lt;code&gt;DialogWarnTextArea&lt;/code&gt; prototype means that objects created with the &lt;code&gt;DialogWarnTextArea&lt;/code&gt; will use that definition since it appears earlier in the prototype chain.&lt;/p&gt;

&lt;p&gt;DialogWarnTextArea.prototype.&lt;span class=&quot;function-name&quot;&gt;limitWarn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;() {
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$textArea.val().length &amp;gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.limit ) {
    &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;.$dialog.text(&lt;span class=&quot;string&quot;&gt;&amp;quot;Too much text!&amp;quot;&lt;/span&gt;).show();
  }
};
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Last, we need to handle the case where the &lt;code&gt;TextArea&lt;/code&gt; constructor is invoked with the new operator to set a prototype (ie, without arguments) which constitutes our only alteration to the &lt;code&gt;TextArea&lt;/code&gt; code.&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;TextArea&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$textArea&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;limit&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( !arguments.length ) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
  &lt;span class=&quot;comment&quot;&gt;// ...
&lt;/span&gt;}
&lt;/pre&gt;

&lt;p&gt;It should also be pointed out that there are a few items worth refactoring (3 arg and the &lt;code&gt;limitWarn&lt;/code&gt; boolean operation) but the changes are at least palatable and mostly non-invasive. In stark contrast, achieving the same functionality without the prototype system requires moving the &lt;code&gt;grow&lt;/code&gt; function into a parent scope, gathering the target from the event object passed to &lt;code&gt;grow&lt;/code&gt; as an event handler, and creating another each loop over the second set of textareas.&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;grow&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;event&lt;/span&gt; ){
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$textArea&lt;/span&gt; = $(event.target),
      &lt;span class=&quot;variable-name&quot;&gt;scrollHeight&lt;/span&gt; = $textArea[ 0 ].scrollHeight,
      &lt;span class=&quot;variable-name&quot;&gt;clientHeight&lt;/span&gt; = $textArea[ 0 ].clientHeight;

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( clientHeight &amp;lt; scrollHeight ) {
    $textArea.height(scrollHeight + 20);
  }
}

$( &lt;span class=&quot;string&quot;&gt;&quot;textarea.other&quot;&lt;/span&gt; ).each(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ) {
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$textArea&lt;/span&gt; = $(elem);

  &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;limitWarn&lt;/span&gt;() {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( $textArea.val().length &amp;gt; 10 ) {
      $(&lt;span class=&quot;string&quot;&gt;&quot;#dialog&quot;&lt;/span&gt;).text(&lt;span class=&quot;string&quot;&gt;&quot;Too much text!&quot;&lt;/span&gt;).show();
    }
  }

  $textArea.keyup(grow).keyup(limitWarn);
  $(window).load(grow).load(limitWarn);
});&lt;/pre&gt;

&lt;p&gt;Also unfortunate is that &lt;code&gt;grow&lt;/code&gt; has lost context for the reader, it relies entirely on the fact that the &lt;code&gt;event.target&lt;/code&gt; will behave like a textarea. Ultimately this is really about getting any reusability &lt;strong&gt;at all&lt;/strong&gt; with the added bonuses of sane state access and a limit on the enclosed bindings. Using closures alone to manage scoping concerns simply collapses where reuse is concerned.&lt;/p&gt;

&lt;h2&gt;Slow Progress&lt;/h2&gt;

&lt;p&gt;My fear, and the motivation for this post, is that developers are not turning quickly enough to libraries and language constructs, be they MV* frameworks or plain old prototypes, which are crucial to building more complex client side applications. For nearly any application that must be maintained, even those with a minimum of client side code, developer&amp;#39;s should look to move beyond the simple scoping semantics of the jQuery event callback and leverage the code organization and reuse features that JavaScript and its libraries have to offer.&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;One of the best examples I've found is Google's closure library. Whatever you may think of the library itself, the &lt;a href=&quot;http://code.google.com/p/closure-library/source/browse/trunk/closure/goog/demos/samplecomponent.js&quot; title=&quot;Sample&quot;&gt;code&lt;/a&gt; is really nice to look through.
    &lt;li&gt;Underscore.js provides a nice facility for binding all methods on an object to that object context (&lt;code&gt;_.bindAll&lt;/code&gt;), though it requires explicit inclusion of methods defined on the prototype&lt;/li&gt;
    &lt;li&gt;You can learn more about prototypal inheritance from &lt;a href=&quot;http://javascript.crockford.com/prototypal.html&quot; title=&quot;prototypal inheritance&quot;&gt;Douglas Crockford&lt;/a&gt; and &lt;a href=&quot;http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/&quot; title=&quot;Yehuda Katz - Prototypes&quot;&gt;Yehuda Katz&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>You got your type class in my jQuery: Applicative Functors</title>
   <link href="http://johnbender.github.com/2011/07/20/you-got-your-type-class-in-my-jquery-applicative-functors"/>
   <updated>2011-07-20T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2011/07/20/you-got-your-type-class-in-my-jquery-applicative-functors</id>
   <content type="html">&lt;p&gt;Previously we saw how jQuery's &lt;code&gt;$()&lt;/code&gt; can behave like Haskell's Functor typeclass, when it wraps raw DOM objects and how provides its own version of &lt;code&gt;fmap&lt;/code&gt; (&lt;code&gt;$.map&lt;/code&gt;) for lifting functions into that wrapper to work with those DOM objects. In this post I'll explain Haskell's Applicative typeclass, how it's slightly different from the Functor, and demonstrate how defining functions on &lt;code&gt;$.fn&lt;/code&gt; behaves in a similar fashion to the Applicative function &lt;code&gt;pure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The article assumes you've read the previous post and that you have some basic understanding of what it means to define a function on jQuery's &lt;code&gt;$.fn&lt;/code&gt; object (&lt;a href=&quot;http://docs.jquery.com/Plugins/Authoring&quot; title=&quot;jQuery Plugin Authoring&quot;&gt;docs&lt;/a&gt; for reference).&lt;/p&gt;

&lt;h2&gt;Applicative Functors&lt;/h2&gt;

&lt;p&gt;To start, the Applicative typeclass in Haskell requires that instances also be Functors. Practically speaking this means that any Applicative type actually builds on top of it's Functor by requiring an extra function and an operator, &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. This is important because it tells us that we're still working with contexts, the stuff in them, and getting operations inside to work on the stuff in them.&lt;/p&gt;

   &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Functor&lt;/span&gt; f &lt;span class=&quot;variable-name&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Applicative&lt;/span&gt; f &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; f (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b&lt;/pre&gt;

&lt;p&gt;Continuing with our practice of renaming types for clarity lets alter the definition a bit&lt;/p&gt;

   &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; applicative(a)
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; applicative(a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; applicative(a) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; applicative(b)&lt;/pre&gt;

&lt;p&gt;and being that any Applicative is also a Functor&lt;/p&gt;

&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;pure&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor(a)
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; functor(a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor(a) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor(b)&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pure&lt;/code&gt; is relatively simple. From the type &lt;code&gt;a -&amp;gt; applicative(a)&lt;/code&gt; you can see that its a function that takes some type &lt;code&gt;a&lt;/code&gt;, wraps/lifts it into the Applicative, and hands that Applicative instance back. In the previous article on the Functor we didn't discuss how the data &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; got wrapped inside a Functor in Haskell. We took for granted the fact that the value would be wrapped because it was easy to illustrate in Javascript. This means that instances of a Functor might need to expose some way to do the wrapping or users have to create a function for that purpose outside the requirements of the Functor type class. In the case of Applicatives &lt;code&gt;pure&lt;/code&gt; is a function that does the wrapping&lt;sup&gt;1&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Next, the infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. Its type signature looks a little bit like &lt;code&gt;fmap&lt;/code&gt;s:&lt;/p&gt;

   &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; f (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b&lt;/pre&gt;

&lt;p&gt;The only difference is that the first argument &lt;code&gt;f (a -&amp;gt; b)&lt;/code&gt; is a function wrapped inside the Applicative context, where &lt;code&gt;fmap&lt;/code&gt; takes a raw function and does the wrapping for you. You can probably imagine how &lt;code&gt;pure&lt;/code&gt; is used with &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, it wraps functions and data in the Applicative and then &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; is used to apply those wrapped functions to the wrapped data.&lt;/p&gt;

&lt;h2&gt;Javascript's &lt;code&gt;this&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Before we get started in demonstrating the jQuery analogue to the Applicative Haskell type class, we need to talk about &lt;code&gt;this&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because we're drawing analogies with pure functional programming, where arguments are always defined explicitly, and our jQuery analog will reference it as a replacement for arguments in the type class type signatures, we're going to think of &lt;code&gt;this&lt;/code&gt; as an implicit parameter. This isn't too much of a stretch given that for any function/method invoked via &lt;code&gt;Function.prototype.call&lt;/code&gt; and &lt;code&gt;Function.prototype.apply&lt;/code&gt;, it's actually explicit.&lt;/p&gt;

&lt;p&gt;A simple example&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;foo&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;first&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;second&lt;/span&gt;){
  console.log(first);
  console.log(second);
  console.log(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;);
};

foo.call(&lt;span class=&quot;string&quot;&gt;&quot;wow&quot;&lt;/span&gt;, 1, 2);
&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; 1
// -&amp;gt; 2
// -&amp;gt; [object]
&lt;/span&gt;
foo.apply(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;js2-error&quot;&gt;&quot;wow&quot;, [1, 2]);&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// -&amp;gt; 1
// -&amp;gt; 2
// -&amp;gt; [object]
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;The only issue with thinking this way is that &lt;code&gt;this&lt;/code&gt; is treated as an object and not simply passed through as a parameter would be, though this doesn't affect our discussion. The important part to get for the rest of the article is that, just because it isn't declared as an argument, doesn't mean that &lt;code&gt;this&lt;/code&gt; can't behave like one during invocation.&lt;/p&gt;

&lt;h2&gt;jQuery&lt;/h2&gt;

&lt;p&gt;To define our jQuery analog for the Applicative we have to implement the two functions from the Haskell type class. First &lt;code&gt;pure&lt;/code&gt; and then the operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. Luckily, once we sort out &lt;code&gt;pure&lt;/code&gt;, the extra operator mostly sorts itself out.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;pure&lt;/code&gt; wraps things in the Applicative, functions or data, and we already have a way to wrap the data, HTMLElements, with the jQuery &lt;code&gt;$()&lt;/code&gt; function, all we really need to do is figure out how to get functions into the Applicative so they can operate on wrapped HTMLElement data. Your initial reaction might be to use the same wrapping function for HTMLElements and functions but in jQuery &lt;code&gt;$(function(){})&lt;/code&gt; is a callback for DOM ready so we'll need to find something else. For reference the type signature of the function we're looking for in Haskell would be&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/pre&gt;

&lt;p&gt;or in terms of the Applicative&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; applicative(a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/pre&gt;

&lt;p&gt;The first argument is a function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; and the return type is a function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, presumably the same one, wrapped in the Applicative. Obviously &lt;code&gt;pure&lt;/code&gt; does just that since the type of &lt;code&gt;a&lt;/code&gt; in its type signature &lt;code&gt;pure :: a -&amp;gt; applicative(a)&lt;/code&gt; can be a function &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Lets look at how functions defined on &lt;code&gt;$.fn&lt;/code&gt; behave to see if that might suggest anything:&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;comment&quot;&gt;// definition
&lt;/span&gt;&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;clearIds&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
  $.map(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;e&lt;/span&gt;){
    e.id = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;
  });

  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;;
};

&lt;span class=&quot;comment&quot;&gt;// invocation
&lt;/span&gt;$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).clearIds();
&lt;/pre&gt;

&lt;p&gt;Looking at the &lt;code&gt;clearIds&lt;/code&gt; invocation it certainly appears that its been defined/lifted/wrapped to work with the &lt;code&gt;$()&lt;/code&gt; wrapper/Applicative, but you'll notice that &lt;code&gt;this&lt;/code&gt; inside the function body is a set of &lt;code&gt;$()&lt;/code&gt; wrapped HTMLElements that must be mapped over and &lt;em&gt;not&lt;/em&gt; the HTMLElements themselves. Assuming &lt;code&gt;this&lt;/code&gt; as an implicit first parameter the type of the &lt;code&gt;clearIds&lt;/code&gt; definition when translated back to Haskell would be something like:&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;clearIds&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt;(a) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt;(b)
&lt;/pre&gt;

or in terms of the Applicative

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;clearIds&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;applicative&lt;/span&gt;(a) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;applicative&lt;/span&gt;(b)&lt;/pre&gt;

&lt;p&gt;This should make perfect sense for anyone thats written a jQuery plugin meant to chain with other plugins or jQuery builtins. It takes a &lt;code&gt;$()&lt;/code&gt; wrapped set of elements and returns the same so the next plugin method can operate on them.&lt;/p&gt;

&lt;p&gt;While it does sort of resemble the function wrapped into the Applicative, &lt;code&gt;applicative(a -&amp;gt; b)&lt;/code&gt;, that we're looking, it is different. If you spotted the &lt;code&gt;map&lt;/code&gt; call inside the &lt;code&gt;clearIds&lt;/code&gt; definition you'll have noticed that the function references the &lt;code&gt;id&lt;/code&gt; attribute directly from each HTMLElement. That function&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;e&lt;/span&gt;){
  e.id = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;
}&lt;/pre&gt;

&lt;p&gt;has the type signature that we want to emulate, namely &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt;, or more concretely &lt;code&gt;(HTMLElement -&amp;gt; HTMLElement)&lt;/code&gt;. If we can abstract the &lt;code&gt;map&lt;/code&gt; call and the return of the mutated &lt;code&gt;this&lt;/code&gt; we'll end up with a function that takes a function &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; and results in a function that can work with the Applicative. Lets do that now:&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;pure&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;fromAToB&lt;/span&gt;){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;applicative&lt;/span&gt;){
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $.map(applicative, fromAToB);
  };
};&lt;/pre&gt;

&lt;p&gt;That's more like it. &lt;code&gt;$.pure&lt;/code&gt; takes a simple function &lt;code&gt;fromAtoB&lt;/code&gt;, meant to work with the raw HTMLElements wrapped inside the Applicative &lt;code&gt;$()&lt;/code&gt;. The type signature is a bit off &lt;code&gt;(a -&amp;gt; b) -&amp;gt; (f a -&amp;gt; f b)&lt;/code&gt;, but lets take a look at the corresponding implementation of &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, here referred to as &lt;code&gt;ap&lt;/code&gt; to see if we've captured the spirit of the applicative.&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.fn.&lt;span class=&quot;function-name&quot;&gt;ap&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;applicativeFn&lt;/span&gt;){
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; applicativeFn(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;);
};
&lt;/pre&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ap&lt;/code&gt; will take the result of a call to &lt;code&gt;$.pure&lt;/code&gt;, and uses it to alter the implicit parameter &lt;code&gt;this&lt;/code&gt; which is &lt;code&gt;$()&lt;/code&gt; wrapped HTMLElements. Including the &lt;code&gt;this&lt;/code&gt; parameter the type signature is&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;variable-name&quot;&gt;$.&lt;/span&gt;fn&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;ap &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b&lt;/pre&gt;

which is is pretty close to what we're looking for

&lt;pre&gt;
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; f (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/pre&gt;

when you consider that the descrepancy in the first argument is dictated by how functions defined on &lt;code&gt;$.fn&lt;/code&gt; have to operate.

The end result will look something like this for our &lt;code&gt;clearIds&lt;/code&gt; example above:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;clearIds&lt;/span&gt; = $.pure(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;e&lt;/span&gt;){
  e.id = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;
});

$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).ap(clearIds);&lt;/pre&gt;

&lt;p&gt;Here we've got all the necessary peices to fulfill the type requirements for both &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. &lt;code&gt;$.pure&lt;/code&gt; does the wrapping for functions that operate on the elements of our jQuery Applicative, &lt;code&gt;$()&lt;/code&gt; does the wrapping of the elements themselves (eg &lt;code&gt;$( &quot;div&quot; )&lt;/code&gt;), and the &lt;code&gt;ap&lt;/code&gt; method does the application of the lifted function to the HTMLElements. Thus the &lt;code&gt;ap&lt;/code&gt; method defined on the &lt;code&gt;$.fn&lt;/code&gt; object is our &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; opperator from Haskell so long as the method defined on the jQuery object has been created using &lt;code&gt;$.pure&lt;/code&gt;!&lt;/p&gt;

&lt;h2&gt;A New JQuery Plugin Helper&lt;/h2&gt;

&lt;p&gt;We've fulfilled the requirements of the Applicative type class and derived a useful helper as a consquence, but asking the user to manage the results of the &lt;code&gt;$.pure&lt;/code&gt; is clumsy. A simplification might take the form&lt;/p&gt;

    &lt;pre&gt;
&lt;span class=&quot;js2-external-variable&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;function-name&quot;&gt;pure&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;fnName&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;fromAToB&lt;/span&gt;){
  $.fn[fnName] = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $.map(&lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;, fromAToB);
  };
};
&lt;/pre&gt;

with a definition and invocation for our &lt;code&gt;clearIds&lt;/code&gt; example

    &lt;pre&gt;
$.pure(&lt;span class=&quot;string&quot;&gt;'clearIds'&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;e&lt;/span&gt;){
  e.id = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; e;
});

$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).clearIds();&lt;/pre&gt;

&lt;p&gt;Here, the pattern of mapping a function of &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; into the jQuery context is done as before by &lt;code&gt;$.pure&lt;/code&gt;, but the storage is done on the jQuery &lt;code&gt;$.fn&lt;/code&gt; object not by the user. As a consequence, we can simply invoke a function of &lt;code&gt;fnName&lt;/code&gt; directly on the jQuery object as a substitute for &lt;code&gt;ap&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. It deviates from the type signatures of the Applicative function definitions from Haskell but it captures their spirit while making the pattern much more user friendly.&lt;/p&gt;

&lt;h2&gt;Notes&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Applicatives and Functors can expose their data constructors for the purpose of wrapping data as well. Its up to the author of the data type to determine whether they want to expose that functionality or force the user to use &lt;code&gt;pure&lt;/code&gt;. The difference between exposed and private data constructors becomes important when discussing IO and other monads in Haskell.&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>You got your type class in my jQuery: Functors</title>
   <link href="http://johnbender.github.com/2011/07/08/you-got-your-type-class-in-my-jquery-functors"/>
   <updated>2011-07-08T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2011/07/08/you-got-your-type-class-in-my-jquery-functors</id>
   <content type="html">I have previously described practical applications of common functional programming concepts in earlier posts: &lt;a href=&quot;http://johnbender.us/2010/07/22/middleware-composition-and-monads/&quot; title=&quot;Middleware, Composition, and Monads&quot;&gt;Rack's Middleware&lt;/a&gt; and &lt;a href=&quot; http://johnbender.us/2010/10/18/haskell-and-vagrants-middleware/&quot; title=&quot;Haskell and Vagrant's Middleware&quot;&gt;Vagrant's Middleware&lt;/a&gt;. Next in this series I'll cover how jQuery's design leverages abstractions similar to Haskell's better-known type classes: Functor, Applicative, and Monad. It draws heavily from Brent Yorgey's Typeclassopedia from [&lt;a href=&quot;http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf&quot; title=&quot;The Monad Reader 13&quot;&gt;PDF&lt;/a&gt;] The Monad Reader 13 (which was essential for my own understanding), and supplements it with examples from Javascript and jQuery.

The only pre-requisite is a functioning knowledge of Javascript, &lt;a href=&quot;http://api.jquery.com/jQuery.map/&quot; title=&quot;jQuery.map()&quot;&gt;jQuery.map&lt;/a&gt; and in later posts &lt;a href=&quot;http://docs.jquery.com/Plugins/Authoring&quot; title=&quot;jQuery.fn&quot;&gt;jQuery.fn&lt;/a&gt;.

To start: Functors.

&lt;h2&gt;Functors&lt;/h2&gt;

Haskell's Functor typeclass can be thought of as a way to define context. More specifically, it defines a type to behave as a context or wrapper for data into which operations can be &quot;lifted&quot; to work with the unwrapped/uncontextualized data.

Lets take a close look at the definition, and don't worry, the salient parts will be explained:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Functor&lt;/span&gt; f &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/pre&gt;

We can safely ignore the first line for the purposes of our discussion.

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/pre&gt;

&lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; is a function, but this is not the implementation, only a blueprint for what it should do. This code tells the developer that any actual implementation of &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; requires two arguments and must return a single value.

The first argument &lt;span class=&quot;variable-name&quot;&gt;(a -&gt; b)&lt;/span&gt; is a function that accepts an &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; (something of type &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt;), and returns a &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt; (something of type &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt;). &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; and &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt; could be any types at all (Int, String, Boolean, etc). The fact that each is represented by a different letter means that they could be the same type or a different type.

The second argument, &lt;span class=&quot;variable-name&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt;, is special and forms the basis for our discussion about Functors in jQuery. Remember that &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; could be any type that we want. That's simple enough, but what is the &lt;span class=&quot;variable-name&quot;&gt;f&lt;/span&gt; that precedes the &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; in this case? The fact that it's written as &lt;span class=&quot;variable-name&quot;&gt;f&lt;/span&gt; can at first be a little confusing, because it looks like it might be a function. It's not. Lets change it for clarity.

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor b
&lt;/pre&gt;

That at least makes it clear that the &lt;span class=&quot;variable-name&quot;&gt;f&lt;/span&gt; is meant to describe some relationship between &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; and a &lt;span class=&quot;variable-name&quot;&gt;functor&lt;/span&gt;. Lets take it a bit further:

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor(a) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; functor(b)
&lt;/pre&gt;

This seems to get at the central purpose of the &lt;span class=&quot;variable-name&quot;&gt;functor&lt;/span&gt;: to wrap other data.

Finally, the &lt;span class=&quot;variable-name&quot;&gt;functor(b)&lt;/span&gt; on the far right is the return value of &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt;, which is also data of type &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt; wrapped up in a functor.

Taken all together you can see that the first argument, a function that takes one argument of type &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; and returns something of type &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt;, will most likely be operating on the &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; that's inside the second argument &lt;span class=&quot;variable-name&quot;&gt;functor(a)&lt;/span&gt;. Getting that &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; out of the &lt;span class=&quot;variable-name&quot;&gt;functor(a)&lt;/span&gt; and handing it off to the function &lt;span class=&quot;variable-name&quot;&gt;(a -&gt; b)&lt;/span&gt; is what &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; does.

Here's what the equivalent might look like if we built our own &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt;, a function to interact with the values inside it, and invoked &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; with both.

    &lt;pre&gt;
&lt;span class=&quot;comment&quot;&gt;// a function that works with a and returns b
&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;fromAtoB&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt;){
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt; = a.alter();
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b;
};

&lt;span class=&quot;comment&quot;&gt;// fmap uses fromAtoB to alter the value of a in the functor instance
&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;functorWrappingB&lt;/span&gt; = fmap(fromAtoB, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Functor(a));

&lt;span class=&quot;comment&quot;&gt;// we can see that functorWrappingB is a Functor
&lt;/span&gt;console.log(functorWrappingB &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Functor); &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/pre&gt;

The sample &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt; function takes an &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt;, performs some operation on it, and returns the resulting &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt;, which again could be the same type or different. Again, this is only an example, &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt; and consequently any function we use in it's place could do whatever it wants with the &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; it receives so long as it returns the altered value. With &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt;'s first argument, the function &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt;, in place all that's left is to provide a &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; object from which the &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; will be extracted and handed off to &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt;. Inside &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt;, the return value of &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt; will be put back inside a new &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; object and returned.

Finally, lets looks at what an &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; definition might look like in Javascript so that the way it operates on the &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; will be entirely clear.

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;fromAToB&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;functorWithA&lt;/span&gt;){
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// get the value inside the functor object
&lt;/span&gt;  a = functorWithA.getInternalValue();

  &lt;span class=&quot;comment&quot;&gt;// send that value into our function
&lt;/span&gt;  b = fromAToB(a);

  &lt;span class=&quot;comment&quot;&gt;// put the value back into a functor object and return
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Functor(b);
};&lt;/pre&gt;

As we've explained, it pulls the &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; out of the &lt;span class=&quot;variable-name&quot;&gt;functorWithA&lt;/span&gt;, gives that to &lt;span class=&quot;variable-name&quot;&gt;fromAtoB&lt;/span&gt; and then puts the result &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt; back into a new &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt;. The shape or context is always going to be a &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; regardless of whats inside.

&lt;h2&gt;jQuery&lt;/h2&gt;

Interestingly, one of the jQuery's most important functions , &lt;span class=&quot;variable-name&quot;&gt;jQuery&lt;/span&gt; / &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; itself, is based on a pattern similar to a Functor. Remember that instead of altering native HTMLElement objects to add methods and helpers (like Prototype does), jQuery wraps them and provides access to those objects in a safe, browser agnostic fashion.

    &lt;pre&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; )&lt;/pre&gt;

That's just a bunch of HTMLDivElements wrapped up in the jQuery object. So what if you want to work with the underlying HTMLDivElements? As a developer familiar with jQuery you might do something like:

    &lt;pre&gt;
$( &lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt; ).map( &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;i&lt;/span&gt;, &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ){
  &lt;span class=&quot;comment&quot;&gt;// do something with the HTMLElement
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
});&lt;/pre&gt;

In short we've taken a function and &quot;lifted&quot; it into the jQuery object context to get at the underlying HTMLDivElements. After performing the alteration we can return the element back to &lt;span class=&quot;variable-name&quot;&gt;map&lt;/span&gt; and it will handle putting the element into its jQuery object wrapper, just like &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt;.

If thats not quite clear enough, you can achieve the same result with the following:

    &lt;pre&gt;
$.map($(&lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt;), &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;elem&lt;/span&gt; ) {
  &lt;span class=&quot;comment&quot;&gt;// do something with the element
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; elem;
});&lt;/pre&gt;

Really the only difference between &lt;span class=&quot;variable-name&quot;&gt;$.map&lt;/span&gt; and &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; is that jQuery &quot;Functor&quot; is the first argument to &lt;span class=&quot;variable-name&quot;&gt;$.map&lt;/span&gt; and the function that will operate on the values inside it is the second argument. The argument order is just swapped.

&lt;h2&gt;Sample Usage&lt;/h2&gt;

One of the primary uses for a Functor context/wrapper is control. While jQuery provides direct access to the underlying data (array index notation) in addition to the &lt;span class=&quot;variable-name&quot;&gt;$.fn.map&lt;/span&gt; function, this pattern is easy to leverage when you want to control or manipulate access to data.

For example, if you wanted to prevent manipulation of an element while visible, e.g. a modal dialog, you might define a &lt;span class=&quot;variable-name&quot;&gt;HiddenFunctor&lt;/span&gt;. &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; in this case would only execute the function on the dialog element when &lt;span class=&quot;variable-name&quot;&gt;a.is(&quot;:visible&quot;)&lt;/span&gt; is false.

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;HiddenFunctor&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;a&lt;/span&gt;){
  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&lt;span class=&quot;js2-warning&quot;&gt;a&lt;/span&gt;&lt;/span&gt; = a, &lt;span class=&quot;variable-name&quot;&gt;self&lt;/span&gt; = &lt;span class=&quot;builtin&quot;&gt;this&lt;/span&gt;;

  self.&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;js2-function-param&quot;&gt;fromAtoB&lt;/span&gt;){
    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;b&lt;/span&gt;;

    &lt;span class=&quot;comment&quot;&gt;// if a is visible skip the action
&lt;/span&gt;    b = a.is(&lt;span class=&quot;string&quot;&gt;&quot;:visible&quot;&lt;/span&gt;) ? a : fromAtoB(a);

    &lt;span class=&quot;comment&quot;&gt;// re-wrap
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; self.constructor(b);
  };

  self.&lt;span class=&quot;function-name&quot;&gt;hide&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(){
    a.hide();
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self;
  };
};
&lt;/pre&gt;


The constructor prevents access to the wrapped element &lt;span class=&quot;variable-name&quot;&gt;a&lt;/span&gt; outside the instance of the &lt;span class=&quot;variable-name&quot;&gt;HiddenFunctor&lt;/span&gt; by using a constructor local variable and &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; as a closure. When &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; is invoked it checks if the element is visible and if it is, it &lt;i&gt;does not&lt;/i&gt; invoke the passed/lifted function. You'll also see that &lt;span class=&quot;variable-name&quot;&gt;hide&lt;/span&gt; has been included because a function mapped into the functor to hide the element would not execute in the case where it had already been shown.

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;functor&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HiddenFunctor( $(&lt;span class=&quot;string&quot;&gt;&quot;#dialog&quot;&lt;/span&gt;) ),

    &lt;span class=&quot;function-name&quot;&gt;show&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$dialog&lt;/span&gt; ){
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $dialog.show();
    },

    &lt;span class=&quot;function-name&quot;&gt;destroy&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;( &lt;span class=&quot;js2-function-param&quot;&gt;$dialog&lt;/span&gt; ){
      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; $dialog.remove();
    };

&lt;span class=&quot;comment&quot;&gt;// visible dialog cannot be destroyed
&lt;/span&gt;functor
  .fmap(show)
  .fmap(destroy)
  .hide()
  .fmap(destroy);
&lt;/pre&gt;

Here a new &lt;span class=&quot;variable-name&quot;&gt;HiddenFunctor&lt;/span&gt; object is created with a reference to the &lt;span class=&quot;variable-name&quot;&gt;#dialog&lt;/span&gt;. The first &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; with &lt;span class=&quot;variable-name&quot;&gt;destroy&lt;/span&gt; doesn't alter the dialog because it's in the visible state, but after hiding it the second &lt;span class=&quot;variable-name&quot;&gt;destroy&lt;/span&gt; removes the element from the page.

By using the Functor pattern to control alteration of the wrapped data based on visibility, we've abstracted away from the actions taking place on the underlying object and what the object might actually be while focusing on the task of making sure the user isn't presented with broken content.

&lt;h2&gt;Haskell&lt;/h2&gt;

With any luck the concept of getting your functions into the jQuery object or &lt;span class=&quot;variable-name&quot;&gt;HiddenFunctor&lt;/span&gt; contexts, should look strikingly similar to the more general &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; from Haskell. In jQuery's case, the jQuery object is our context, our &lt;span class=&quot;variable-name&quot;&gt;Functor&lt;/span&gt; like object, and the &lt;span class=&quot;variable-name&quot;&gt;map&lt;/span&gt; function is the &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; we use to get into that context to alter the values inside ( &lt;span class=&quot;variable-name&quot;&gt;HTMLElement&lt;/span&gt;s).

We can now go back and substitute some fictional types in the &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; type signature to show what fmap would look like if we were building jQuery in Haskell. Assuming the substitution of &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; for &lt;span class=&quot;variable-name&quot;&gt;jQuery&lt;/span&gt; we can even plug this back into our &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; type signature:

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt;)&lt;/pre&gt;

Again, that's not a valid type signature, but the important part is that you see, &lt;span class=&quot;variable-name&quot;&gt;jQuery&lt;/span&gt; or &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; is wrapping something, in this case an HTMLElement, and &lt;span class=&quot;variable-name&quot;&gt;fmap&lt;/span&gt; lets you operate on the thing being wrapped in an &lt;i&gt;identical&lt;/i&gt; fashion to &lt;span class=&quot;variable-name&quot;&gt;$.map&lt;/span&gt;.

And the valid version:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;JQFunctor&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;JQuery&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;JQuery&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;JQuery&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;HTMLElement&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Further Reading&lt;/h2&gt;

[update] Its important to note, as some folks have already, that the Functor laws form an important part of their structure preserving properties. For a bit more information on them and why they're important you can view the Learn You a Haskell section on the topic, or for more detail you can check out the &lt;a href=&quot;http://en.wikibooks.org/wiki/Haskell/Category_theory#Functors_on_Hask&quot; title=&quot;Functors on Hask&quot;&gt;wikibook entry&lt;/a&gt; on Functors and Hask objects.

In the next post I'll show how extending jQuery's &lt;span class=&quot;variable-name&quot;&gt;$.fn&lt;/span&gt; object results in a behavior similar to the &lt;span class=&quot;variable-name&quot;&gt;pure&lt;/span&gt; function described in McBride and Paterson's Applicative Programming with Effects. From that we'll derive a simple abstraction to make creating chainable jQuery plugins faster and easier to reason about.

If this post has piqued your interest in Haskell, or you want to learn about how lists in Haskell behave like Functors (interesting given that the result of &lt;span class=&quot;variable-name&quot;&gt;$()&lt;/span&gt; behaves like a list as well) please take the time to look through some of these links.

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass&quot; title=&quot;Learn You a Haskell: Functors&quot;&gt;Learn You a Haskell: Functors&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[&lt;a href=&quot;www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf&quot; title=&quot;Typeclassopedia&quot;&gt;PDF&lt;/a&gt;] Monad Reader 13: Typeclassopedia&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikibooks.org/wiki/Haskell/Applicative_Functors&quot; title=&quot;Haskell Wiki: Applicative Functors&quot;&gt;Haskell Wiki: Applicative Functors&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

Special thanks to both Tim Goh (&lt;a href=&quot;http://twitter.com/#!/keyist&quot; title=&quot;Twitter: keyist&quot;&gt;@keyist&lt;/a&gt;) and Mitchell Hashimoto (&lt;a href=&quot;http://twitter.com/#!/mitchellh&quot; title=&quot;Twitter: mitchellh&quot;&gt;@mitchellh&lt;/a&gt;) for their feedback on the article.
</content>
 </entry>
 
 <entry>
   <title>Snap setup from scratch the Vagrant way</title>
   <link href="http://johnbender.github.com/2011/03/05/snap-setup-from-scratch-the-vagrant-way"/>
   <updated>2011-03-05T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2011/03/05/snap-setup-from-scratch-the-vagrant-way</id>
   <content type="html">A large group of web developers, otherwise ambivalent to Haskell, have recently found reason to learn the language thanks in part to the &lt;a href=&quot;http://snapframework.com/&quot;&gt;Snap&lt;/a&gt; web framework. Its really no surprise given Haskell's brilliance as an all purpose programming language and the effort the Snap team has put into providing &lt;a href=&quot;http://snapframework.com/docs&quot;&gt;great documentation&lt;/a&gt;. For those interested in exploring what it can do, the quickstart guide will get you up and running with snap in a few quick commands:

&lt;pre&gt;
$ cabal update
$ cabal install snap
$ mkdir project
$ cd project
$ snap init
&lt;/pre&gt;

This, of course, will only work if you've already installed the &lt;a href=&quot;http://hackage.haskell.org/platform/&quot;&gt;Haskell Platform&lt;/a&gt;. Depending on your operating system and experience level this can be tedious if not challenging. With that in mind and my preference for using virtual machines when building web servers I've created a few Chef cookbooks for use with &lt;a href=&quot;http://vagrantup.com&quot;&gt;Vagrant&lt;/a&gt; that will hopefully make setting up and using Snap painless.

&lt;h2&gt;Setting up Vagrant&lt;/h2&gt;

If you aren't already familiar with Vagrant, it's a virtual machine management tool for developers. Used in conjunction with Chef or Puppet provisioning tools, you can go from zero to a fully functioning, complex (reads multiple vm/server configuration) web application in one command. Among other things it helps to manage and standardize application dependencies, such as the Haskell Platform, by sequestering them inside a virtual machine where they can't collide on the host. If your skeptical about the time investment involved here, I promise, once you try it you'll never want to go back.

You can find detailed directions on installing Vagrant and its dependencies in the &lt;a href=&quot;http://vagrantup.com/docs/getting-started/index.html&quot;&gt;getting started documentation&lt;/a&gt;. Aside: take note of all the awesome documentation being thrown around here!

&lt;h2&gt;Getting the project skeleton&lt;/h2&gt;

First up you'll need to grab the the skeleton, which contains everything necessary for creating the vm. You can do this by cloning the git repository or by downloading a tar from github:

&lt;pre&gt;
$ git clone git://github.com/johnbender/snap-skeleton.git
&lt;/pre&gt;
or
&lt;pre&gt;
$ wget &lt;a href=&quot;http://github.com/johnbender/snap-skeleton/tarball/master&quot;&gt;http://github.com/johnbender/snap-skeleton/tarball/master&lt;/a&gt;
&lt;/pre&gt;

After cloning/untaring you can rename the project directory, in which case you'll need to replace snap-skeleton in the following commands with whatever you choose.

&lt;pre&gt;
$ cd snap-skeleton
$ vagrant up
&lt;/pre&gt;

Following the the up command you'll have to wait about 10 to 20 minutes depending on your internet connection for the platform to download and compile inside the vm. Once that's complete your snap skeleton directory will now be lifted into the virtual machine as an nfs shared folder so that you can start working on your Snap application. Its here that we can rejoin the Snap getting started guide with two differences. The `cabal update` has been performed for us during the vm creation and when we want to run snap or cabal commands we'll need to get inside the vm with `vagrant ssh` ( its important to note that you do NOT have to edit your haskell source in the vm as its in a shared directory with the host ).

&lt;pre&gt;
$ vagrant ssh
vagrant@vagrantup:~$ cd /vagrant
vagrant@vagrantup:~$ snap init
vagrant@vagrantup:~$ cabal install
vagrant@vagrantup:~$ vagrant -p 8000
Initializing Heist/Impl... done.
Initializing Timer/Timer... done.
Listening on http://0.0.0.0:8000/
&lt;/pre&gt;

You'll also notice that application built from the initial snap source is named after its parent directory, which in the vm is /vagrant, the mount point for the project directory on your host machine. Changes made in this directory from the host side will obviously be available inside the vm and vice versa. You can now view the &quot;it works&quot; page at &lt;a href=&quot;http://33.33.33.10:8000&quot;&gt;http://33.33.33.10:8000&lt;/a&gt;.

&lt;h2&gt;Vagrant workflow&lt;/h2&gt;

Now that you've got a nice new virtual machine and everything necessary to dive into a new Snap application you'll need to know a few simple vagrant commands to save you some time. First and foremost all Vagrant commands must be run from within the project directory where the Vagrantfile resides. With that in mind, you've already seen the `up` command but if you want to get rid of your vm, a quick

&lt;pre&gt;
$ vagrant destroy
&lt;/pre&gt;

will clean up for you. Keep in mind though that this means you'll have to start from scratch again when you want to play around with snap. Next, you can suspend and resume your vms with:

&lt;pre&gt;
$ vagrant suspend
$ vagrant resume
&lt;/pre&gt;

Also of note are the provision and reload commands

&lt;pre&gt;
$ vagrant provision
$ vagrant reload
&lt;/pre&gt;

If you decide you want to alter the cookbooks and recipes provided with the skeleton you can use the provision command to run chef solo for you. Alternately if you want to bounce the vm and run the cookbooks again you can use reload. With those commands in hand, lets make a small alteration to the files created by Snap's init and see how this all fits together. Open up Site.hs in your favorite text editor. It should be at /host/path/to/snap-skeleton/src/Site.hs and find the following snippet at the bottom:

 &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
    message &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;-&lt;/span&gt; decodedParam &lt;span class=&quot;string&quot;&gt;&quot;stuff&quot;&lt;/span&gt;
    heistLocal (bindString &lt;span class=&quot;string&quot;&gt;&quot;message&quot;&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;decodeUtf8 message)) &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; render &lt;span class=&quot;string&quot;&gt;&quot;echo&quot;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;
    decodedParam p &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; fromMaybe &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; getParam p
&lt;/pre&gt;

If you're not yet very familiar with Snap the echo handler takes the `stuff` get parameter and echo's it back to you. Lets change that so it ignores the get parameters:


&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; heistLocal (bindString &lt;span class=&quot;string&quot;&gt;&quot;message&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Vagrant + Snap =&amp;gt; amazing&quot;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; render &lt;span class=&quot;string&quot;&gt;&quot;echo&quot;&lt;/span&gt;
&lt;/pre&gt;

Alright, having edited the echo handler the application needs a recompile. First open up terminal at the snap-skeleton directory root then hop into the vm to compile and start the app:

&lt;pre&gt;
$ vagrant ssh
vagrant@vagrantup:~$ cd /vagrant
vagrant@vagrantup:~$ cabal install
vagrant@vagrantup:~$ vagrant -p 8000
Initializing Heist/Impl... done.
Initializing Timer/Timer... done.
Listening on http://0.0.0.0:8000/
&lt;/pre&gt;

To see the alteration hit &lt;a href=&quot;http://33.33.33.10/echo/foo&quot;&gt;http://33.33.33.10/echo/foo&lt;/a&gt;. Generally you'll want at least one terminal logged into the vm while you're working. When you're done playing around just drop out of the vm and suspend it:

&lt;pre&gt;
vagrant@vagrantup:~$ exit
$ vagrant suspend
&lt;/pre&gt;

The next time you want to start hacking just get to the snap-skeleton directory and fire up the vm with a `resume`.

&lt;h2&gt;Altering Your VM&lt;/h2&gt;

The Vagrantfile thats included in the root of the snap-skeleton ( /path/to/snap-skeleton/Vagrantfile ) provides a couple of important configuration options to take note of and a quick overview of its structure will be useful.

    &lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;Vagrant&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Config&lt;/span&gt;.run &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |config|
  config.vm.box = &lt;span class=&quot;string&quot;&gt;&quot;base&quot;&lt;/span&gt;
  config.vm.network(&lt;span class=&quot;string&quot;&gt;&quot;33.33.33.10&quot;&lt;/span&gt;)
  config.vm.customize &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |vm|
    vm.name = &lt;span class=&quot;string&quot;&gt;&quot;Snap&quot;&lt;/span&gt;
    vm.memory_size = 768
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  config.vm.provision &lt;span class=&quot;constant&quot;&gt;:chef_solo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |chef|
    chef.cookbooks_path = &lt;span class=&quot;string&quot;&gt;&quot;cookbooks&quot;&lt;/span&gt;
    chef.add_recipe &lt;span class=&quot;string&quot;&gt;&quot;project&quot;&lt;/span&gt;
    chef.json.merge!({ &lt;span class=&quot;constant&quot;&gt;:ghc_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'6.12.3'&lt;/span&gt;,
                       &lt;span class=&quot;constant&quot;&gt;:haskell_platform_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'2010.2.0.0'&lt;/span&gt;})
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

First, if you named the base box that you downloaded something other than base ( &quot;lucid32&quot; for example ) you can configure that by changing the value assigned to config.vm.box

&lt;pre&gt;
config.vm.box = &lt;span class=&quot;string&quot;&gt;&quot;base&quot;&lt;/span&gt;
&lt;/pre&gt;

The ip thats defined is for the host network and the customization block allows you to change the attributes of the vm. Of particular note, if you want to change the name to better represent your project you can do that here.

&lt;pre&gt;
config.vm.network(&lt;span class=&quot;string&quot;&gt;&quot;33.33.33.10&quot;&lt;/span&gt;)

config.vm.customize &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |vm|
  vm.name = &lt;span class=&quot;string&quot;&gt;&quot;Snap&quot;&lt;/span&gt;
  vm.memory_size = 768
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

The last and most important configuration is for the provisioning tool, Chef.

&lt;pre&gt;
config.vm.provision &lt;span class=&quot;constant&quot;&gt;:chef_solo&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |chef|
  chef.cookbooks_path = &lt;span class=&quot;string&quot;&gt;&quot;cookbooks&quot;&lt;/span&gt;
  chef.add_recipe &lt;span class=&quot;string&quot;&gt;&quot;project&quot;&lt;/span&gt;
  chef.json.merge!({ &lt;span class=&quot;constant&quot;&gt;:ghc_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'6.12.3'&lt;/span&gt;,
                     &lt;span class=&quot;constant&quot;&gt;:haskell_platform_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'2010.2.0.0'&lt;/span&gt;})
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

The provisioner used here is Chef Solo which can, for more advanced users, be replaced with Chef Server or Puppet (see &lt;a href=&quot;http://vagrantup.com/docs/provisioners.html&quot;&gt;documentation&lt;/a&gt;). The first setting is the directory where the Chef cookbooks, that will be used to install and set up the vm, reside. The second is the name of the project recipe, which you are welcome to change as you get more comfortable with Chef.

&lt;pre&gt;
chef.add_recipe &lt;span class=&quot;string&quot;&gt;&quot;project&quot;&lt;/span&gt;
&lt;/pre&gt;

The default recipe in the projects cookbook handles the inclusion of the rest of the coobooks ( cabal, haskell-platform, and apt). If you change the value here, you must change the directory accordingly in cookbooks:

&lt;pre&gt;
$ ls cookbooks
apt  cabal  haskell-platform  project  README.md
&lt;/pre&gt;

Last but not least is the configuration passed to the Chef recipes. In this case I've defined the necessary versions for the current release of the haskell platform. In the future should these fall out of date they'll be easy to change!

&lt;pre&gt;
chef.json.merge!({ &lt;span class=&quot;constant&quot;&gt;:ghc_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'6.12.3'&lt;/span&gt;,
                   &lt;span class=&quot;constant&quot;&gt;:haskell_platform_version&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'2010.2.0.0'&lt;/span&gt;})
&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Contributing to jQuery Mobile</title>
   <link href="http://johnbender.github.com/2011/02/08/contributing-to-jquery-mobile"/>
   <updated>2011-02-08T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2011/02/08/contributing-to-jquery-mobile</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: I&amp;#39;ve updated the vagrant branch used below to support the newest version of Vagrant.&lt;/p&gt;

&lt;p&gt;This is more substantial version of the lightning talk I gave at LA RubyConf last Saturday. If you&amp;#39;re a &lt;a href=&quot;http://vagrantup.com&quot;&gt;Vagrant&lt;/a&gt; user already, this will be familiar. If not, don&amp;#39;t worry, you&amp;#39;re about to get a quick introduction to its power as a tool for web development. If you have any questions feel free to comment or find me on twitter &lt;a href=&quot;http://twitter.com/johnbender&quot;&gt;@johnbender&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Vagrant&lt;/h2&gt;

&lt;p&gt;jQuery Mobile is set up to use php for serving the docs and tests, both of which you will need in order to start hacking on the library. Instead of installing apache and mod_php on your workstation though, we&amp;#39;re going to build a vm using Vagrant that will serve it up.&lt;/p&gt;

&lt;p&gt;First you&amp;#39;ll need to install VirtualBox and Vagrant which is covered in glorious detail by Mitchell&amp;#39;s &lt;a href=&quot;http://vagrantup.com/docs/getting-started/index.html&quot;&gt;documentation&lt;/a&gt;. If you&amp;#39;re questioning the time investment at this point I can promise you that its worth it. Vagrant will change the way you look at web development.&lt;/p&gt;

&lt;h2&gt;Clone and build&lt;/h2&gt;

&lt;p&gt;The next step is to fork and clone the jQuery Mobile repo&lt;/p&gt;

&lt;pre&gt;
$ git clone git@github.com:yourgithandle/jquery-mobile.git
$ cd jquery-mobile
&lt;/pre&gt;

&lt;p&gt;add my fork as a remote&lt;/p&gt;

&lt;pre&gt;
$ git remote add geewilikers https://github.com/johnbender/jquery-mobile.git
&lt;/pre&gt;

&lt;p&gt;track the branch with the Vagrant configuration&lt;/p&gt;

&lt;pre&gt;
$ git fetch geewilikers
$ git branch --track vagrant geewilikers/vagrant
$ git checkout vagrant
&lt;/pre&gt;

&lt;p&gt;make sure to add a base box from which to build our JQM virtual machine&lt;/p&gt;

&lt;pre&gt;
$ vagrant box add base http://files.vagrantup.com/lucid32.box
&lt;/pre&gt;

&lt;p&gt;and then fire that sucker up!&lt;/p&gt;

&lt;pre&gt;
$ vagrant up
&lt;/pre&gt;

&lt;p&gt;About 2 to 5 minutes later, depending on your connection speed, you should be able to hit the &lt;a href=&quot;http://33.33.33.10/&quot;&gt;docs site&lt;/a&gt; served by your brand new vm. You can also view some &lt;a href=&quot;http://33.33.33.10/tests/unit/core/&quot;&gt;tests&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Making changes&lt;/h2&gt;

&lt;p&gt;So now that the site is running how do you make changes? What do you do with this new branch? What does the workflow look like?&lt;/p&gt;

&lt;p&gt;Its actually quite simple. Vagrant lifts the project directory into the virtual machine as a &amp;quot;shared folder&amp;quot; ( it actually mounts the folder with NFS because VirtualBox&amp;#39;s shared folders have extremely poor performance for complex file structures ). This means you can edit any files you like locally and the changes will be represented immediately in the vm. Just make sure that you checkout master first and use the vagrant branch any time you want to run a vagrant command.&lt;/p&gt;

&lt;p&gt;For example, if you wanted to fix a typo in the docs and had just finished building the vm:&lt;/p&gt;

&lt;pre&gt;
$ git branch
  master
* vagrant
$ git checkout master
... hack hack ...
$ git add .
$ git commit -m &quot;changed the docs to be more awesome&quot;
&lt;/pre&gt;

&lt;p&gt;There&amp;#39;s no need to stay on the vagrant branch, its only necessary when you want to interact with vagrant. For example if you wanted to suspend the vm after finishing some work:&lt;/p&gt;

&lt;pre&gt;
$ git checkout vagrant
$ vagrant suspend
&lt;/pre&gt;

&lt;p&gt;When you want to start working again, just resume the suspended vm:&lt;/p&gt;

&lt;pre&gt;
$ vagrant resume
$ git checkout master
&lt;/pre&gt;

&lt;p&gt;And that pretty much covers the workflow. If you ever want to go rooting around in the vm itself, which in this case I find to be a rare occurrence, you can simply ssh in:&lt;/p&gt;

&lt;pre&gt;
$ vagrant ssh
&lt;/pre&gt;

&lt;p&gt;In the worst case where your vm just doesn&amp;#39;t seem to be working at all, just destroy it and rebuild it from scratch.&lt;/p&gt;

&lt;pre&gt;
$ vagrant destroy
$ vagrant up
&lt;/pre&gt;

&lt;h2&gt;Pull requests&lt;/h2&gt;

&lt;p&gt;Now that its dead easy to make changes to JQM and you&amp;#39;re ready to dive in and help out, where&amp;#39;s the best place to start?&lt;/p&gt;

&lt;p&gt;As of this writing the team is focusing on bug fixes and testing. Feature requests are being moved to a backlog for post beta/1.0 consideration as we focus on platform support and stability. That means if you want to contribute your best bet is to find an unclaimed issue ( ie one that isn&amp;#39;t tagged with a person&amp;#39;s name ), in the &lt;a href=&quot;https://github.com/jquery/jquery-mobile/issues&quot;&gt;issues list&lt;/a&gt; on github and try your hand at a fix.&lt;/p&gt;

&lt;p&gt;Once you&amp;#39;re happy with your solution submit a pull request and ... wait. We&amp;#39;re doing our best to get to all the pull requests but we get a fair amount and you might have to wait a couple days to get a response while we sort through them.&lt;/p&gt;

&lt;p&gt;To speed the process along there are a couple important things you can do:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Rebase!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If/When your pull request branch falls behind master don&amp;#39;t merge - rebase! By rebasing and resolving the conflicts you make the application of your commits to the existing master much easier for the reviewer.&lt;/p&gt;

&lt;p&gt;First thing you&amp;#39;ll want to do is add the original git repo&lt;/p&gt;

&lt;pre&gt;
$ git remote add jqm git://github.com/jquery/jquery-mobile.git
&lt;/pre&gt;

&lt;p&gt;Then you can fetch the latest from the original jqm and rebase your changes on top of it&lt;/p&gt;

&lt;pre&gt;
$ git fetch jqm
$ git branch
* master
  vagrant
$ git rebase jqm/master
... resolve conflicts ...
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. Separate white space/refactor commits&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you want to add in a quick refactor, like renaming a variable, or cleaning up some white space keep it in a seperate commit from the bug fix/feature. That way the reviewer doesn&amp;#39;t have to fight to separate the important changes from the rest.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Test&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This really cannot be over emphasized. If you fix a bug please add a test for it. In this way we can guarantee that there aren&amp;#39;t any regressions in the future as the project makes changes and improvements. Just take a gander at the other tests to see what they should look like and dive right in. Even better, if you want to learn the library, just start writing tests for whats already there, you&amp;#39;ll be making a huge contribution to the stability of the code base.&lt;/p&gt;

&lt;h2&gt;Contributing to other projects&lt;/h2&gt;

&lt;p&gt;The most important part of all, which I didn&amp;#39;t get enough time to talk about at the conference, is that you don&amp;#39;t have to be a rocket scientist or hacker extraordinaire to contribute in a big way to an open source project you&amp;#39;re interested in. How do I know this, you may ask? Because I&amp;#39;m neither one of those things.&lt;/p&gt;

&lt;p&gt;Sadly, I spent a lot of time on the outside looking in, thinking &amp;quot;I&amp;#39;d just be making trouble&amp;quot; or &amp;quot;I doubt I&amp;#39;d have any meaningful impact even if they did accept my submission&amp;quot;. If you tend to think on the same level, stop. Go fix a bug. Go write a test. Don&amp;#39;t let the fear of someone rejecting your submission stop you from trying in the first place.&lt;/p&gt;

&lt;p&gt;Even if it doesn&amp;#39;t get accpeted, take the feedback to heart, get better, and try again. Good projects will have a polite and helpful response for you if they don&amp;#39;t think your fix is quite ready to be merged in. As someone who reviews pull requests I know that the most important asset the project has is its contributors and users. I see it as my most important job to make sure they know we appreciate all their hard work. ( credit to Yehuda Katz&amp;#39;s &lt;a href=&quot;http://www.infoq.com/presentations/Open-Source-Project-Like-Rails&quot;&gt;talk&lt;/a&gt;, and many discussions with Mitchell Hashimoto for those ideals).&lt;/p&gt;

&lt;h2&gt;Dive right in&lt;/h2&gt;

&lt;p&gt;Hopefully if you were on the fence about contributing to JQM or any other oss project this was the nudge you needed to give it a try. Open source is dead if people don&amp;#39;t jump in to contribute and make it better, so I hope to see your pull request in our queue sometime soon!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Haskell and Vagrantâs Middleware</title>
   <link href="http://johnbender.github.com/2010/10/18/haskell-and-vagrants-middleware"/>
   <updated>2010-10-18T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2010/10/18/haskell-and-vagrants-middleware</id>
   <content type="html">As a follow up to my last post on &lt;a href=&quot;http://nickelcode.com/2010/07/22/middleware-composition-and-monads/&quot;&gt;middleware and monads&lt;/a&gt; I'll be going over how the Warden class, as &lt;a href=&quot;http://github.com/mitchellh/vagrant/blob/master/lib/vagrant/action/warden.rb&quot;&gt;implemented inside Vagrant&lt;/a&gt;, uses concepts derived from some of the basic monad combinators to achieve a rescuable middleware stack. As before, this article assumes you have some knowledge of the Haskell language and middleware as defined in the Rack specification/Pep 333. Also, if you've never heard of Vagrant you can check out the &lt;a href=&quot;http://vagrantup.com&quot;&gt;documentation&lt;/a&gt; and some &lt;a href=&quot;http://www.engineyard.com/blog/2010/mitchell-hashimoto-joins-engine-yard-oss-community-grant-program/&quot;&gt;press&lt;/a&gt;.

&lt;h2&gt;Quick Recap&lt;/h2&gt;

For a full treatment of the similarities between function composition and Rack middleware please see the &lt;a href=&quot;http://nickelcode.com/2010/07/22/middleware-composition-and-monads/&quot;&gt;previous article&lt;/a&gt;.

Function composition and the method call chain created when defining a middleware stack are strikingly similar. Each middleware is called from the previous with the environment object as the only argument. Borrowing from previous examples

&lt;pre&gt;
&lt;/span&gt;app = &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Builder&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;

  run lambda { |env| [200, { &lt;span class=&quot;string&quot;&gt;'Content-Type'&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'text/html'&lt;/span&gt; }, &lt;span class=&quot;string&quot;&gt;'Hello World'&lt;/span&gt;] }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

Which, once its made its way down the call &quot;request&quot; chain, takes the psuedo-code-form:

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Proc&lt;/span&gt;#call
&lt;/pre&gt;

So, aside from the exposure to external state, and being informed about the subsequent middleware during the initialization it actually looks very much like function composition in haskell

&lt;pre&gt;
reverse &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)
&lt;/pre&gt;

It boils down to function chaining with a common argument, namely &lt;span class=&quot;variable-name&quot;&gt;env&lt;/span&gt;. However, if a guarantee on error handling is important, PEP 333 doesn't have much to offer. In contrast, taking function composition and making use of a different combinator in place of the &lt;span class=&quot;variable-name&quot;&gt;(.)&lt;/span&gt; composition operator provides an opportunity for error handling abstraction. From the previous article

&lt;pre&gt;
reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)
&lt;/pre&gt;

By lifting the functions into the Either monad and using the monadic composition operator &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;, error condition handling is abstracted outside of the functions operating on the &lt;span class=&quot;variable-name&quot;&gt;env&lt;/span&gt;. The Warden class inside Vagrant was implemented to provide similar functionality by inserting itself into the Vagrant middleware call stack.

&lt;h2&gt;Warden&lt;/h2&gt;

Vagrant, being a command line application unlike Rack, requires different things of its middleware. Particularly when it comes to error handling. For example, when running `vagrant up` it duplicates a base virtual machine. If for some reason there's an issue during this process its best not to leave 500mb+ virtual disk files lying around.

Prior to the introduction of the middleware Warden, each middleware would call its own cleanup method and either return back up the call chain when a problem was encountered or mark the &lt;span class=&quot;variable-name&quot;&gt;env&lt;/span&gt; with an error. This meant that each middleware had to contain its own logic for error checking the environment and for dealing with those errors appropriately.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MiddlewareExample&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;initialize&lt;/span&gt;(app, env)
    &lt;span class=&quot;variable-name&quot;&gt;@next_app&lt;/span&gt; = app
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;call&lt;/span&gt;(env)
    &lt;span class=&quot;variable-name&quot;&gt;@next_app&lt;/span&gt;.call(env)

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;was the environment tagged with an error by
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;middleware farther down the stack?
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; env.error?
      fixit
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;fixit&lt;/span&gt;
    &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;cleanup
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

To improve on this situation the Warden class was introduced to act, in a similar fashion to the &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; operator,  as a middle man inserted by the Builder class. The only requirement (one met before the Warden was created thanks to Mitchell's diligence with well factored code) being that each middleware wishing to perform some cleanup action must implement a separate cleanup method, &lt;span class=&quot;variable-name&quot;&gt;recover&lt;/span&gt;, which the Warden would call when necessary.

  &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MiddlewareExample&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;initialize&lt;/span&gt;(app, env)
    &lt;span class=&quot;variable-name&quot;&gt;@next_app&lt;/span&gt; = app
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;call&lt;/span&gt;(env)
    &lt;span class=&quot;variable-name&quot;&gt;@next_app&lt;/span&gt;.call(env)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;recover&lt;/span&gt;
    &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;cleanup
&lt;/span&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

If the example was a pre-Warden Vagrant middleware, the &lt;span class=&quot;variable-name&quot;&gt;@next_app&lt;/span&gt; instance variable would have been an instance of the next middleware. With Warden its actually an instance of the Warden class. To use the illustration from earlier:

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Proc&lt;/span&gt;#call
&lt;/pre&gt;

Which becomes:

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;Warden&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Warden&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Warden&lt;/span&gt;#call &lt;- &lt;span class=&quot;type&quot;&gt;Proc&lt;/span&gt;#call
&lt;/pre&gt;

Swapping the monadic composition operator &lt;span class=&quot;variable-name&quot;&gt;(&amp;lt;=&amp;lt;)&lt;/span&gt; into the pseudo-code call chain for the Warden instance makes the inspiration a bit clearer.

&lt;pre&gt;
&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;#call &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;#call &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Proc&lt;/span&gt;#call
&lt;/pre&gt;

&lt;h2&gt;Implementation&lt;/h2&gt;

To create the modified middleware stack the Builder class first sends all the middleware classes, lambdas, and procs into the Warden initializer to be finalized (instantiated or wrapped in the case of a lambda/proc):

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;initialize&lt;/span&gt;(actions, env)
  &lt;span class=&quot;variable-name&quot;&gt;@stack&lt;/span&gt; = []
  &lt;span class=&quot;variable-name&quot;&gt;@actions&lt;/span&gt; = actions.map { |m| finalize_action(m, env) }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

Next the Builder class calls the Warden instance just as it would normally call the first middleware and the Warden instance tracks which middleware have been run:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;call&lt;/span&gt;(env)
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;@actions&lt;/span&gt;.empty?

  &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Call the next middleware in the sequence, appending to the stack
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;of &quot;recoverable&quot; middlewares in case something goes wrong!
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Errors&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;VagrantInterrupt&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; env.interrupted?
    &lt;span class=&quot;variable-name&quot;&gt;@stack&lt;/span&gt;.unshift(&lt;span class=&quot;variable-name&quot;&gt;@actions&lt;/span&gt;.shift).first.call(env)
    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Errors&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;VagrantInterrupt&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; env.interrupted?
  &lt;span class=&quot;keyword&quot;&gt;rescue&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Something went horribly wrong. Start the rescue chain then
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;reraise the exception to properly kick us out of limbo here.
&lt;/span&gt;    begin_rescue(env)
    &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

Lets break this down a little so its clear how this method does the middleware management in the midst of the interupt handling code.

&lt;pre&gt;
  &lt;span class=&quot;variable-name&quot;&gt;@stack&lt;/span&gt;.unshift(&lt;span class=&quot;variable-name&quot;&gt;@actions&lt;/span&gt;.shift).first.call(env)
&lt;/pre&gt;

&lt;span class=&quot;variable-name&quot;&gt;@actions&lt;/span&gt;.shift pulls the first middleware off the front of the uncalled array and &lt;span class=&quot;variable-name&quot;&gt;@stack&lt;/span&gt;.unshift pushes it onto the front of the rescuable middleware array. Calling first on the result of unshift, the new mutated list, returns the current action which is subsequently called.

&lt;pre&gt;
  &lt;span class=&quot;keyword&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Errors&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;VagrantInterrupt&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; env.interrupted?
&lt;/pre&gt;

The interrupt checks happen on both sides of the middleware management code to handle interrupts before and after calls to the middleware. Any other exceptions raised during the course of execution by the middleware are obviously caught in the same manner and when they are the &lt;span class=&quot;variable-name&quot;&gt;begin_rescue&lt;/span&gt; method is invoked. Here the Warden will begin walking back up the stack of already executed middleware, starting with the most recent, calling the recover method on those that define it:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;begin_rescue&lt;/span&gt;(env)
  &lt;span class=&quot;variable-name&quot;&gt;@stack&lt;/span&gt;.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |act|
    act.recover(env) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; act.respond_to?(&lt;span class=&quot;constant&quot;&gt;:recover&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

While the Warden has added some complexity to the traditional middleware stack the call method on the Warden instance provides a central place to catch exceptions and and begin the rescue process.

&lt;h2&gt;But where are the Monads?&lt;/h2&gt;

The implementation of the Warden class is distinctly imperative. Still, the basic premise of inserting something, be it a combinator or non-middleware instance, between otherwise normal method/function calls remains intact. Its an important addition of functionality without intruding on the original purpose of each middleware. Better still, and much like the Either monad, the Warden &quot;combinator&quot; has imbued the call stack with the chance to recover from a bad state while defining a simple way for the middleware to participate in that process. In fact this one change in Vagrant resulted in several hundred lines of code removal by refocusing each call method definition back towards its original purpose.

&lt;h2&gt;Learning from Haskell&lt;/h2&gt;

Anyone who follows Haskell can see that its fortunes are rising in &quot;the real world&quot;. Still, you might be forgiven for thinking its goals too lofty and learning curve too steep for taking the time to learn it. For my part the Warden implementation in Vagrant has been a clear example of what can be gained from spending time learning Haskell. The analogs between function composition and middleware were evident when talking with Mitchell about his middleware implementation in Vagrant. Viewed from that perspective it was natural to look for other techniques and abstractions guided by function composition and combinators that might provide interesting benefits where middleware &quot;composition&quot; was concerned.

My goal for the next article will be to build a middleware implementation in Haskell that reflects the same rescue-able behavior. Then I hope to compare its implementation to existing Rack-like software such as Hack and Wai.



</content>
 </entry>
 
 <entry>
   <title>Middleware, Composition, and Monads</title>
   <link href="http://johnbender.github.com/2010/07/22/middleware-composition-and-monads"/>
   <updated>2010-07-22T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2010/07/22/middleware-composition-and-monads</id>
   <content type="html">This article pre-supposes that you have some basic knowledge of Haskell, &lt;a href=&quot;http://rack.rubyforge.org/doc/SPEC.html&quot;&gt;Rack&lt;/a&gt;/&lt;a href=&quot;http://www.python.org/dev/peps/pep-0333/&quot;&gt;PEP 333&lt;/a&gt;, and &lt;a href=&quot;http://wiki.github.com/rack/rack/list-of-middleware&quot;&gt;middleware&lt;/a&gt;.

&lt;h2&gt;Middleware&lt;/h2&gt;

Middleware, as a plugin architecture for creating custom web stacks, is an amazing tool (the fact that it makes web servers interchangeable is equally important but not useful for this discussion). By simplifying and standardizing the interface used by middleware to communicate, web developers have been given an easy way to compose and reuse nicely sized chunks of functionality. Interestingly the pattern itself is general enough that it applies just as well to pluggable architectures outside of the web stack as evidenced by recent &lt;a href=&quot;http://github.com/mitchellh/vagrant/blob/master/lib/vagrant/action/builder.rb&quot;&gt;additions&lt;/a&gt; of similar functionality to &lt;a href=&quot;http://vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt;. In fact if you stand back a bit further, just far enough to look past object oriented underpinnings, it starts to look a lot like function composition which many consider to be the pinacle in abstractions for software reuse.

&lt;h2&gt;composition&lt;/h2&gt;

To illustrate the similarities with function composition lets define a simple Rack app with some middleware borrowed from an introductory &lt;a href=&quot;http://vision-media.ca/resources/ruby/ruby-rack-middleware-tutorial&quot;&gt;tutorial&lt;/a&gt; on Rack middleware.
    &lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;A sample rack app
&lt;/span&gt;app = &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Builder&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;

  run lambda { |env| [200, { &lt;span class=&quot;string&quot;&gt;'Content-Type'&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'text/html'&lt;/span&gt; }, &lt;span class=&quot;string&quot;&gt;'Hello World'&lt;/span&gt;] }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

The middleware used here modify the response in the manner you would expect. As long as they both forward the request environment down the stack they are afforded the opportunity to manipulate the response provided, first, by the endpoint and then by any subsequent middleware. Now something similar, though simpler, in Haskell:

 &lt;pre&gt;

&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Data.Char&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Prelude&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;hiding&lt;/span&gt; (reverse)
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;qualified&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Data.List&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, [(&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)], &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;reverse body))

&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;map toUpper body))

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;(200,[(&quot;Content-Type&quot;,&quot;text/html&quot;)],&quot;!DLROW OLLEH&quot;)
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;&lt;/span&gt;&lt;/pre&gt;

There obviously isn't any environment forwarding performed here, but the response manipulation is virtually the same. Both the Rack middleware and the composed functions form a pipeline of functionality bound by the common expectation of an HTTP response type in the form of a triple. As long as whatever you're building is able to manipulate that triple it can be used at any stage in the pipeline or in any other pipeline with the same expectation. But this basic composition, a wonderful tool though it is for creating reusable and generic software, still leaves some issues unresolved.

&lt;h2&gt;Errors&lt;/h2&gt;

When building your own Rack middleware there are a couple of ways you can go about handling errors or problematic states. First, you can simply return an error response, thereby alerting the outside world to problems immediately. Alternatively you can attach error information to the environment and allow subsequent middlwares to decide what they would like to do and then possibly modify the response when one is returned. Both options leave something to be desired because there are no guarantees or contracts around error handling. To illustrate lets address the first scenario, see how it maps to function composition and then attempt to improve it.

To do this we'll add another bit of middleware into our stack, one that has a condition under which it cannot operate and must report a failure. We'll call it Rack::Head, and it will attempt to trim the response body down to its first character.

   &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Head&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;initialize&lt;/span&gt; app
      &lt;span class=&quot;variable-name&quot;&gt;@app&lt;/span&gt; = app
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;call&lt;/span&gt; env
      status, headers, body = &lt;span class=&quot;variable-name&quot;&gt;@app&lt;/span&gt;.call env

      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; body.empty?
        [500, headers, &lt;span class=&quot;string&quot;&gt;&quot;Head cannot operate on an empty string&quot;&lt;/span&gt;]
      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
        [status, headers, [body.first]]
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

Now, if the endpoint's response body is changed to be an empty string this new middleware will have to report its failure to those above it in the stack.

 &lt;pre&gt;
app = &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Builder&lt;/span&gt;.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Upcase&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Reverse&lt;/span&gt;
  use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Head&lt;/span&gt;

  run lambda { |env| [200, { &lt;span class=&quot;string&quot;&gt;'Content-Type'&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'text/html'&lt;/span&gt; }, &lt;span class=&quot;string&quot;&gt;''&lt;/span&gt;] }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

Unfortunately there is no guarantee the middleware above Rack::Head won't just replace, alter, or in this case reverse the response body making the error response hard to read or non-existent. This, I believe, is an intentionaly flexible design choice leaving what to do with errors in the hands of middleware authors. Looking back to Haskell we get a similarly unfortunate result with pure function composition:

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (s, h, &lt;span class=&quot;string&quot;&gt;&quot;Head cannot operate on an empty string&quot;&lt;/span&gt;)
&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (s, h, [&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;head body])

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;(200,[(&quot;Content-Type&quot;,&quot;text/html&quot;)],&quot;GNIRTS YTPME NA NO ETAREPO TONNAC DAEH&quot;)
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;&lt;/span&gt;&lt;/pre&gt;

Here the application accounts for the fact that head is unable to operate on an empty list, an error message replaces the response body, and is subsequently mangled. The application could let head throw its empty list exception, though thats less than optimal as well. It appears that simple composition has reached the limits of its usefulness in error handling and some other tactic is required.

&lt;h2&gt;Maybe&lt;/h2&gt;

While Rack, in its current form, doesn't have any alternatives to offer when it comes to error handling, Haskell has some interesting tools that might provide some insight. The first, and most oft cited, is the Maybe monad. When used in conjunction with the monad instance of Maybe, functions can continue to use composition, if in a slightly altered form, without much additional overhead for the developer while the pipeline is imbued with the ability to &quot;short circuit&quot; when something untoward occurs&lt;sup&gt;1&lt;/sup&gt;.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Control.Monad&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;reverse body))

&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;map toUpper body))

&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;(s, h, &quot;Head cannot operate on an empty string&quot;)
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (s, h, [&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;head body])

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Nothing
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; &lt;/span&gt;&lt;/pre&gt;


There are 3 changes to the original. First, an import of Control.Monad makes the Maybe Monad instance available. Second, the dot composition operator has been replaced with the monad composition operator (&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;). Third, the type of (&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;) is
&lt;pre&gt;
(&lt;span class=&quot;function-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Monad&lt;/span&gt; m) &lt;span class=&quot;variable-name&quot;&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; m c) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; m c&lt;/pre&gt;

so we are required to wrap our Response with one of the two Maybe value constructors (Maybe is the m in the type signature). If this seems convoluted, just remember that the type of the regular composition operator (&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;) is &lt;pre&gt;
(&lt;span class=&quot;function-name&quot;&gt;.&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (b &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; c) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; c&lt;/pre&gt;

and the only real difference is that we're required to wrap the result in the Maybe monad.

The last is the key to how the head function can prevent the other middleware from altering its error response. The monadic composition operator (&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;) is built on the monadic bind operator, (&lt;span class=&quot;variable-name&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;) which is defined in the Monad instance for Maybe:

 &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;
    return         &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt;
    fail           &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nothing&lt;/span&gt;
    &lt;span class=&quot;type&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;variable-name&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nothing&lt;/span&gt;
    (&lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; x) &lt;span class=&quot;variable-name&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; f x&lt;/pre&gt;

The key is that when Nothing is passed as the first argument to (&lt;span class=&quot;variable-name&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;) the result will &lt;em&gt;always&lt;/em&gt; be Nothing. Consequently we can say the same about (&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;) as the only extra work that it does on top of the bind operator is some type unwrapping. So! by making sure to wrap the return result in the Maybe monad with the Just data constructor, or Nothing data constructor if there is a failure, the plumbing for managing errors (ie &quot;short circuiting&quot; ) is handled in the (&lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt;) operator.

 &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Nothing
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;run2&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Just&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run2 ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Just (200,[(&quot;Content-Type&quot;,&quot;text/html&quot;)],&quot;H&quot;)
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;
&lt;/span&gt;&lt;/pre&gt;

Great! We've established a way to prevent the other middleware from futzing with the error, but lets make one small change so that our pipeline can report something more useful than Nothing while continuing to short circuit.

 &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Control.Monad.Error&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;reverse&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;reverse body))

&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;upcase&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (s, h, (&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;map toUpper body))

&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Response&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;type&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Head cannot operate on an empty string&quot;&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;head&lt;/span&gt; (s, h, body) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (s, h, [&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt;head body])

&lt;span class=&quot;function-name&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Left &quot;Head cannot operate on an empty string&quot;
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;run2&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; reverse &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; upcase &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; head &lt;span class=&quot;variable-name&quot;&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;\&lt;/span&gt;env &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Right&lt;/span&gt; (200, [(&lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;text/html&quot;&lt;/span&gt;)], &lt;span class=&quot;string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt; run2 ()
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Right (200,[(&quot;Content-Type&quot;,&quot;text/html&quot;)],&quot;H&quot;)
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;*Main&amp;gt;&lt;/span&gt;&lt;/pre&gt;

The only thing thats changed here is that Either has replaced Maybe as our Monad of choice. It should come as no surprise that its defined in Control.Monad.Error, and it has two data constructors just like Maybe; Left for signaling failure and Right for signaling success. As a result we can include a message for the operator of the function to give them some helpful debugging information without worrying about another function farther up the line meddling!

&lt;h2&gt;Closing&lt;/h2&gt;

Next time I'd like to take the concepts we've applied here to our Haskell &quot;middleware&quot; and show how abstracting the error handling in a Builder class like Rack's can provide benefits for use in something like Vagrant. Most of all I hope that this might provide some clarity around why function composition, and by extension middleware, is a really nice patterns for creating modular software.

&lt;h2&gt;Notes&lt;/h2&gt;

1. Functions composed in the Maybe monad, as in the example, don't actually short circuit. They have to run through each composition but as you can see from the Maybe Monad instance they don't execute the function itself.

2. Replacing our Response whole sale with a Left String is really only useful for illustration in this case. It would be better to at least use Either Response Response, and provide an errorResponse function that takes a string and sets the status and headers properly.
</content>
 </entry>
 
 <entry>
   <title>bebop: resource routing for Sinatra/Monk</title>
   <link href="http://johnbender.github.com/2010/01/10/bebop-resource-routing-for-sinatramonk"/>
   <updated>2010-01-10T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2010/01/10/bebop-resource-routing-for-sinatramonk</id>
   <content type="html">I've been using &lt;a href=&quot;http://monkrb.com&quot;&gt;Monk&lt;/a&gt; with the &lt;a href=&quot;http://github.com/tizoc/armonk-skeleton&quot;&gt;armonk&lt;/a&gt; skeleton for the last couple of weeks to build a little app that monitors Craig's List searches. Bebop aside, I've found it to be a really refreshing experience, but I knew when I started building the app that the vanilla routing DSL wasn't going to meet my needs (it wasn't built too!). I also knew I would end up missing the path helpers, targeted filters, resource nesting, and printable routing information from Rails. So! after mocking up a simple DSL and consulting some friends I built and tested this little Sinatra routing extension and dubbed it Bebop in honor of Thelonius Monk.

&lt;h2&gt;Examples&lt;/h2&gt;

Once registered Bebop provides the &lt;code&gt;resource&lt;/code&gt; class method on &lt;code&gt;Sinatra::Base&lt;/code&gt; as the starting point for building your routes.

    &lt;pre&gt;
require &lt;span class=&quot;string&quot;&gt;'sinatra'&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;'bebop'&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;
  register &lt;span class=&quot;type&quot;&gt;Bebop&lt;/span&gt;

  resource &lt;span class=&quot;constant&quot;&gt;:foos&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |foos|

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/hello
&lt;/span&gt;    foos.get &lt;span class=&quot;string&quot;&gt;'/hello'&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;string&quot;&gt;'hello world'&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET '/foos/goodbye'
&lt;/span&gt;    foos.get &lt;span class=&quot;string&quot;&gt;'/goodbye'&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;string&quot;&gt;'goodbye'&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Routing Helpers&lt;/h2&gt;

As illustrated, Bebop can be used for nothing more than prefixing the routes generated by the normal dsl methods with a resource name ('/foos' in this case). It also provides route helper methods that build RESTful routes for the actions index, new, create, show, edit, update, and destroy.

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;
  register &lt;span class=&quot;type&quot;&gt;Bebop&lt;/span&gt;

  resource &lt;span class=&quot;constant&quot;&gt;:foos&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |foos|

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Get /foos
&lt;/span&gt;    foos.index {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/:foo_id
&lt;/span&gt;    foos.show {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/new
&lt;/span&gt;    foos.new {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;POST /foos
&lt;/span&gt;    foos.create {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;PUT /foos/:foo_id
&lt;/span&gt;    foos.update {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/:foo_id/edit
&lt;/span&gt;    foos.edit {}

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;DELETE /foos/:foo_id
&lt;/span&gt;    foos.destroy {}
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

And if you want to nest your resources bebop handles prepending the routes correctly:

    &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;
  register &lt;span class=&quot;type&quot;&gt;Bebop&lt;/span&gt;

  resource &lt;span class=&quot;constant&quot;&gt;:foos&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |foos|

    foos.resource &lt;span class=&quot;constant&quot;&gt;:bars&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |bars|

      &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Get /foos/:foos_id/bars
&lt;/span&gt;      foos.index {}

      &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/:foo_id/bars/:bar_id
&lt;/span&gt;      foos.show {}
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/pre&gt;

&lt;h2&gt;Extras&lt;/h2&gt;

Bebop also extends some of the basic Sinatra functionality like before and after filters and provides new functionality in the form of path helper methods. Filters can target specific routes based on identifier, all routes, or nested resource routes. The only stipulation is that the filters must be defined _before_ the filtered route in the body of the resource block.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;
  register &lt;span class=&quot;type&quot;&gt;Bebop&lt;/span&gt;

  resource &lt;span class=&quot;constant&quot;&gt;:foos&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |foos|

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;To run a filter before all routes
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;
&lt;/span&gt;    foos.before &lt;span class=&quot;constant&quot;&gt;:all&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@all&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;'all'&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;To have your filter run before a specific route, the route must be one of the seven helper
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;routes (see example/routes.rb) or specify the :identifier parameter
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;
&lt;/span&gt;    foos.before &lt;span class=&quot;constant&quot;&gt;:new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@new&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;'new'&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    foos.new &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{@all}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{@new}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; 'all new'
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;You can target the vanila methods by providing the :identifier hash option
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/baz
&lt;/span&gt;    foos.get &lt;span class=&quot;string&quot;&gt;'/baz'&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:identifier&lt;/span&gt; =&amp;gt; &lt;span class=&quot;constant&quot;&gt;:new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@new&lt;/span&gt; &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; 'new'
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;You can also specify a before filter for nested routes by using the child resource name
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;
&lt;/span&gt;    foos.before &lt;span class=&quot;constant&quot;&gt;:bars&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@bars&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;'some bars'&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    foos.resource &lt;span class=&quot;constant&quot;&gt;:bars&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |bars|
      bars.get &lt;span class=&quot;string&quot;&gt;'/some_bars'&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;variable-name&quot;&gt;@bars&lt;/span&gt; &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; 'some bars'
&lt;/span&gt;      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    foos.get &lt;span class=&quot;string&quot;&gt;'/bak'&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@bars&lt;/span&gt; &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; nil
&lt;/span&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Finally you can specify many different methods in your filters by passing many identifiers
&lt;/span&gt;    &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;
&lt;/span&gt;    foos.before &lt;span class=&quot;constant&quot;&gt;:bak&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:baz&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;variable-name&quot;&gt;@bak_baz&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;bak 'n' baz&quot;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

    foos.get(&lt;span class=&quot;string&quot;&gt;'/something'&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:identifier&lt;/span&gt; =&amp;gt; &lt;span class=&quot;constant&quot;&gt;:bak&lt;/span&gt;) { &lt;span class=&quot;variable-name&quot;&gt;@bak_baz&lt;/span&gt; }
    foos.get(&lt;span class=&quot;string&quot;&gt;'/anything'&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:identifier&lt;/span&gt; =&amp;gt; &lt;span class=&quot;constant&quot;&gt;:baz&lt;/span&gt;) { &lt;span class=&quot;variable-name&quot;&gt;@bak_baz&lt;/span&gt; }
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

Path helpers follow a simple naming convention that starts with the original parent resource, all the child resources ordered by nesting, and finishing with the action identifier.

  &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;
  register &lt;span class=&quot;type&quot;&gt;Bebop&lt;/span&gt;

  resource &lt;span class=&quot;constant&quot;&gt;:foos&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |foos|

    foos.resource &lt;span class=&quot;constant&quot;&gt;:bars&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |bars|

      &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;GET /foos/:foo_id/bars/:bar_id/edit
&lt;/span&gt;      bars.edit &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;string&quot;&gt;&quot;foo: &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{params[:foo_id]}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt; bar: &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{params[:bar_id]}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

      bars.get &lt;span class=&quot;string&quot;&gt;'/redirect'&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;

        &lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Redirects to /foos/1/bars/2/edit
&lt;/span&gt;        redirect foos_bars_edit_path(1, 2)
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;h2&gt;Code&lt;/h2&gt;

Most of the above examples are borrowed from the examples directory in the gem if you are interested. The repo can be found at &lt;a href=&quot;http://github.com/johnbender/bebop&quot;&gt;github&lt;/a&gt;, and you can install the gem right now as long as gemcutter.org is one of your sources. As suggested by Damian Janowski I'll be adding some template helpers and some other goodies soon.

As always feedback and suggestions are welcome!
</content>
 </entry>
 
 <entry>
   <title>Using a haskell dfa type to match strings</title>
   <link href="http://johnbender.github.com/2009/11/08/using-a-haskell-dfa-type-to-match-strings"/>
   <updated>2009-11-08T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/11/08/using-a-haskell-dfa-type-to-match-strings</id>
   <content type="html">A &lt;a href=&quot;http://mitchellhashimoto.com/&quot;&gt;friend of mine &lt;/a&gt;recently covered deterministic and non-deterministic finite state machines (automata for the cool kids) in one of his classes and passed along a sample problem for me to figure out. Informally, build a dfa that will match a given string against another string in the provided alphabet. An example of this class of problem would be to build one that matches 'aab' in any string for the alphabet [ab] ('aaba' would match, 'aba' would not).

To help with visualizing the answer for this example I've built a graph of the states and edges that make up our dfa (yay graphviz):
&lt;img src=&quot;/../../../assets/images/graph1.jpg&quot; alt=&quot;graph&quot; title=&quot;graph&quot; width=&quot;158&quot; height=&quot;635&quot; class=&quot;aligncenter size-full&quot; style=&quot;border: 0px; display: block; margin-right: auto; margin-left:auto;&quot;/&gt;


At each state the machine follows the edge that matches the next input from a given string. If it ever hits the fourth state, it's found a match. Checking the string &quot;baab&quot; for  &quot;aab&quot; (for which our machine is built), starting at state one it would take the path 1 -b-&gt; 1 -a-&gt; 2 -a-&gt; 3 -b-&gt; 4, and conclude that &quot;aab&quot; was in fact contained within &quot;baab&quot;.

After doing this on paper I thought it might be fun to use haskell and put together a function that took a dfa, a string to match, and produced a boolean result. The first step I took was to define a data type that represented the dfa.

   &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; { identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; , edges &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] }
           &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt; { identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, edges &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] }
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; { action &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;), edge_identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; }&lt;/pre&gt;


This is an informal representation (you can find the formal one &lt;a href=&quot;http://en.wikipedia.org/wiki/Deterministic_finite-state_machine#Formal_definition&quot;&gt;here&lt;/a&gt;) but here, a dfa is a set of States, a State is an identifier and a set of Edges, and an Edge is a function to determine if it is the edge to follow for a given input and its target state. If this looks a bit clunky at first a cleaned up version is further down.

With my types in place I went ahead with building the functions to traverse a DFA for a given input:

&lt;pre&gt;

&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; current_state &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; is_final current_state
&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; current_state dfa (x&lt;span class=&quot;type&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; match next_state dfa xs
                           &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; next_state &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; traverse dfa current_state x


&lt;span class=&quot;function-name&quot;&gt;traverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;traverse&lt;/span&gt; dfa state &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (find_state dfa) &lt;span class=&quot;variable-name&quot;&gt;.&lt;/span&gt; (next_id &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; edges state)

&lt;span class=&quot;function-name&quot;&gt;is_final&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt; x y) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;is_final&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; x y) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;find_state&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;find_state&lt;/span&gt; (st&lt;span class=&quot;type&quot;&gt;:&lt;/span&gt;sts) state_id  &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; identifier st &lt;span class=&quot;variable-name&quot;&gt;==&lt;/span&gt; state_id &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; st
                              &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; otherwise &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; find_state sts state_id

&lt;span class=&quot;function-name&quot;&gt;next_id&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;next_id&lt;/span&gt; (e&lt;span class=&quot;type&quot;&gt;:&lt;/span&gt;es) input &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; (action e) input &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; edge_identifier e
                     &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; otherwise &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; next_id es input
&lt;/pre&gt;

The short explanation is that for each input it checks the current state for where it should go next, having determined the destination state's id it finds that state in the dfa and then proceeds with the rest of the input.

Now, to test a sample graph:

  &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;state1&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; 1 [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a 2, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b 1]
&lt;span class=&quot;function-name&quot;&gt;state2&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; 2 [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a 3, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b 1]
&lt;span class=&quot;function-name&quot;&gt;state3&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; 3 [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a 3, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b 4]
&lt;span class=&quot;function-name&quot;&gt;state4&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt; 4 [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a 4, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b 4]

&lt;span class=&quot;function-name&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; [state1, state2, state3, state4]

&lt;span class=&quot;function-name&quot;&gt;is_a&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;variable-name&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;is_b&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;variable-name&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;) &lt;/pre&gt;

You'll note that state4 refers to itself no matter the input so that the match function can operate exhaustively on the input string.

And it works! But the best part of this whole exercise (for me at least) was yet to be realized because this whole first definition has been done in a very inelegant manner by failing to make use of haskell's lazy nature and recursive data types.

&lt;h2&gt;Improved&lt;/h2&gt;

The first, and easiest, thing to improve is how the Edges reference their destination states. Before, an integer was defined corresponding the identifier of the target state, but in haskell types can be defined recursively:

 &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; { edges &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] }
           &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; { condition &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;), destination &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; }

&lt;/pre&gt;

For reference:

   &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Dfa&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; { identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; , edges &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] }
           &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt; { identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, edges &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] }
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; { action &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;), edge_identifier &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; }&lt;/pre&gt;


Not only is the new definition much cleaner, but its also more intuitive. An edge simply hands off the _actual_ state its pointing at. No need to go find it. As a result the code necessary to operate the state machine is also significantly simplified:

 &lt;pre&gt;

&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;) &lt;span class=&quot;type&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;match&lt;/span&gt; current_state (x&lt;span class=&quot;type&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; match next_state xs
    &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; next_state &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; traverse (edges current_state) x

&lt;span class=&quot;function-name&quot;&gt;traverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;traverse&lt;/span&gt; (e&lt;span class=&quot;type&quot;&gt;:&lt;/span&gt;es) input &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; (condition e) input &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; destination e
                      &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; otherwise &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; traverse es input
&lt;/pre&gt;

Notice the type signature of traverse is very intuitive:

 &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;traverse&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; [&lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt;] &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; &lt;/pre&gt;

Given a list of edges and an input it will give you the resulting state. Not the id, which would then be used to search for its corresponding state. Finally, the actual graph:

  &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;state1&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a state2, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b state1]
&lt;span class=&quot;function-name&quot;&gt;state2&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a state3, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b state1]
&lt;span class=&quot;function-name&quot;&gt;state3&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;State&lt;/span&gt; [ &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_a state3, &lt;span class=&quot;type&quot;&gt;Edge&lt;/span&gt; is_b state4]
&lt;span class=&quot;function-name&quot;&gt;state4&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;FinalState&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;is_a&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;variable-name&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'a'&lt;/span&gt;)

&lt;span class=&quot;function-name&quot;&gt;is_b&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;variable-name&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'b'&lt;/span&gt;)&lt;/pre&gt;

&lt;h2&gt;Simplified&lt;/h2&gt;

By leveraging the recursive reference to another state in the destination field of the Edge type the code shrinks by 3 functions and an enormous amount of complexity. In addition the ability to exhaust the input string or return early on a match with the FinalState constructor allows for a much more readable definition of the match function and the graph itself (no more self referencing weirdness).

I had a lot of fun thinking this through and I would be excited to see some further refinements in the comments from those who know haskell!
</content>
 </entry>
 
 <entry>
   <title>Ruby Cons</title>
   <link href="http://johnbender.github.com/2009/10/28/ruby-cons"/>
   <updated>2009-10-28T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/10/28/ruby-cons</id>
   <content type="html">I think technically this counts as an application of my readings from Algebra of Programming. Satisfied.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;
  include &lt;span class=&quot;type&quot;&gt;Enumerable&lt;/span&gt;
  attr_accessor &lt;span class=&quot;constant&quot;&gt;:child&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:value&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;self.[]&lt;/span&gt;(value, child=&lt;span class=&quot;constant&quot;&gt;:empty&lt;/span&gt;)
    new(value, child)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;initialize&lt;/span&gt;(value, child)
    &lt;span class=&quot;variable-name&quot;&gt;@value&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;@child&lt;/span&gt; = value, child
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function-name&quot;&gt;each&lt;/span&gt;
    x = &lt;span class=&quot;variable-name&quot;&gt;self&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;( x != &lt;span class=&quot;constant&quot;&gt;:empty&lt;/span&gt;)
      &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; x
      x = x.child
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

x = &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;'MWA'&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;'HAHA'&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;'HAHA'&lt;/span&gt;]]]
puts x.inject(&lt;span class=&quot;string&quot;&gt;''&lt;/span&gt;){ |acc, x| acc+=x.value  }
&lt;/pre&gt;

&lt;br /&gt;


As a side note, I hope that someone finds this page looking for a list of negative things about ruby. Maybe if you run the code you'll find something &gt;:]  
</content>
 </entry>
 
 <entry>
   <title>Algebra of Programming: Chapter 1 section 5</title>
   <link href="http://johnbender.github.com/2009/09/26/algebra-of-programming-chapter-1-sections-5"/>
   <updated>2009-09-26T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/09/26/algebra-of-programming-chapter-1-sections-5</id>
   <content type="html">&lt;h2&gt;Inverses are (horrible)&lt;span style=&quot;font-size: 15px;&quot;&gt;&lt;sup&gt;-1&lt;/sup&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

This section gives an introduction to the extremely interesting concept of implementing a function as the inverse of another with zip and unzip as the examples. First, the goal is to build out our zip and unzip functions to satisfy the equation

&lt;pre&gt;
zip &lt;span class=&quot;function-name&quot;&gt;.&lt;/span&gt; unzip &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; id
&lt;/pre&gt;
&lt;br /&gt;

A couple of notes here. Previously everything has been defined in terms of Haskell, but this is simply an equation. Also, if you're coming from a non-functional background, id is a function that gives you back the same thing you pass to it. No matter what.

In this case the equation is meant to point out that, if you give unzip a list of pairs (two element tuples) and give that result, a tuple of two lists, to zip, in the end you'll get back the original list of pairs. So zip compose unzip is equivalent to the id function. You get back just what you gave it.

    &lt;pre&gt;
zip &lt;span class=&quot;function-name&quot;&gt;$&lt;/span&gt; unzip [(1,2), (3,4)] &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; [(1,2), (3,4)]
&lt;/pre&gt;
&lt;br /&gt;

Before we get into why this is immediately useful lets define the two functions as the book does, but with Haskell.

 &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a) &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;foldr'&lt;/span&gt; c h &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;function-name&quot;&gt;foldr'&lt;/span&gt; c h (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, x)) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; h a &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; foldr' c h x
&lt;/pre&gt;
&lt;br /&gt;

Our old friends the Cons list and foldr here. If you're new to these you can check out more information on them &lt;a href=&quot;http://nickelcode.com/2009/09/19/algebra-of-programming-chapter-1-section-3/&quot;&gt;here&lt;/a&gt;.

&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;unzip'&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; (a, b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; b)
&lt;span class=&quot;function-name&quot;&gt;unzip'&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldr' emptys conss
        &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; emptys &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;)
              conss (a, b) (x, y) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, x) , &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (b, y))

&lt;span class=&quot;function-name&quot;&gt;unzip_'&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; (a, b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; b)
&lt;span class=&quot;function-name&quot;&gt;unzip_'&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;)
&lt;span class=&quot;function-name&quot;&gt;unzip_'&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; ((a,b), x)) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, left &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; unzip_' x), &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (b, right &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; unzip_' x))
                           &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; left (x, y) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; x
                                 right (x, y) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; y
&lt;/pre&gt;
&lt;br /&gt;

unzip' and unzip_' represent two possible ways of unzipping a list of pairs. Of interest here is the fact that my own, much less efficient, implementation involves two &quot;folds&quot; over the data structure, and the one implemented in the book only requires one. Apparently, any and all functions defined by a pair of folds can be defined in terms of a single fold (to be demonstrated later in the book).

&lt;pre&gt;

&lt;span class=&quot;function-name&quot;&gt;zip'&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a, &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; b) &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; (a, b)
&lt;span class=&quot;function-name&quot;&gt;zip'&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;zip'&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt;
&lt;span class=&quot;function-name&quot;&gt;zip'&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, x), &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (b, y)) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; ( (a, b) , zip' (x, y) )

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;gt; let x = zip' . unzip'
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;gt; x  $ Cons ((1, 'a'), Cons ((2, 'b'), Empty))
&lt;/span&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Cons ((1,'a'),Cons ((2,'b'),Empty))
&lt;/span&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;gt; let y = zip' . unzip_'
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;gt; y  $ Cons ((1, 'a'), Cons ((2, 'b'), Empty))
&lt;/span&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Cons ((1,'a'),Cons ((2,'b'),Empty))
&lt;/span&gt;
&lt;/pre&gt;&lt;br /&gt;

Finally we have an exhaustive (can handle lists of different lengths) definition of zip' and the results of composing zip' with unzip' and unzip_' using ghci.

&lt;h2&gt;Testing with maths&lt;/h2&gt;

If you know how zip and unzip work its not imperative (though it is fun) to walk yourself through how each of them operates as defined here. What is important is the result we've gotten out of ghci. We've composed our two functions, and as stated above in our original equation we've gotten back the very same thing we put in. Just as though it were the id function.

I had originally wanted to build my own &quot;foldrless&quot; version of unzip_ in the hopes that it would be easier to see the &quot;inversity&quot; in the code itself. Unfortunately its not incredibly clear, and whats worse the implementation isn't extremely efficient. BUT! Its not a total loss, because in order to satisfy myself that my hack was working properly, all I had to do was run the results BACK through zip and see if I got the original Cons list out the other side to satisfy our original assertion.

And that's really the sweet spot here. While its not a formal proof of the functionality, it provides us with a lot of confidence that our functions are working properly. By defining the function as the inverse of another function we get a way to build it and test it. Incredible.



</content>
 </entry>
 
 <entry>
   <title>Algebra of Programming: Chapter 1 Section 3</title>
   <link href="http://johnbender.github.com/2009/09/19/algebra-of-programming-chapter-1-section-3"/>
   <updated>2009-09-19T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/09/19/algebra-of-programming-chapter-1-section-3</id>
   <content type="html">&lt;h2&gt;Lists&lt;/h2&gt;
The third section of chapter one covered some basic functional programming concepts. Namely Cons lists, their mirror Snoc lists, and the functions built to operate on them. Particularly the adaptations of the foldn function from the previous section which operated over Nat.

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a, a) &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a) &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;function-name&quot;&gt;foldl'&lt;/span&gt; c h &lt;span class=&quot;type&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;function-name&quot;&gt;foldl'&lt;/span&gt; c h (&lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt; (x, a)) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; h (foldl' c h x) a

&lt;span class=&quot;function-name&quot;&gt;foldr'&lt;/span&gt; c h &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;function-name&quot;&gt;foldr'&lt;/span&gt; c h (&lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (a, x)) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; h a &lt;span class=&quot;variable-name&quot;&gt;$&lt;/span&gt; foldr' c h x
&lt;/pre&gt;
&lt;br /&gt;

As you can see in the definition of both Cons and Snoc they are identical to the previous sections definition of natural numbers save for an addition bit of information, whatever you are storing in your list. Also, Cons and Snoc are only different in the position of their recursive self reference. It's only the general understanding of the position by those using the type and the functions created for them ( : as an example ) that makes it behave the way it does. If you were, without prior knowledge, to examine the types by themselves it wouldn't be clear that they were operated upon in significantly different ways when adding new elements (other than the difference in the names of the data constructor). As an example we could redefine the haskell infix cons operator to work with Snoc lists just as it would a Cons list (Note: I've been informed that in practice this isn't possible, but the purpose of the example still holds).

  &lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nil&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a, a) &lt;span class=&quot;keyword&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Show&lt;/span&gt;

(&lt;span class=&quot;function-name&quot;&gt;:&lt;/span&gt;) &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a
x &lt;span class=&quot;function-name&quot;&gt;:&lt;/span&gt; y &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt; (y, x)

&lt;span class=&quot;function-name&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; 1 &lt;span class=&quot;type&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;Snoc&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;Nil&lt;/span&gt;, 3), 2)
          &lt;span class=&quot;comment-delimiter&quot;&gt;--  &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Cons(2, Cons(1, Nil)) would be the norm
&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

Also of interest in this chapter is the myriad of operations that can be defined in terms of foldr for Cons lists and foldl for Snoc lists, much as with Nat. From two of the excercises:

    &lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Excercise 1.7
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;convert&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a
&lt;span class=&quot;function-name&quot;&gt;convert&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldl' &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; h
    &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; h x y &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;(y, x)

&lt;span class=&quot;comment-delimiter&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Excercise 1.8
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;catconv&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listl&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a &lt;span class=&quot;variable-name&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Listr&lt;/span&gt; a
&lt;span class=&quot;function-name&quot;&gt;catconv&lt;/span&gt; m n &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldl' n h m
    &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; h x y &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt;(y, x)
&lt;/pre&gt;
&lt;br /&gt;

Or a quick implementation of map' for Cons lists built atop our &lt;em&gt;extremely&lt;/em&gt; reusable foldr'

    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;map'&lt;/span&gt; f &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldr' &lt;span class=&quot;type&quot;&gt;Empty&lt;/span&gt; h
    &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; h x y &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Cons&lt;/span&gt; (f x, y)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;&amp;gt; map' (+2) $ Cons (1, Cons(2, Empty))
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Cons (3,Cons (4,Empty))
&lt;/span&gt;&lt;/pre&gt;
&lt;br /&gt;

&lt;h2&gt;Further Work&lt;/h2&gt;

I'm getting a lot of joy from rehashing these basic data structures and the implications of understanding them at a relatively low level are obvious. Lists make up such a huge portion of the programming that we do and understanding the types of lists that make the most sense for use within code for both comprehension and performance can provide real value. Also, in fooling around with some little coding challenges on the side (examples to be posted soon I hope) in haskell I've noticed my ease with maps and folds becoming greater.

One bit that I have to revisit is the proof from the middle of the section that the ++ operation is associative and that nil is the left and right unit. I was never very good with proofs, I've long since lost the terminology, and I would like to complete the exercise that requires that knowledge.


</content>
 </entry>
 
 <entry>
   <title>Algebra of Programming: Chapter 1 Section 2</title>
   <link href="http://johnbender.github.com/2009/09/12/algebra-of-programming-chapter-1"/>
   <updated>2009-09-12T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/09/12/algebra-of-programming-chapter-1</id>
   <content type="html">[update] you'll notice I corrected the title to represent the section I went through. Not clear how I got the idea this was the whole first chapter.

My wife, bless her heart, heard me talking about Algebra of Programming after it was recommended to my by the fine people in #haskell and she went out and ordered a print on demand copy. You can do the same for yourself &lt;a href=&quot;http://www.amazon.ca/Algebra-Programming-Richard-Bird/dp/013507245X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1252798706&amp;sr=8-1&quot;&gt;here&lt;/a&gt; (Note: the price at amazon.ca is much better than amazon.com).

Since my new job is working with Ruby, my free time can be devoted to other languages/projects and I've fallen under the spell of Haskell. As an example, &lt;a href=&quot;http://github.com/johnbender/unraverl/tree/master&quot;&gt;Unraverl&lt;/a&gt;'s partial application parse transform for Erlang grew out of my time spent learning about Haskell, and how useful partial application can be. And as a natural sort of progression I've gotten interested in how mathematics can play a larger roll in my programming.

&lt;h2&gt;Starting Out&lt;/h2&gt;

I was initially a bit worried that I would be out of my depth with this book but I was also determined to do whatever was necessary to fill in the gaps of understanding. Luckily the first bit hasn't been too difficult, as most of my questions have been around terminology which were quickly answered thanks, once again, to #haskell. As an aside, if you're on the fence about which functional language to learn spend a couple minutes in haskell's irc channel. Huge thanks to heatsink, c_wraith, and others.

&lt;h2&gt;Recursive Data Types &lt;/h2&gt;

The second section of the first chapter is where things started to get exciting and dense. The first example of recursive data types they provide, that make the basis for the rest of the chapter, is natural numbers (all integers &gt;= 0). In haskell it would look something like

&lt;pre&gt;
&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/pre&gt;
&lt;br /&gt;

To further explain how this can represent any natural number consider the following possible definitions of a function that represents the value 3

     &lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;What we would normally do
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; 3

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Another &quot;unrolled&quot; recursive definition using the + function
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (1 &lt;span class=&quot;variable-name&quot;&gt;+&lt;/span&gt; (1 &lt;span class=&quot;variable-name&quot;&gt;+&lt;/span&gt; (1 &lt;span class=&quot;variable-name&quot;&gt;+&lt;/span&gt; 0)))

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Using our data type
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt;)))

&lt;/pre&gt;
&lt;br /&gt;

When I attempted an explanation of this to my wife her question was a frustrating &quot;Why?&quot;. Of course, &quot;because its cool&quot; didn't persuade her. First, it's a definition for a set of numbers which involves no actual numbers, only the structure of our new data type. We've &lt;em&gt;structurally&lt;/em&gt; defined natural numbers. Second, because we have a recursive representation we can define recursive functions for this data type, and more generic functions for other types that are similarly recursive.

The rest of the chapter is devoted to presenting the foldn function that provides a very generic way to perform operations over recursive data types like Nat.

    &lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;In terms of numbers as you would use them normally
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;foldn&lt;/span&gt; c h 0 &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;function-name&quot;&gt;foldn&lt;/span&gt; c h (n &lt;span class=&quot;variable-name&quot;&gt;+&lt;/span&gt; 1) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; h (foldn c h n)

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;In terms of our Nat data type
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;foldn&lt;/span&gt; c h &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; c
&lt;span class=&quot;function-name&quot;&gt;foldn&lt;/span&gt; c h ( &lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; n ) &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt;  h (foldn c h n)&lt;/pre&gt;
&lt;br /&gt;

It should be noted here, as it confused me initially, that by providing (n + 1) or (Successor n) in the head of the function, n represents a value of one less than that which is passed in. So in the case that foldn was called with some c, some h and 6, n has the value 5 (since (5 + 1) is 6).

The fun part about this is that is provides a method by which you can define functions for addition, subtraction and exponentiation (and others) in terms of foldn. From the book:

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Addition
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;plus&lt;/span&gt; m n &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldn m &lt;span class=&quot;type&quot;&gt;Successor&lt;/span&gt; n

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Subtraction
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;mult&lt;/span&gt; m n &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldn 0 (plus m) n

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Exponentiation
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;expn&lt;/span&gt; m n &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; foldn 1 (mult m) n

&lt;span class=&quot;comment-delimiter&quot;&gt;-- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;The more point free (&quot;point-less&quot;?) version, would be without the n's. &lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

If you're a ruby developer you'll recall the Comparable mixin. Each of the methods in Comparable is defined in terms of the method &lt;span class=&quot;function-name&quot;&gt;&lt; =&gt;&lt;/span&gt;, and once you've done that you get skads of additional functionality for free. Similarly here we've defined one function, significantly more generic than &lt;span class=&quot;function-name&quot;&gt;&lt; =&gt;&lt;/span&gt;, that can be used as the basis for many other functions.

&lt;h2&gt;Exercises&lt;/h2&gt;

I've actually completed all the exercises save for the 1.4 and 1.6. For the first, I simply couldn't provide h which requires knowing how to add n times in such a way that it results in the square of a number. As for the second, I haven't taken the time. You can actually download the answers &lt;a href=&quot;http://web2.comlab.ox.ac.uk/oucl/publications/books/algebra/&quot;&gt;here&lt;/a&gt;, which has been wonderful for checking my answers and allowing me to enjoy the satisfaction of my failures and triumphs.

&lt;h2&gt;Elementary&lt;/h2&gt;

Obviously this is only the first chapter and relatively simple (though not for me), but being able to go through it and grasp the concepts explained was extremely gratifying. Even more, seeing how those concepts apply to every day development gave me confidence that I can really get something out of this to apply to my personal projects. I hope to post here on each of the chapters so that I'm forced to verify my understanding of the material. Any corrections are greatly welcomed in the comments!
</content>
 </entry>
 
 <entry>
   <title>RQuery: refactored and simplified</title>
   <link href="http://johnbender.github.com/2009/08/22/rquery-refactored-and-simplified"/>
   <updated>2009-08-22T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/08/22/rquery-refactored-and-simplified</id>
   <content type="html">I've gone back and knocked off a couple of big todos in rquery. Namely, removing the Symbol capability, and using instances of the new OperationCollector in place of the global class variable + mutex required by the Symbol alterations. Also, as a consequence, I was able to remove the Declarations methods ( .is, .is_not )  previously required for use with overloaded operators like ==.

&lt;h2&gt;No More Symbols&lt;/h2&gt;

Previously there were two DSLs coexisting in the library. One opened up the Symbol class and added the  declaration methods.

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where { &lt;span class=&quot;constant&quot;&gt;:age&lt;/span&gt;.is == 12 }
&lt;/pre&gt;&lt;br /&gt;

This, in my opinion, was an interesting hack and fun to implement but required both global storage for the results of the executing statements and the pollution of the Symbol class. The library's better half used a block parameter that represented a collection of the attributes provided by ActiveRecord.

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where { |user| user.age.is == 12 }
&lt;/pre&gt;&lt;br /&gt;

In removing support for the Symbol based syntax, the block based version became much cleaner both externally and internally. Externally there's no longer a need for the .is and .is_not declarations while the from, between, in and contains methods remain the same.

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
  user.age == 12
  user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;George&quot;&lt;/span&gt;
  user.weight.between 160..180
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;br /&gt;

Though, because of Ruby's restriction on overloading the != operator it now looks like:

&lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
  user.age.not = 12
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;br /&gt;

&lt;h2&gt;Simple Internals&lt;/h2&gt;

The internals have been simplified as well. At a glance, there is now a single class that handles the organization of the calls to the adapter for serialization, OperationCollector. In addition every time the where method is called, a new instance of this class is created so there's no need to have the mutex to prevent race conditions. Please take a look at the &lt;a href=&quot;http://github.com/johnbender/rquery/tree/master&quot;&gt;newness&lt;/a&gt; for more details.
</content>
 </entry>
 
 <entry>
   <title>Unraverl: Partial Function Application</title>
   <link href="http://johnbender.github.com/2009/08/14/unraverl-partial-function-application"/>
   <updated>2009-08-14T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/08/14/unraverl-partial-function-application</id>
   <content type="html">Last weekend I hacked partial application into my parse transform for erlang, unraverl. The rules are very simple but the implications are interesting if nothing else.

In other functional languages, haskell as an example, there's nothing inherently wrong with defining a function that requires two arguments but giving it one.

&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;add&lt;/span&gt; x y &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;variable-name&quot;&gt;+&lt;/span&gt; y
&lt;span class=&quot;function-name&quot;&gt;example&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;=&lt;/span&gt; add 1
&lt;span class=&quot;comment-delimiter&quot;&gt;{- &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; \y -&amp;gt; 1 + y -}&lt;/span&gt;&lt;/pre&gt;

The result is a lambda where the supplied argument is applied across the code in the function.

&lt;h2&gt;Unraverl's implementation?&lt;/h2&gt;

Using the initial example in Erlang

&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;add&lt;/span&gt;(x, y) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;x + y.

&lt;span class=&quot;function-name&quot;&gt;example&lt;/span&gt;() -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;add(1).
&lt;/pre&gt;

the parse transform sees that there are no local (only) functions named 'add' with an arity of 1. It then finds the next highest arity definition and changes the call to accommodate

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;%% &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;roughly
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;example&lt;/span&gt;() -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt;(y) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;add(1, y) &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.&lt;/pre&gt;

So while haskell applies whatever arguments are available to the actual function (internally I'm not sure how its implemented), unraverl simply wraps a call to the actual function in a new fun requiring the remaining arguments.

To make use of this feature in your own applications simply add the compiler directive

&lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;-compile&lt;/span&gt;([{parse_transform, unraverl}]). &lt;/pre&gt;

and make sure the &lt;a href=&quot;http://github.com/johnbender/unraverl/tree/master&quot;&gt;library&lt;/a&gt; is in the code path.

As yet, it doesn't have a makefile or unit tests so use at your own peril.


</content>
 </entry>
 
 <entry>
   <title>BootStraps: now with less crapyness</title>
   <link href="http://johnbender.github.com/2009/06/16/bootstraps-now-with-less-crapyness"/>
   <updated>2009-06-16T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/06/16/bootstraps-now-with-less-crapyness</id>
   <content type="html">I've been getting rid of my TODO's in my mini bootstrapping library whilst focusing on my Sinatra app and the config file looks a lot less crappy now. It even looks a tiny bit awesome. Its doesn't do everything (still need to put my app/* directories in here) but it serves my purposes and remains flexible:

    &lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;BootStraps&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Initializer&lt;/span&gt;.configure &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |config|

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Use the vendor directory
&lt;/span&gt;  config.vendored = &lt;span class=&quot;variable-name&quot;&gt;true&lt;/span&gt;
  config.default_env = &lt;span class=&quot;string&quot;&gt;'production'&lt;/span&gt;

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;require each gem
&lt;/span&gt;  config.gem &lt;span class=&quot;string&quot;&gt;'activerecord'&lt;/span&gt;
  config.gem &lt;span class=&quot;string&quot;&gt;'sinatra'&lt;/span&gt;
  config.gem &lt;span class=&quot;string&quot;&gt;'json'&lt;/span&gt;
  config.gem &lt;span class=&quot;string&quot;&gt;'haml'&lt;/span&gt;
  config.gem &lt;span class=&quot;string&quot;&gt;'twitter'&lt;/span&gt;
  config.gem &lt;span class=&quot;string&quot;&gt;'nakajima-rack-flash'&lt;/span&gt;

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;action taken when config.db.connect is called
&lt;/span&gt;  config.db.connect_action &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;type&quot;&gt;ActiveRecord&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;.establish_connection( 
        &lt;span class=&quot;constant&quot;&gt;:adapter&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'sqlite3'&lt;/span&gt;,
        &lt;span class=&quot;constant&quot;&gt;:dbfile&lt;/span&gt; =&amp;gt;  &lt;span class=&quot;type&quot;&gt;File&lt;/span&gt;.join(config.root, &lt;span class=&quot;string&quot;&gt;'db'&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{config.env}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;.sqlite3&quot;&lt;/span&gt; ))

  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Sinatra settings
&lt;/span&gt;  config.framework.set &lt;span class=&quot;constant&quot;&gt;:environment&lt;/span&gt;, config.env
  config.framework.set &lt;span class=&quot;constant&quot;&gt;:views&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;File&lt;/span&gt;.join(&lt;span class=&quot;string&quot;&gt;'app'&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;'views'&lt;/span&gt;)
  config.framework.set &lt;span class=&quot;constant&quot;&gt;:server&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;'mongrel'&lt;/span&gt;
  config.framework.use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Session&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Cookie&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:domain&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'localhost'&lt;/span&gt;
  config.framework.use &lt;span class=&quot;type&quot;&gt;Rack&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Flash&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;:sweep&lt;/span&gt; =&amp;gt; &lt;span class=&quot;variable-name&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;br /&gt;

No more string literal library names (holy cow that was bad), a nice flexible block for defining the db connection code, and little method missing spice to run whatever methods on whatever framework I'm using.

Using the config has been simplified as well:

  &lt;pre&gt;
require &lt;span class=&quot;string&quot;&gt;'config/bootstraps'&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyMod&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyApp&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;

    configure &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;type&quot;&gt;Straps&lt;/span&gt;.db.connect
      &lt;span class=&quot;type&quot;&gt;Straps&lt;/span&gt;.framework.apply_settings!(&lt;span class=&quot;variable-name&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;br /&gt;

Thinking about rolling it into a gem just to save myself time down the road. 

</content>
 </entry>
 
 <entry>
   <title>BootStrapping a Sinatra app</title>
   <link href="http://johnbender.github.com/2009/06/09/bootstrapping-a-sinatra-app"/>
   <updated>2009-06-09T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/06/09/bootstrapping-a-sinatra-app</id>
   <content type="html">In an effort to simplify my Sinatra app startup and configuration process I've built out a very simple bootstrapping library. It's robust enough to cover the needs for a small to mid size app, but simple enough that it's not overkill for use with Sinatra.

&lt;h2&gt;boostraps.rb&lt;/h2&gt;

In my config directory I have two files: bootstraps.rb and environment.rb.

The former contains three classes DataStore, Configuration, and Initializer. When you invoke the class method boot! on Initializer it pulls in the environment.rb, loads up the configured gems and then loads up all the files in whatever library directories have been specified. 

Use within your Sinatra::Base subclass takes the form:

 &lt;pre&gt;
require &lt;span class=&quot;string&quot;&gt;'config/bootstraps'&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyModule&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;App&lt;/span&gt; &amp;lt; &lt;span class=&quot;type&quot;&gt;Sinatra&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Base&lt;/span&gt;

    configure &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;type&quot;&gt;Config&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;BootStraps&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Initializer&lt;/span&gt;.config
      &lt;span class=&quot;type&quot;&gt;Config&lt;/span&gt;.db.connect
      bar = &lt;span class=&quot;type&quot;&gt;Config&lt;/span&gt;.global[&lt;span class=&quot;constant&quot;&gt;:foo&lt;/span&gt;]      
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt; 
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;br /&gt;
&lt;h2&gt;Environment.rb&lt;/h2&gt;

The above is nice and quiet as it should be. Behind the scenes we've told ol' BootStraps a bunch of stuff about what our app looks like:

 &lt;pre&gt;
&lt;span class=&quot;type&quot;&gt;BootStraps&lt;/span&gt;::&lt;span class=&quot;type&quot;&gt;Initializer&lt;/span&gt;.configure &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |config|
  
  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;Configure the db library and settings
&lt;/span&gt;  config.db.lib = &lt;span class=&quot;string&quot;&gt;'ActiveRecord::Base'&lt;/span&gt;
  config.db.init_method = &lt;span class=&quot;constant&quot;&gt;:establish_connection&lt;/span&gt;
  config.db.init_args = {
    &lt;span class=&quot;constant&quot;&gt;:adapter&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;'sqlite3'&lt;/span&gt;,
    &lt;span class=&quot;constant&quot;&gt;:dbfile&lt;/span&gt; =&amp;gt;  &lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{config.root}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;db/&lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;#{config.env}&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;.sqlite3&quot;&lt;/span&gt;}

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;default our environment to production
&lt;/span&gt;  config.default_env = &lt;span class=&quot;string&quot;&gt;'production'&lt;/span&gt;

  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;require a ActiveRecord on boot
&lt;/span&gt;  config.gems[&lt;span class=&quot;string&quot;&gt;'activerecord'&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;'&amp;gt;=2.2'&lt;/span&gt;
  
  &lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;arbitrary setting
&lt;/span&gt;  config.global[&lt;span class=&quot;constant&quot;&gt;:foo&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;'bar'&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;

&lt;br /&gt;
&lt;h2&gt;Other stuff&lt;/h2&gt;

The best part that you don't see here is the ability to add libraries to app/[models,ext]/ or lib/ and have them required for you. Again, the point is to limit the knowledge/effort needed to contribute new code to the app.

&lt;br /&gt;
&lt;h2&gt;kinks&lt;/h2&gt;

It's quirky in some places (you have to specify something for a gem version even if its nil) but its a relatively clean app boostrapping solution. You can check out my current use case in more detail &lt;a href=&quot;http://github.com/johnbender/twitter_ring/tree/5d881f64d6bacaa43899836c32ffd8850a21d121/config&quot;&gt;here&lt;/a&gt; so long as you ignore the rest of the app :D.
</content>
 </entry>
 
 <entry>
   <title>RQuery: now with | and &amp; operators</title>
   <link href="http://johnbender.github.com/2009/04/26/rquery-now-with-and-operators"/>
   <updated>2009-04-26T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/04/26/rquery-now-with-and-operators</id>
   <content type="html">This weekend I wanted to tackle some of rquery's shortcomings so I added the ability to |/&amp; your operations and also the ability to use an object in the block instead of the symbol class for the column names. I agree with the assertion that it's bad to pollute other classes, but I still think the symbol.declaration syntax is pretty clean and there's isn't much likely hood of those methods ever being implemented elsewhere ( says the guy who decided to implement them :P )

&lt;h2&gt;Examples&lt;/h2&gt;

The key bit is the ability to add multiple operations to the same line connected with | or &amp; operators. In this way you can form extremely complex queries, where as before you were limited to whatever you could get out a series of anded logic. The only stipulation is that you you have to wrap the operations with parenthesis if they are on the same line, or ruby will complain about a syntax error.

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;All operations need to be on the same line and in parens
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;either the | operator or the &amp;amp; operator can be used on a singel line
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
  (user.age.is &amp;gt; 20) | (user.age.in 16,18)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

The above example should be easy to follow but there is one important gotcha with including &amp;'s and |'s on the same line. Because the &amp; operator has precedence in a string of operations if you want both | and &amp; on the same line you need to force precedence for the | where it needs to be evaluated before the &amp; in the resulting query.

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;the &amp;amp; takes precedence here and will be grouped with the contains &quot;Alice&quot; which will be
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;or'd with the contains &quot;George&quot;
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; name contains &quot;George&quot; or (name contains &quot;Alice and age from 20 to 30)
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
  (user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;George&quot;&lt;/span&gt;) | (user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;) &amp;amp; (user.age.from 20..30)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

In this case the query writer wanted to get the users who's names contained either George or Alice and then filter with an age range. What it'll actually do is find the users who's name contains Alice and have an age between 20 and 30, and add anyone with a name like George. To fix this you can add more parens :(

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;to correct the above to the more intuitive version add parens to force precedence of the
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;contains operations
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;=&amp;gt; (name contains &quot;George&quot; or name contains &quot;Alice) and age from 20 to 30
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
 ((user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;George&quot;&lt;/span&gt;) | (user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;)) &amp;amp; (user.age.from 20..30)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

Or you can simply move the and'd operation to the next line as the operations are evaluated top down as the ruby block is executed and they are grouped using and.

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;in this sutation it would be cleaner and easier to just move the and'd statement down
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;a line as all seperate lines are and'd and lines have precedence from top to bottom
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;additionaly operations on seperate lines don't need parens
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
 (user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;George&quot;&lt;/span&gt;) | (user.name.contains &lt;span class=&quot;string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;)
 user.age.from 20..30
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

The biggest change here is simply being able to use the | instead of the default for each line (and). And finally, if you checked out RQuery before, you'll have noticed I'm passing in an object that represents the model being queried. The advantage is there's no class polution, and the not so obvious advantage is that it will throw and nice verbose and descriptive exception if you try and use an attribute that doesn't exist for a given model.

&lt;pre&gt;

&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;should you attempt to use and attribute that doesn't exist for a given model
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;rquery will tell you before it's sent to the db
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |user|
  user.ssn.is == &lt;span class=&quot;string&quot;&gt;&quot;123-45-6789&quot;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;RQuery::AttributeNotFoundError: The field 'ssn' doesn't exist for this object
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from /Users/johnbender/Projects/rquery/lib/rquery/attrib...
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from (irb):24
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from /Users/johnbender/Projects/rquery/lib/rquery/active...
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from /Users/johnbender/Projects/rquery/lib/rquery/active...
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from /Users/johnbender/Projects/rquery/lib/rquery/active...
&lt;/span&gt;&lt;span class=&quot;comment-delimiter&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;      from (irb):23
&lt;/span&gt;
&lt;br /&gt;
&lt;/pre&gt;

My specs cover most of the code and functionality for the activerecord extension (still the only piece I've worked on) and you can still use the symbol syntax if you want.

&lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;environment config
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;RQuery&lt;/span&gt;.use_symbols

&lt;span class=&quot;comment-delimiter&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;example of using symbols, you can see more at the RQuery page on my site.
&lt;/span&gt;&lt;span class=&quot;type&quot;&gt;User&lt;/span&gt;.where &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
 (&lt;span class=&quot;constant&quot;&gt;:name&lt;/span&gt;.contains &lt;span class=&quot;string&quot;&gt;&quot;George&quot;&lt;/span&gt;) | (&lt;span class=&quot;constant&quot;&gt;:name&lt;/span&gt;.contains &lt;span class=&quot;string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;)
 &lt;span class=&quot;constant&quot;&gt;:age&lt;/span&gt;.from 20..30
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

You can get the gem from github as johnbender-rquery, and I won't be updating the rubyforge one unless github fails to build my gem again ( /cross_fingers ).
</content>
 </entry>
 
 <entry>
   <title>Searching the abstract form in erlang</title>
   <link href="http://johnbender.github.com/2009/04/22/searching-the-abstract-form-in-erlang"/>
   <updated>2009-04-22T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/04/22/searching-the-abstract-form-in-erlang</id>
   <content type="html">[update: I've added the head matching version of the check funs as per the recommendations in the comments. Thanks Hynek!]

I imagine there's a much better way to do this, but in the process of writing another parse_transform hack I wanted to search for specific things within the abstract form of a module which looks something like this:

 &lt;pre&gt;
[{attribute,1,file,{&lt;span class=&quot;string&quot;&gt;&quot;./test2.erl&quot;&lt;/span&gt;,1}},
 {attribute,1,module,test2},
 {attribute,2,export,[{append,2},{prepend,2}]},
 {attribute,3,compile,[]},
 {attribute,6,after_exec,{[prepend,append],to_a_atom}},
 {function,8,before_prepend_to_a_atom,2,
     [{clause,8,
          [{var,8,&lt;span class=&quot;string&quot;&gt;'S1'&lt;/span&gt;},{var,8,&lt;span class=&quot;string&quot;&gt;'S2'&lt;/span&gt;}],
          [],
          [{op,9,&lt;span class=&quot;string&quot;&gt;'++'&lt;/span&gt;,{var,9,&lt;span class=&quot;string&quot;&gt;'S1'&lt;/span&gt;},{var,9,&lt;span class=&quot;string&quot;&gt;'S2'&lt;/span&gt;}}]}]},
 {function,11,before_append_to_a_atom,2,
     [{clause,11,
          [{var,11,&lt;span class=&quot;string&quot;&gt;'S1'&lt;/span&gt;},{var,11,&lt;span class=&quot;string&quot;&gt;'S2'&lt;/span&gt;}],
          [],
          [{match,12,
               {var,12,&lt;span class=&quot;string&quot;&gt;'Fun'&lt;/span&gt;},
               {&lt;span class=&quot;string&quot;&gt;'fun'&lt;/span&gt;,12,
                   {clauses,
                       [{clause,12,...
&lt;/pre&gt;
&lt;br /&gt;


It's a bunch of recursive lists, tuples, atoms, etc. Which means you should be able to write a simple function to dive through it and find something like an atom or number, but what if you want to match a tuple where the third item is the value &quot;Fred&quot;?

Here's the hack I came up with this evening:

 
    &lt;pre&gt;
&lt;span class=&quot;function-name&quot;&gt;-module&lt;/span&gt;(util).

&lt;span class=&quot;function-name&quot;&gt;-export&lt;/span&gt;([find/2]). 

&lt;span class=&quot;function-name&quot;&gt;-define&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;call_check&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt;({call,&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;,{atom,&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;,&lt;span class=&quot;variable-name&quot;&gt;Name&lt;/span&gt;},&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;}) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;true;
                       (&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;false
                    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;).

&lt;span class=&quot;function-name&quot;&gt;-define&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;function_check&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt;({&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Name&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;}) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;true;
                           (&lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt;) -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;false
                        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;).
&lt;span class=&quot;function-name&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;) -&amp;gt;
    find(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, []). 

&lt;span class=&quot;function-name&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;is_tuple&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;) -&amp;gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; 
        true -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt; ++ [&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;];
        &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt; -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;find(&lt;span class=&quot;keyword&quot;&gt;tuple_to_list&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;), &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;

&lt;span class=&quot;function-name&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;is_list&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;) -&amp;gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; 
        true -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt; ++ &lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;;
        &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt; -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt; ++ [&lt;span class=&quot;variable-name&quot;&gt;Y&lt;/span&gt; || &lt;span class=&quot;variable-name&quot;&gt;X&lt;/span&gt; &amp;lt;- &lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Y&lt;/span&gt; &amp;lt;- find(&lt;span class=&quot;variable-name&quot;&gt;X&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;), &lt;span class=&quot;variable-name&quot;&gt;Y&lt;/span&gt; =/= []]
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;;

&lt;span class=&quot;function-name&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;) -&amp;gt;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;variable-name&quot;&gt;CompareFun&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt;
        true -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt; ++ [&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;];
        &lt;span class=&quot;variable-name&quot;&gt;_&lt;/span&gt; -&amp;gt;&lt;span class=&quot;function-name&quot;&gt; &lt;/span&gt;&lt;span class=&quot;variable-name&quot;&gt;Acc&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;.
&lt;/pre&gt;
&lt;br /&gt;

Its fairly easy to follow how the 3 clauses of find/3 work

&lt;ul&gt;
	&lt;li&gt;First Clause: If Form is a tuple check it with the comparison function. If the comparison function returns true add it to the accumulator and return the accumulator. If not convert it to a list and call find.&lt;/li&gt;
	&lt;li&gt;Second Clause: If Form is a list check it with the comparison function. If the comparison function returns true add it to the accumulator and return the accumulator. If not call find on each of the elements of the list.&lt;/li&gt;
	&lt;li&gt;Third Clause: If Form is anything else it can't contain something so we simply check it with the comparison function, and add it to the accumulator if it matches otherwise return the current value of the accumulator.&lt;/li&gt;
&lt;/ul&gt;

The funs defined at the top as macros are the matching functions. They have to be custom built for whatever you're looking for, and the variables you include within them must be bound in the scope where you use them. 

Aside from that, there are 3 things I think this highlights: anonymous functions are a gateway drug, you only have to deal with a small set of possible data structures in Erlang, and I would love the ability to check for equality with the same syntax used for assignment/matching:

   &lt;pre&gt;
{foo, &lt;span class=&quot;variable-name&quot;&gt;_dontcare&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;_alsodontcare&lt;/span&gt;} == &lt;span class=&quot;variable-name&quot;&gt;Bar&lt;/span&gt;
&lt;/pre&gt;
&lt;br /&gt;

In this case I ended up using the assignment, catching the badmatch error, and returning false unless it worked. This is not ideal (the try should probably match against the badmatch error at the very least), but it does work, its short and easy to read and its useful for searching complex data structures. Using find would look something like:

   &lt;pre&gt;
&lt;span class=&quot;comment-delimiter&quot;&gt;%% &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;finds anything in Form that resembles {call,_,{atom,_,Name},_}
&lt;/span&gt;&lt;span class=&quot;function-name&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, &lt;span class=&quot;variable-name&quot;&gt;Name&lt;/span&gt;) -&amp;gt;
    find(&lt;span class=&quot;variable-name&quot;&gt;Form&lt;/span&gt;, ?&lt;span class=&quot;constant&quot;&gt;call_check&lt;/span&gt;).
&lt;/pre&gt;
&lt;br /&gt;

Name fills its roll in the macro and the fun is used to check all the elements in Form. What you get back is a list of the matches. Not too shabby for 30 something lines of code!

</content>
 </entry>
 
 <entry>
   <title>non-deterministic description</title>
   <link href="http://johnbender.github.com/2009/04/17/non-deterministic-description"/>
   <updated>2009-04-17T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/04/17/non-deterministic-description</id>
   <content type="html">File this under that &quot;meta-tao of hacking&quot; or WARNING: thar be rosy language and fluff hereabouts.

Walking my dog down the street at dusk today the air had a nice warmth to it and I enjoyed the pink and gold hues of the sunset (please stick with this post it does go somewhere). It's warming up here, and instead of racing home with my head down I was free to enjoy the smell of the air and the sites around me. So, I was letting this scene (dusk, pink, leaves, trees) roll around in my head trying to think how I would describe it accurately to my wife so she could somehow feel and see the light as it passed through the new leaves and buds of flowers, the warmth hitting my face, etc, etc.

&lt;h2&gt;Mooshy&lt;/h2&gt;

Its very hard, if not impossible to achieve that type of expressiveness. Thats what makes great writers. Transferring the totally ephemeral/sensory/emotional/mooshy stuff to these semi-deterministic buckets of words and phrases that comprise our language is a real and difficult challenge that people seek to tackle every day. Even as I'm writing this I'm struggling to lay my ideas out in a way that can be understood by someone else reading them. Without even considering the gulf of perception and personal experience that separates any two people this task is almost insurmountable.

In a lot of ways language designers are trying to do the same thing in reverse. They're trying to give us the tools to describe a very deterministic world using words and phrases with more meaning than their underlying implementation. We've continually abstracted farther and farther away from the on die voltage so that a more detailed and expressive version of computational reality can be recorded.

As a result we get a meeting somewhere in the middle:

&lt;pre lang=&quot;text&quot;&gt;
God/Universe =&gt; Words/Phrases =&gt; ---?--- &lt; = Haskell &lt;= Assembly &lt;= 0011101001000100
&lt;/pre&gt;

As a programmer your brain bridges the gap there, further distilling your understanding of language and how to represent the world in written form into code so we can turn that last bit around.

&lt;/pre&gt;&lt;pre lang=&quot;text&quot;&gt;
God/Universe =&gt; Words/Phrases =&gt; :D =&gt; Haskell =&gt; Assembly =&gt; 0011101001000100
&lt;/pre&gt;

&lt;h2&gt;Sweet diagram bro&lt;/h2&gt;

That gap from Words/Phrases to your language of choice is 6 dashes and a question mark wide. Plenty wide enough for anyone who hacks, or takes an interest therein, to feel proud. Thats the world we live in, striving to make our lives easier and our code more expressive.

As time marches on it seems like we've worked our way towards that reality of using languages to tell the computer exactly what to do. Slowly but surely working up from hardware, to assembler, to cobol, C, Java, Ruby/Haskell/Scala/&lt;insert your favorite&gt;. It's gotten to the point now where its even &lt;a href=&quot;http://ikanobori.jp/weblog/2009/04/11/language-performance-on-the-sum-of-a-file/&quot;&gt;efficient&lt;/a&gt; when it gets boiled all the way down! So what are some of the spoken language &quot;idioms&quot; we use every day when programming, and what are some other things that have yet to make their way into our programming?

&lt;h2&gt;merge! valid? Damn you GHCI compile my code!&lt;/h2&gt;

I personally really like the Ruby way of using the language equivalent of tone to convey meaning in code. When you ask a question of an object and expect a boolean you can use a question mark (how novel!) and when I use the bang operator it reminds me of getting frustrated with clamshell packaging and just smashing my way into it with a screwdriver which is most definitely a destructive update.

Even better is Haskell's type inference. Admittedly my knowledge of Haskell is limited to a small set of hacks that I've been toying with, and in almost every case I define a type signature for my functions, but inference is something we do every time we speak or write. My use of &quot;their&quot; or &quot;there&quot; in spoken form is immediately apparent because of the context its been wrapped in. Haskell's compiler(s) is(are) smart enough to force a type based a what can be gathered about the operations over that type within a function. Thats pretty awesome.

&lt;h2&gt;Stuff you should ignore&lt;/h2&gt;

There are other places that inference could be used. Namespaces/modules for instance. For better or worse, allowing the compiler/vm to handle namespace collisions could be achieved my the inferred functionality and object contained within. This of course gives people the free reign to name their modules whatever they like, thereby confusing the poor end user who needs to use two modules with completely different functionality and the same name (I think there's already another project named RQuery).


&lt;/insert&gt;
</content>
 </entry>
 
 <entry>
   <title>Haskell learnings</title>
   <link href="http://johnbender.github.com/2009/04/12/haskell-learnings"/>
   <updated>2009-04-12T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/04/12/haskell-learnings</id>
   <content type="html">This week I caved and decided to learn haskell. I'm about 5 chapters into RWH and its great except for a few topics they gloss over early on (Type classes, $). Luckily my attention was directed &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;here&lt;/a&gt;, and I was quickly able to fill in some gaps. Big thanks to &lt;a href=&quot;http://www.reddit.com/user/f4hy/&quot;&gt;f4hy&lt;/a&gt; from proggit for the link.

Aside from the link there are a couple things that have gotten me really excited. One of which is partial function application.

&lt;h2&gt;Partial Function Application&lt;/h2&gt;

&lt;br /&gt;
&lt;pre lang=&quot;haskell&quot;&gt;
-- file: ch04/Fold.hs
myFoldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a
myFoldl f z xs = foldr step id xs z
    where step x g a = g (f a x)
&lt;/pre&gt;

This is a problem from chapter four of RWH with a lot going on but I'm going to focus specifically on the function application for foldr. If you're new to haskell it looks pretty ambiguous but function application associates to the left and is equivelant to:

&lt;pre lang=&quot;haskell&quot;&gt;(foldr step id xs) z&lt;/pre&gt;

That's still not much help because a common call to foldr has a value of some sort where the function id is in this case (note: id simply returns whatever argument it is passed). For example.

&lt;pre lang=&quot;haskell&quot;&gt;
--zero value of 1
foldr (+) 1 [1,2,3]
--7
&lt;/pre&gt;

So to figure out how this works we can start with the trace of how foldr builds it's thunks up to establish basic understanding:

&lt;pre lang=&quot;haskell&quot;&gt;
--included for reference
foldr step zero (x:xs) = step x (foldr step zero xs)
foldr _    zero []     = zero

--foldr (+) 1 [1,2,3]
--step = (+)
--zero = 1
+ 1 (+ 2 (+ 3 (1)))

&lt;/pre&gt;

That's simple enough, now lets apply this to the chapter 4 problem and see where it gets us.

&lt;pre lang=&quot;haskell&quot;&gt;
--a custom foldl using foldr
myFoldl f z xs = foldr step id xs z
    where step x g a = g (f a x)

--foldr step id [1,2,3]
--step = step
--zero = id
step 1 (step 2 (step 3 (id)))
&lt;/pre&gt;

But how does that damn z fit in here? If evaluating foldr with those three arguments gets me that expression how does that last argument fit in? This is where I got stopped and figured that either this assumption was incorrect or I was missing some fundamental piece of the problem. As it turns out, this is correct but the way in which this statement is evaluated to come up with a result is not obvious, and really amazing.

The explanation I got from #haskell (Gracenotes/Eridius) was simple and important for working with haskell in general. All functions with more than a single argument can be decomposed one argument at a time into anonymous functions with the remaining arguments.

&lt;pre lang=&quot;haskell&quot;&gt;
--given the following definition of step
step x g a = g (f a x)

--we can count on the following assertions
step = \x g a -&gt; g (f a x)

step 1 = \g a -&gt; g(f a 1)

step 1 id = \a -&gt; id (f a 1)

&lt;/pre&gt;

In the case of our step function and the resulting expression of our foldr, you can see we only give it 2 arguments but step calls for 3. That leaves us with the last argument unassigned, and evaluating that resulting expression looks something like:

&lt;pre lang=&quot;haskell&quot;&gt;
step 1 (step 2 (step 3 (id)))

\a3 -&gt; (\a2 -&gt; (\a -&gt; id (f a 3)) (f a2 2)) (f a3 1)
&lt;/pre&gt;

Confusing? Yes its hard to read so walking though it step by step might be useful.

&lt;pre lang=&quot;haskell&quot;&gt;
--right most fold operation
step 3 (id)

--only two arguments to the step function
--step x g a = g (f a x) so...
\x g a = g (f a x)

--we know x and g (3 and id respectively)
\a -&gt; id (f a 3)

--having evaluated the rightmost fold we have
step 1 (step 2 (\a -&gt; id (f a 3)))

--having evaluated the 2 rightmost folds
step 1 (\a2 -&gt; (\a -&gt; id (f a 3)) (f a2 x))

--and finally evaluating the last fold we get
\a3 -&gt; (\a2 -&gt; (\a -&gt; id (f a 3)) (f a2 2)) (f a3 1)
&lt;/pre&gt;

At this point we've at least figured out how the function is able to take only two arguments (partial application!) and we can actually plug that back in to our original myFoldl (adding in the example argument values (+), 1, and [1,2,3]) to see what it will look like

&lt;pre lang=&quot;haskell&quot;&gt;
--for myFoldl (+) 1 [1,2,3]
myFoldl (+) 1 [1,2,3] = (\a3 -&gt; (\a2 -&gt; (\a -&gt; id (+ a 3)) (+ a2 2)) (+ a3 1))  1
    where step x g a = g (f a x)
&lt;/pre&gt;

And if you look waaay over there on the right we have our third argument! So you can follow the course of the evaluation down from there replacing a3 with 1 and then evaluating (+ a3 1) then passing the result to a2 and (+ a2 2) to a.

The laziness of the language allows you to deal with completing your function call at a later date through partial application. This also gives some insight into the type signature syntax of functions

&lt;pre lang=&quot;haskell&quot;&gt;
myFunc :: Int -&gt; Int -&gt; Bool
myFunc x y = x == y
&lt;/pre&gt;

What its really saying is that after evaluation of myFunc with its first argument of type Int another function accepting an argument of type Int will be returned. Should you supply another argument to the resulting function a final result of Bool will be returned. I'm not speaking specifically about the execution of the code but rather the nature of the application of functions to the arguments passed.

&lt;pre lang=&quot;haskell&quot;&gt;
--different ways to write myFunc
\x -&gt; (\y -&gt; x == y)
\x y -&gt; x == y
myFunc 1 = \y -&gt; 1 == y
myFunc 1 2 = False
&lt;/pre&gt;

If you look at that first one there it looks an awful lot like the type signature. This kind of symmetry to the code and how it works is deeply satisfying to me. I am extremely excited to get my mind wrapped around how to use things like &lt;a href=&quot;http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html?repost&quot;&gt;monoids&lt;/a&gt; to make your code more stable.

Hopefully I'll be back with more as haskell continues to flip my lid.






</content>
 </entry>
 
 <entry>
   <title>Unraverl: filters and more for erlang</title>
   <link href="http://johnbender.github.com/2009/03/30/unraverl-filters-and-more-for-erlang"/>
   <updated>2009-03-30T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/03/30/unraverl-filters-and-more-for-erlang</id>
   <content type="html">After checking out a really neat project (still in beta but I think its one of the coolest new webapps out there) that leverages Erlang, I got inspired to get back to my functional education.

&lt;h2&gt;Code as Data&lt;/h2&gt;

One thing that I really love about Ruby is how flexible it is, and in almost all other languages I end up wishing I had this/that facility. So as I was trying to come up with ideas for Erlang projects I thought I would try and hack together some new language features for Erlang in the form of a parse_transform.

I only recently happened upon the awesomeness that is the Erlang parse_transform and what it means for programming in Erlang. It basically allows you to manipulate the parsed, or abstract form, of your code before it heads to the compiler. Lispers know what this looks like: code as data... awesome.

As an example:

&lt;script src=&quot;http://gist.github.com/88022.js&quot;&gt;&lt;/script&gt;

Tough to look at and evaluate for functionality, but surprisingly it didn't hinder my efforts to hack together filter functionality in the form of a new attribute -before_exec.

&lt;h2&gt;Unraverl&lt;/h2&gt;

In the following module code there are two functions, append and prepend that do exactly that. They are using the list operator ++ so it would be nice to make sure that anything that gets in there is in fact a list. One way to do it would be to call the all_lists function on both arguments before operating on those arguments like so:

&lt;script src=&quot;http://gist.github.com/88031.js&quot;&gt;&lt;/script&gt;

all_lists converts any object into a list using the to_list function and then puts them together. It works, and in this simple example its really not much of a hassle if we decide to change the name of all_lists to make_lists or some such. If instead we had 50 functions we were exposing as list operation api, and, to make them user friendly we wanted to convert everything to a list (for better or worse), it might then be something of a hassle.

&lt;h2&gt;Filter to the Rescue&lt;/h2&gt;

So with a little parse transform magic, we can do the following:

&lt;script src=&quot;http://gist.github.com/88032.js&quot;&gt;&lt;/script&gt;

Three things to look at. The first is the -compile directive to call the parse_transform function that I hacked together in unraverl.erl. The second is the attribute -before_exec that basically says, before [prepend, append] execute all_lists. Last, prepend and append are much simplified!

At this point you'll notice that all_lists only takes one argument and both of the filtered functions have 2 arguments. My bit of code stipulates that you're filtering function must have an identical arity to the filtered function, or a single argument treated as a list. Additionally it must return a list of a values who's number is equal to the arity of the filtered function. Though it sounds like a lot its really quite simple, the filtering function must deal with the right number of arguments and get them back in a way that the original function can then proceed! You can even use multiple filters on the same function.

&lt;h2&gt;Down Side&lt;/h2&gt;

The downsides to this are obvious. The biggest problem I see is that when you're looking at the function code itself, it is in no way apparent why sending two atoms to append and prepend will work just fine and send you back a string. Although if you think of it as a language construct you just have to keep it in the back of your mind to look at the top of the source file for the given attribute.

Also, when filters are used elsewhere (such as in Rails) they generally have an effect on some global state which makes them less useful in a pure functional language. In my experience there are times though when multiple functions all execute the same code/function call upon entering, which can then, with a filter be extracted out to a single place. This might happen when you don't have the option of using some parent function, like when you want to expose many different functions in a module as an api, but some of the code is the same. Without the filter, the farthest you can get it down is to a single function call encapsulating all the duplicate code. Later if you decide to change the name of that internal function it can be a pain. In addition, Erlang does have the ability to affect global state, with things like logging, debugging/stdio, the global registry, and Mnesia.

&lt;h2&gt;Good Times&lt;/h2&gt;

It was quite fun to put together and play around with the parsed form of my own code. I definitely plan to add some more fun bits to this, like after_exec/around_exec though I've questioned the usefulness of those.

It really amazed me at how little time it took despite the almost unreadable nature of the abstract form. Erlang is continuing to show itself to have some strange innate ability to produce error free code quickly and I look forward to finding new ways to break my code at compile time :P

&lt;h2&gt;Fork Away&lt;/h2&gt;

You can fork it &lt;a href=&quot;https://github.com/johnbender/unraverl/tree/master&quot;&gt;here&lt;/a&gt;, but be warned its super aplha (no tests, etc).

I'll leave you with the resulting abstract form of this test module that I've used as an example. See if you can figure out how the filtering is implemented in unraverl (hint: its a lot like the rails which has its downsides):

&lt;script src=&quot;http://gist.github.com/88034.js&quot;&gt;&lt;/script&gt;





</content>
 </entry>
 
 <entry>
   <title>rquery for Rails is ready</title>
   <link href="http://johnbender.github.com/2009/03/21/rquery-for-rails-is-ready"/>
   <updated>2009-03-21T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/03/21/rquery-for-rails-is-ready</id>
   <content type="html">I just finished hacking this thing together this week, there's a screencast and a full explanation of what it is &lt;a href=&quot;http://nickelcode.com/rquery/&quot;&gt;here&lt;/a&gt;. Also, I hope you enjoy the music.
</content>
 </entry>
 
 <entry>
   <title>Query DSL in Ruby</title>
   <link href="http://johnbender.github.com/2009/03/12/query-dsl-in-ruby"/>
   <updated>2009-03-12T00:00:00-07:00</updated>
   <id>http://johnbender.github.com/2009/03/12/query-dsl-in-ruby</id>
   <content type="html">[update] looking at rspec I made some tweaks see bottom gist...
[update] had some even better ideas for rails see bottom again...

Having hacked rails apps is, in my opinion, not sufficient for learning the strengths/weaknesses/ins/outs of ruby, as most of it is obstructed from view. I guess in that sense they shouldn't really be called &quot;helpers&quot; (rimshot?).

In any case, I figured I could build a simple Ruby library for querying Mnesia via my little project Grove. This has given me a chance to use Rspec outside of rails, and get working with some of metaprogramming bits of the language that I haven't touched. In particular its pushed me to consider building a query language using Ruby.

There's one particular structure I'm leaning towards because it maps well to sql queries, and with Grove, Mnesia set comprehension queries. It's sort of Rspecish.

&lt;script src=&quot;http://gist.github.com/78203.js&quot;&gt;&lt;/script&gt;

Ideally, adapters would be built to implement the functions for eq, gt, etc that would allow translation into various forms of sql and other query languages. Writing things in ruby is just more fun, and it gives you more options like:

&lt;script src=&quot;http://gist.github.com/78240.js&quot;&gt;&lt;/script&gt;

It looks like my little adventure into letting ruby talk to Mnesia has pushed me in a whole new direction. I still want to add a lot more to Grove (authentication, better error description/handling, CrUD), but this might be more generally useful for other's applications.

[update] even better:

&lt;script src=&quot;http://gist.github.com/78269.js&quot;&gt;&lt;/script&gt;

[update] rails use:

&lt;script src=&quot;http://gist.github.com/78795.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;http://gist.github.com/78815.js&quot;&gt;&lt;/script&gt;
</content>
 </entry>
 
 <entry>
   <title>Rails Dev Shortages</title>
   <link href="http://johnbender.github.com/2009/02/17/rails-dev-shortages"/>
   <updated>2009-02-17T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/02/17/rails-dev-shortages</id>
   <content type="html">Mr. Frenandez's &lt;a href=&quot;ttp://blog.obiefernandez.com/content/2009/02/rails-maturity-model.html&quot;&gt;post&lt;/a&gt; on Rails Maturity has sparked quite a reaction, most notably from &lt;a href=&quot;http://gilesbowkett.blogspot.com/2009/02/obie-no.html&quot;&gt;Mr. Bowkett&lt;/a&gt;. There was one part that made me happy and frustrated all in one go:


&lt;blockquote&gt;Actually, I hate to end on a bad note, but I really think that there's some urgency to all this and that our collective failure to set high standards for the community is strangling the continued growth of Ruby and Rails overall.

&lt;blockquote&gt;Tom Mornini: Our customers at Engine Yard are screaming for more developer capacity, and in fact, TWO previous customers abandoned Rails (one for PHP and the other for Java) simply because they could not find enough skilled and savvy Rails developers to move their projects forward.&lt;/blockquote&gt;

It's not a problem only for Tom and Engine Yard. At Hashrocket we've been helping organizations transition from legacy technologies to Rails and they all have difficulties finding qualified developers. I know that folks like Courtenay at ENTP are having the same problem. Please don't shoot the messenger. Something has to be done about this, and I think it's more important than Rails 3 or anything else we are currently excited about.&lt;/blockquote&gt;

If this is you, if you're looking for someone who would make a great rails dev, please post in the comments.

[update] I would also love to work with erlang, if anyone is listening.


</content>
 </entry>
 
 <entry>
   <title>grove is out</title>
   <link href="http://johnbender.github.com/2009/02/16/grove-is-done"/>
   <updated>2009-02-16T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/02/16/grove-is-done</id>
   <content type="html">After working away at it for a month or two of scraped together free time, whilst learning erlang, grove is done and there's a screencast to demo it.

(By done I mean done for now, I've got some other projects to attend to for a bit)

&lt;a href=&quot;http://nickelcode.com/grove&quot;&gt;http://nickelcode.com/grove&lt;/a&gt;
</content>
 </entry>
 
 <entry>
   <title>Scale Rails Screencasts</title>
   <link href="http://johnbender.github.com/2009/02/11/scale-rails-screencasts"/>
   <updated>2009-02-11T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/02/11/scale-rails-screencasts</id>
   <content type="html">&lt;a href=&quot;http://railslab.newrelic.com/scaling-rails&quot;&gt;http://railslab.newrelic.com/scaling-rails&lt;/a&gt;

Been watching these, and they are great from every perspective. Even if your rails app is small and doesn't really need to scale, the client side optimization tips in the first video are awesome stuff to put into practice.
</content>
 </entry>
 
 <entry>
   <title>testing = mochijson2 funnyness feature</title>
   <link href="http://johnbender.github.com/2009/01/31/unit-testing-finds-mochijson2-funnyness"/>
   <updated>2009-01-31T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/01/31/unit-testing-finds-mochijson2-funnyness</id>
   <content type="html">[Update] I filed a ticket on the mochiweb google code site, and they pointed out that this &lt;strong&gt;IS&lt;/strong&gt; expected behaviour. Mochijson2 expects binary strings, which makes good sense since when you decode with mochijson2, strings are converted to just that! Also, string operations in Erlang are faster on binary strings (or so I've been told). See the gist for an example.

So I'm working on my test coverage for grove, which has been otherwise abysmal and late to the game. The bright side is that I caught some funnyness with my testing that I was not dealing with before, and I thought I would share my good fortune with everyone.

Notice I said &lt;strong&gt;funnyness&lt;/strong&gt; and not wrongness, this may be the intended behavior but I was not expecting it.

&lt;script src=&quot;http://gist.github.com/55800.js&quot;&gt;&lt;/script&gt;

I realized this once I started building my unit tests because I'd been dealing with atoms and numbers ONLY for the value position of those key/value tuples. Obviously I thought it a bit odd when the string result I got included and array of integers where I expected to see a string.

Solution: use mochijson. Not sure why I was using 2 in the first place.

Blah, blah worthless post, _but_ I am constantly reminded why testing makes the world a better place. To take it a bit farther I'm going to borrow a story my high school econ teacher, Mr. Werbylo, told me to explain why we shouldn't sit on the desks in class:

&lt;blockquote&gt;

Look, [ these desks are old &lt; =&gt; programming is hard ].

If you [ fall of the desk  &lt; =&gt; don't build unit tests ] you're going to be hurt and everyone is going to laugh at you for your clumsiness. Most people think the story ends there, but it doesn't. When you get home, you'll still be angry and you might kick your dog. Your dog, being angry and sad from the physical pain you've caused him will bite the mailman. And finally, ultimately,  the mailman will go to work the next day with an Uzi and kill everyone.

That, is how [ falling of a desk &lt; =&gt; failing to get test coverage ] causes loss of life.

&lt;/blockquote&gt;

One of my favorite teachers.



</content>
 </entry>
 
 <entry>
   <title>Erlang: Pattern Matching Declarations vs Case Statements/Other</title>
   <link href="http://johnbender.github.com/2009/01/17/erlang-pattern-matching-declarations-vs-case-statementsother"/>
   <updated>2009-01-17T00:00:00-08:00</updated>
   <id>http://johnbender.github.com/2009/01/17/erlang-pattern-matching-declarations-vs-case-statementsother</id>
   <content type="html">[Update] I did some refactoring that I've been meaning to do thanks to ayrnieu in #erlang.

So as I'm hacking my first Erlang project I've come across a few places where I was unsure what would generally be a more readable/understandable/robust solution to a given problem. The one I'm thinking about right now is using pattern matching in my function definitions or, alternatively, case statements. I'm hoping someone from the community might be able to shed some light.

Part of the project I'm working on turns a tuple like:

&lt;script src=&quot;http://gist.github.com/48407.js&quot;&gt;&lt;/script&gt;

into a set comprehension like:

&lt;script src=&quot;http://gist.github.com/48409.js&quot;&gt;&lt;/script&gt;

As you can see my goal is to be able to query Mnesia, or rather to produce a standard way to query any data store. The following function definition and support functions do the work:

&lt;script src=&quot;http://gist.github.com/48410.js&quot;&gt;&lt;/script&gt;

The tuple is &quot;filtered&quot; down the function definitions, and when each tuple (columns, operations, etc) is handled it is translated into a string and thus not matched again until ultimately the final definition concatenates all the pieces together to build/return our query. I REALLY like the way this works in that its short and simple. Also the tuples could in theory be replaced by an appropriate string built outside the function and it would still work, which makes it more flexible.

It has other issues, such as its fragile ordering requirement. If its not ordered properly it may break, or worse just not form the comprehension properly. Which leads me to wonder if there's a better way to implement this, even if its not _quite_ as concise.

The following is a quick hack and not tested but another way to handle it might look like:

&lt;script src=&quot;http://gist.github.com/48416.js&quot;&gt;&lt;/script&gt;

Honestly, I can't say which would be better as I haven't tried replacing the version I'm using with a case statement. Is there even a third and better way to handle this situation? Or is this just a case of agonizing over the fork or spoon for eating your pie: doesn't really matter both will work equally well.

Also, I am proposing a new term for pattern matching in function declarations:

&lt;strong&gt;patmatchlarations!&lt;/strong&gt;



</content>
 </entry>
 

</feed>