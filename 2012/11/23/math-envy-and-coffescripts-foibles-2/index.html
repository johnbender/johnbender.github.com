
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    
    <title>Math Envy and CoffeeScript's Foibles, Part 2</title>
    
    
    <meta name="author" content="John Bender">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="//johnbender.github.com/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="//johnbender.github.com/assets/themes/twitter/css/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="//johnbender.github.com/assets/themes/twitter/css/cv.css" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="//johnbender.github.com">johnbender.us</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
  
    
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/cv.html">Curriculum Vitae</a></li>
      	
      
    
  
    
      
      	
        <li><a href="//johnbender.github.com/portfolio.html">Portfolio</a></li>
      	
      
    
  



          </ul>

          <div class="social-media">
            <a href="http://twitter.com/johnbender">
              <img src="//johnbender.github.com/assets/themes/twitter/../../../assets/images/twitter.png">
            </a>
            <a href="http://github.com/johnbender">
              <img src="//johnbender.github.com/assets/themes/twitter/../../../assets/images/github.png">
            </a>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        
<div class="page-header">
  <h1>Math Envy and CoffeeScript's Foibles, Part 2</h1>
</div>

<div class="row-fluid">
  <div class="span9">
    <h2 id="toc_27">Type Rules</h2>

<p>Type rules are similar in construction to evaluation rules consisting of a premise and conclusion. As with evaluation rules the premise establishes the preconditions for the conclusion.</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-rules.png"></img>
</div>

<p>The type rules for this subset of CoffeeScript are fairly intuitive. For the type rules without a premise like <code>true : Bool</code> and <code>false : Bool</code>, we take them to be true out of hand. That is, the terms <code>true</code> and <code>false</code> both have the type <code>Bool</code>. The others are more complicated.</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-rules-lambda-term.png"></img>
</div>

<p>Equation 9 illustrates how to determine the type of a lambda term like <code>(-&gt; true)</code>. The premise above the line states that if the subterm <code>t</code> has the type <code>T</code>, then the conclusion on the bottom, <code>\t</code>, has the type <code>\top \to T</code>. Translated to our mini example <code>(-&gt; true)</code>, because the subterm <code>true</code> has the type <code>Bool</code>, the lambda term has the type <code>\top \to Bool</code>. One extremely important note: because neither of the lambda expressions make use of arguments, Top (<code>Top</code>) is used to represent the acceptance of any type. So when <code>t</code> in <code>\t</code> has the type <code>T</code> it means that <code>\t</code> will, under invocation or application, result in an expresion of typ <code>T</code> regardless of what it&#39;s applied to or invoked with. As an example:</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-rules-lambda-invocation.png"></img>
</div>

<p>Equation 10 shows how to determine the type of lambda invocation like <code>(-&gt; true)()</code>. The premise states if the lambda term has the type <code>\top \to T</code> the term <code>\t()</code> has the type <code>T</code>. This fits with the CoffeeScript <code>(-&gt; true)()</code> which obviously evaluates to <code>true</code> which has the type <code>Bool</code>. Again, <code>\top</code> is used to denote the fact that the argument type is unimportant and in this case non existent.</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-rules-lambda-application.png"></img>
</div>

<p>Equation 11 is the type rule for lambda applications such as <code>(-&gt; true) false</code>. The premise says that if the lambda term <code>\t</code> on the left has the type <code>\top \to T_1</code> and the term on the right as the type <code>T_2</code> the conclusion is that the application of the lambda term will have the type <code>T_1</code>. Again, the type of an application, like invocation, is only concerned with the type of the <em>first</em> lambda&#39;s subterm <code>t</code>.</p>

<h2 id="toc_28">Type Rule Stacking</h2>

<p>This notation makes it easy to establish the type of a term by stacking the type rules on one another. Taking a very timple example, some diagrams will illustrate how this works:</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span>
</code></pre>
</div>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-derivation-simple.png"></img>
</div>

<p>Equation 13 is the stack, a derivation tree. It explains how the reader can derive the type at the bottom from it&#39;s subterms. Starting with equation 14, the subterm <code>true</code> is typed by the type rule <em>true</em>. That can then be &quot;stacked&quot; by using it to replace the premise of type rule <em>lambda</em> in equation 15. The type derivation expands from the subterm to establish each subsequent parent term&#39;s type. Make sure to note that type derivations are never really accompanied by the full form of the type rules in equations (just the labels like <em>lambda</em> and <em>true</em>) but it&#39;s helpful here for illustration here. Taking the more complex term from earlier it&#39;s clear why they are ommited:</p>
<div class="highlight"><pre><code class="coffeescript"><span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">false</span><span class="p">))()</span>
</code></pre>
</div>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-derivation-complex.png"></img>
</div>

<p>Since there are two subterms involved in application, each branch extends upward until it reaches the atomic value types <code>true : Bool</code> and <code>false : Bool</code>. The subterm on the left is identical to equation 13. On the right, the nested lambdas and invocation make for a taller stack of type rules to reach the atomic <code>false</code>.</p>

<h2 id="toc_29">Not Quite There</h2>

<p>At this point the CoffeeScript subset has enough definition to describe the original issue in terms of evaluation or typing. That is, using the inference rules it&#39;s clear that the evaluation of <code>(-&gt; true)() -&gt; false</code> &quot;gets stuck&quot; from the following derivation tree:</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-eval-derivation-original-issue.png"></img>
</div>

<p>After the invocation of the left lambda term the evaluation gets stuck because the right lambda term can&#39;t be evaluated any further and no rule exists to handle the application of the term <code>true</code> to <code>(-&gt; false)</code>. Additionally, a derivation tree based on the typing rules highlight that the term is untypable:</p>

<div class="center">
  <img src="/assets/images/diagrams/cs-type-derivation-original-issue.png"></img>
</div>

<p>Once the derivation tree reaches the outermost term it breaks because once again we have no type rule for the application of <code>true</code> to a lambda term like <code>(-&gt; false)</code>. It&#39;s a type error.</p>

<p>So what&#39;s been gained thusfar by applying the formalism of operational semantics and type derivations? It&#39;s clear that types, inferred or otherwise, would prevent at least the original case <code>(-&gt; true)() -&gt; false</code> as you can see from the type derivation. Unfortunately type derivation or type inference would only alert the end user and not an author in the middle of creating a language and then only if the result of the leftmost lambda term is not a lambda term. That is, if the leftmost lambda term evaluates to a lambda term the the whole thing is well typed. This means type information/derivations alone can&#39;t help identify this syntactic ambiguity.</p>

<h2 id="toc_30">Detecting Ambiguity</h2>

<p>Even if the two terms will <em>not</em> result in a type error under evaluation (See the snippet below for an example), they have different types and different derivation trees. Taken together with the fact that the two expresions are &quot;similar&quot; might be enough.</p>

<p>As an aside, you might wonder what value there is in creating type/evaluation derivations since the difference in the final type is clear. In another language two terms with the same final type and very similar syntax might have different type/evaluation derivations. It may even be possible with CoffeeScript and I&#39;m simply not clever enough to think of an example. In any case they both carry useful information that shouldn&#39;t be discarded without good reason.</p>
<div class="highlight"><pre><code class="coffeescript"><span class="c1"># fails</span>
<span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">)</span><span class="nf">() -&gt;</span> <span class="kc">false</span>

<span class="c1"># works fine</span>
<span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">))</span><span class="nf">() -&gt;</span> <span class="kc">false</span>

<span class="c1"># also works fine</span>
<span class="p">(</span><span class="o">-&gt;</span> <span class="p">(</span><span class="o">-&gt;</span> <span class="kc">true</span><span class="p">))</span> <span class="nf">() -&gt;</span> <span class="kc">false</span>
</code></pre>
</div>

<p>With at least two concrete ways to identify a semantic difference between terms, the syntax itself can be used as measure of syntactic difference. This provides a sliding scale</p>

<p>Since this particular problem is small the definition can start out simple. Taking the Levenshtein Distance as a function of string size should work for a start. For the syntax/string representation of two terms <code>a</code> and <code>b</code>:</p>

<p>insert image</p>

<p><em>For two terms with inconsistent types, we say they are more or less ambigous based on the calculation Levenshtein Distance/max(Length<sub>1</sub>, Length<sub>2</sub>)</em>.</p>

<h3 id="toc_31">footnotes</h3>

<p>!! See the confusion over Monads/Functors due in part to their relationship with mathematics</p>

<p>!! Turing, Church, Algorithms</p>

<p>!! denotational semantics, axiomatic semantics</p>

<p>!! more information about types and programming languages and how much you like it</p>

<p>!! This Theorem is referred to as Determinacy of Evaluation. I may go back and do some simple proofs for my own education after this post and a possible follow up.</p>

<p>!! Tested at <a href="http://coffeescript.org/">http://coffeescript.org/</a>.</p>

<p>!! Technically JavaScript uses a strategy known as Call by Sharing, which differs from Call by Value in how deals with objects. More information at <a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/">http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/</a> courtesy of <a href="https://twitter.com/raganwald">@raganwald</a>.</p>

    
  </div>

  <div id="info" class="span3">
    <h4>Published</h4>
    <div class="date"><span>23 November 2012</span></div>

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
    
    	<li><a href="#coffeescript-ref">coffeescript <span>2</span></a></li>
    
    	<li><a href="#javascript-ref">javascript <span>10</span></a></li>
    
    	<li><a href="#math-ref">math <span>10</span></a></li>
    
  



    </ul>
  
  </div>
</div>


      </div>

    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="//johnbender.github.com/2012/10/09/math-envy-and-coffeescripts-foibles" title="Math Envy and CoffeeScript's Foibles, Part 1">&larr; Previous</a></li>
      
        <li><a href="//johnbender.github.com/archive.html">Archive</a></li>
      
        <li class="next disabled"><a>Next &rarr;</a>
      
      </ul>
    </div>

    <footer>
      <p>&copy; John Bender 2012
        with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
      </p>
    </footer>

    </div>

    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21257360-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>




  </body>
</html>

