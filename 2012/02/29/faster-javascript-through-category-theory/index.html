
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Faster JavaScript Through Category Theory</title>
    
    <meta name="author" content="John Bender">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="//johnbender.github.com/writing/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="//johnbender.github.com/writing/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="//johnbender.github.com/writing">johnbender.us</a>
          <ul class="nav">
            
            
            


  
    
      
    
  
    
      
      	
      	<li><a href="//johnbender.github.com/writing/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="//johnbender.github.com/writing/categories.html">Categories</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="//johnbender.github.com/writing/tags.html">Tags</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="//johnbender.github.com/writing/pages.html">Pages</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <div class="content">
        
<div class="page-header">
  <h1>Faster JavaScript Through Category Theory</h1>
</div>

<div class="row-fluid">
  <div class="span9">
    This post started out as a <a href="https://gist.github.com/7242a7434195565b4a9d">gist</a> meant to help work through what I've learned about category theory by applying it to something I already knew, JavaScript. The surprising result is a clearly defined set of JavaScript functions and jQuery helpers that can be optimized to reduce execution time.

In the course of this post we'll define two categories: one for HTMLElements and the other for jQuery objects. We'll then construct a Functor that maps from the category of HTMLElements to the category of jQuery objects. At the end we'll see how jQuery plugin authors can help user's speed up their JavaScript using what we learned along the way.

<h2>Assumptions/Requirements</h2>

Some things to know before getting started:

<ol>
<li><code>this</code> is treated as an implicit parameter to jQuery helper functions, later referred to as <strong>Jqry</strong> morphisms.</li>
<li>Type guarantees are made by the closure compiler JSDoc type annotations and custom <code>@sig</code> type signature annotation. Don't worry if this is new to you -- it only adds a bit more rigor to the discussion.</li>
<li>My examples do not constitute proofs but I'm fairly confident that both categories and the functor satisfy their respective laws.<sup>1</sup></li>
</ol>

<h2>Categories</h2>

If you're perfectly happy taking the category definitions at face value, feel free to skip ahead to the next section.

A category consists of two things, a set of objects and a set of morphisms sometimes referred to as arrows that relate two of those objects. In layman's terms, a category is a consistent set of things (objects) and operations on those things (morphisms/arrows). The abstract nature of both is exactly what gives categories and category theory power, because you can define a wide range of systems in terms of a categories. A few examples, including the two defined later in the post, will help to build an intuition for the forms that objects and morphisms can take.

<ol>
<li><a href="http://en.wikibooks.org/wiki/Haskell/Category_theory#Hask.2C_the_Haskell_category">Hask</a> is the category where Haskell types are the objects and functions are the morphisms.</li>
<li><a href="http://en.wikipedia.org/wiki/Category_of_sets">Set</a> is the category where objects are sets and the morphism are, again, functions between those sets.</li>
</ol>

Additionally each and every category must satisfy three laws.

<ol>
<li>Identity: The morphisms in a category must include an identity morphism. In terms of the category Set or Hask and those defined here, the identity morphism is just a function that return it's first and only argument.</li>
<li>Composition: The composition of morphisms, which is itself a requirement, must be associative. For Hask, Set, and the following categories this is simply function composition (eg <code>.</code> for Hask) and we'll explicitly define a composition function for <strong>Html</strong> and <strong>Jqry</strong>. Function application is always associative<sup>2</sup> so for Hask, Set and the categories to follow this can be assumed.</li>
<li>Closed Under Composition: When composing two morphisms in a category the result must also be in the set of morphisms in that same category. For Hask this means that the output of composing two functions must be another function that takes a Haskell type and returns a Haskell type.</li>
</ol>

These laws are important for understanding the conclusions drawn from the rest of the post and we'll cover how both the <strong>Html</strong> and <strong>Jqry</strong> categories satisfy each.

<h2>Html</h2>

The Category <strong>Html</strong> is extremely simple and, if you're still interested in understanding categories more generally, it will help in building an intuition for them. The objects in <strong>Html</strong> are the HTMLElements that you're familiar with from JavaScript (eg, HTMLDivElement, HTMLAnchorElement). The morphisms are JavaScript functions that opperate on those objects, and <em>only</em> those objects.

The next step is to make sure that <strong>Html</strong> satisfies the three category laws:

Identity:

<pre>
<span class="doc">/** @sig {HTMLElement} -&gt; {HTMLElement} */</span>
<span class="keyword">function</span> <span class="function-name">id</span>( <span class="js2-function-param">a</span> ) {
  <span class="keyword">return</span> a;
}
</pre>

Composition:

<pre>
<span class="doc">/** @typedef {function(HTMElement): HTMElement} */</span>
html.morphism;

<span class="doc">/** @sig {html.morphism}, {html.morphism} -&gt; {html.morphism} */</span>
<span class="keyword">function</span> <span class="function-name">compose</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>( <span class="js2-function-param">a</span> ) {
    <span class="keyword">return</span> f(g(a));
  };
}
</pre>

Sample use of <code>compose</code>:

<pre>
<span class="keyword">function</span> <span class="function-name">a</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"foo"</span>, <span class="string">"bar"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">function</span> <span class="function-name">b</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"baz"</span>, <span class="string">"bak"</span> );
  <span class="keyword">return</span> elem;
}

<span class="keyword">var</span> <span class="variable-name">elem</span> = document.getElementById( <span class="string">"example-anchor"</span> );
elem.getAttribute( <span class="string">"foo"</span> ); <span class="comment">// undefined
</span>elem.getAttribute( <span class="string">"baz"</span> ); <span class="comment">// undefined
</span>
elem = compose( a, b )( elem );
elem.getAttribute( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span>elem.getAttribute( <span class="string">"baz"</span> ); <span class="comment">// "bak"
</span></pre>

The identity function is trivial and, as noted before, function composition is always associative. We know that the functions in <strong>Html</strong> are closed under composition because of the type guarantees we've placed on them. That is, all the functions accept as their only argument HTMLElements and return only HTMLElements so there's no way to compose two of them that doesn't also have the same type signature. Having met the three requirements for a category with <strong>Html</strong> we can move on to the second, and more complex category <strong>Jqry</strong>.

<h2>Jqry</h2>

<strong>Jqry</strong> is the category of <code>jQuery</code> objects and functions from <code>jQuery</code> objects to <code>jQuery</code> objects.<sup>3</sup> It's only slightly more complex than <strong>Html</strong> because the reader must accept <code>this</code> as an implicit parameter to the JavaScript functions that are the category's morphisms. Also, these morphisms must be defined on the <code>$.fn</code> object to guarantee the value of <code>this</code> is a <code>jQuery</code> object. Otherwise the objects are simply jQuery objects as you know them from day to day use, ie the result of something like <code>$("div")</code>, and the functions are JavaScript functions that retun jQuery objects.

Identity:

<pre>
<span class="doc">/** @this {jQuery}
    @return {jQuery} */</span>
<span class="js2-external-variable">$</span>.fn.<span class="function-name">id</span> = <span class="keyword">function</span>(){ <span class="keyword">return</span> <span class="builtin">this</span>; };
</pre>

Sample use of <code>$.fn.id</code>:

<pre>
<span class="keyword">var</span> <span class="variable-name">$elem</span> = $( <span class="string">"#example-anchor"</span> );

assert($elem.id() == $elem); <span class="comment">// true
</span></pre>

As you can see, the value of <code>this</code>, and therefore the constraint that the morphisms must be defined on <code>$.fn</code>, plays an important role in the way that the functions behave in the <strong>Jqry</strong> category. If it's unclear why that is, remember that <code>this</code> is whatever object the method is invoked on using dot notation in JavaScript. Also recall that <code>$.fn == $.prototype</code>, meaning when you call <code>$("div").foo()</code> it finds <code>foo</code> on the <code>$.fn</code> by following the prototype chain.

Composition:

<pre>
<span class="doc">/** @typedef {function(this:jQuery): jQuery} */</span>
jqry.morphism;

<span class="doc">/** @sig {jqry.morphism}, {jqry.morphism} -&gt; {jqry.morphism} */</span>
<span class="js2-external-variable">$</span>.<span class="function-name">compose</span> = <span class="keyword">function</span>( <span class="js2-function-param">f</span>, <span class="js2-function-param">g</span> ){
  <span class="keyword">return</span> <span class="keyword">function</span>(){
    <span class="keyword">return</span> f.apply(g.apply(<span class="builtin">this</span>, arguments), arguments);
  };
};
</pre>

Defining composition is a bit more complex for <strong>Jqry</strong> than it is for <strong>Html</strong> if only because forcing the value that <code>this</code> will represent in the composed functions takes more work than just passing in the values as parameters. The first function, <code>g</code>, is invoked by forwarding the arguments and explicitly defining its <code>this</code> value using the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply">apply</a> method common to all JavaScript functions. The value returned by applying <code>g</code> is a jQuery object, as required by membership in the category <strong>Jqry</strong>, which is used to explicitly define <code>this</code> in the application of <code>f</code>.

Sample use:

<pre>
<span class="js2-external-variable">$</span>.fn.<span class="function-name">a</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>.map(<span class="keyword">function</span>( <span class="js2-function-param">elem</span> ){
    elem.setAttribute( <span class="string">"foo"</span>, <span class="string">"bar"</span> );
    <span class="keyword">return</span> elem;
  });
};

<span class="js2-external-variable">$</span>.fn.<span class="function-name">b</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>.map(<span class="keyword">function</span>( <span class="js2-function-param">elem</span> ){
    elem.setAttribute( <span class="string">"baz"</span>, <span class="string">"bak"</span> );
    <span class="keyword">return</span> elem;
  });
};

<span class="keyword">var</span> <span class="variable-name"><span class="js2-warning">$elem</span></span> = $( <span class="string">"#example-anchor"</span> );
$elem.attr( <span class="string">"foo"</span> );         <span class="comment">// undefined
</span>$elem.attr( <span class="string">"baz"</span> );         <span class="comment">// undefined
</span><span class="js2-external-variable">$</span>.fn.aAndB = $.compose( $.fn.a, $.fn.b );

$elem.aAndB().attr( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span>$elem.attr( <span class="string">"baz"</span> );         <span class="comment">// "bak"
</span></pre>

Please direct your attention to the fact that you could substitute the <code>a</code> and <code>b</code> functions from the <strong>Html</strong> <code>compose</code> example here for the functions that are mapped using <code>this.map</code> (<code>$.fn.map</code>) over the set of elements in the jQuery object (represented by <code>this</code>). This will be important when defining the Functor from <strong>Html</strong> to <strong>Jqry</strong>.

Again, we know that the morphisms of <strong>Jqry</strong> are closed under composition because each accepts and returns only jQuery objects.

<h2>$() ∉ Functors</h2>

Functors are a <em>single</em> morphism from one category to another. Another way to think about them is an operation that can take either an object or a morphism from one category and translate it so that it exists or "works" in another category. This obvioulsy means that a given functor handles both morphisms and objects. Evaluating <code>$()</code> as a functor from <strong>Html</strong> to <strong>Jqry</strong>, shows that it translates the objects in the category <strong>Html</strong> (HTMLElements) properly to the objects in <strong>Jqry</strong> (instances of jQuery) but turns the morphisms (functions) into dom ready callbacks. So <code>$()</code> is not, strictly speaking, a category theoretic functor.

On the other hand it's quite easy to define a function that handles both objects functions properly. As I noted in a previous post and in an earlier in this post, <code>$.fn.map</code> provides an easy way to change functions in <strong>Html</strong> to <strong>Jqry</strong>. So, this new functor just needs to check if it's operating on an object or a function from the <strong>Html</strong> category and respond accordingly.

For the Haskell fans out there (and ciaranm in ##categorytheory) it's better to define a seperate function to handle the translation of morphisms from one category to another in the spirit of <code>fmap</code>, but since this is flexible ol' JavaScript, it's possible to use type unions in the closure compiler type constraints, and I think it makes the mapping from theory to Javascript a bit easier to understand, I've chosen to deal with both in a single function.

<h2>Functor Html → Jqry</h2>

<pre>
<span class="doc">/** @sig {HTMLElement | html.morphism} -&gt; {jQuery | jqry.morphism} */</span>
<span class="js2-external-variable">$</span>.<span class="function-name">Functor</span> = <span class="keyword">function</span>( <span class="js2-function-param">a</span> ){
  <span class="keyword">if</span>( <span class="keyword">typeof</span> a == <span class="string">"function"</span> ){
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="builtin">this</span>.map(a);
    };
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> $( a );
  }
};
</pre>

Sample use for objects:

<pre>
<span class="keyword">var</span> <span class="variable-name"><span class="js2-warning">elem</span></span> = document.getElementsById( <span class="string">"example"</span> );
elem.nodeName;                        <span class="comment">// "A"
</span>$.Functor( elem ).prop( <span class="string">"nodeName"</span> ); <span class="comment">// "A"
</span></pre>

Sample use for functions:

<pre>
<span class="js2-external-variable">$</span>.fn.myMorphism = $.Functor(<span class="keyword">function</span>( <span class="js2-function-param">a</span> ){
  a.setAttribute(<span class="string">"foo"</span>, <span class="string">"bar"</span> );
  <span class="keyword">return</span> a;
});

$( <span class="string">"#example"</span> ).attr( <span class="string">"foo"</span> );              <span class="comment">// undefined
</span>$( <span class="string">"#example"</span> ).myMorphism().attr( <span class="string">"foo"</span> ); <span class="comment">// "bar"
</span></pre>

In the first example it takes an HTMLElement, one of the objects of <strong>Html</strong>, and translates it into a jQuery object by using the <code>$()</code> function. In the second example it takes a function from HTMLElements to HTMLElements, a morpishm in <strong>Html</strong>, and translates it to a function from jQuery objects to jQuery objects.

Having establish how the functor will operate it too has laws we must obey. First it must preserve identity:

<pre>
<span class="keyword">var</span> <span class="variable-name">a</span> = document.getElementById( <span class="string">"#example-anchor"</span> );

assert($.Functor(id(a)) == $.Functor(a).id());

a;                 <span class="comment">// &lt;a id="example-anchor"&gt;&lt;/a&gt;
</span>
id(a);             <span class="comment">// &lt;a id="example-anchor"&gt;&lt;/a&gt;
</span>$.Functor(id(a));  <span class="comment">// [&lt;a id="example-anchor"&gt;&lt;/a&gt;]
</span>
$.Functor(a);      <span class="comment">// [&lt;a id="example-anchor"&gt;&lt;/a&gt;]
</span>$.Functor(a).id(); <span class="comment">// [&lt;a id="example-anchor"&gt;&lt;/a&gt;]
</span></pre>

Whether the identity function is applied before or after the Functor the result should be the same. As you can see the return value of the two expressions is idenitcal. The second law states the the Functor must preserve composition. Assuming a and b from the html compose example:

<pre>
<span class="keyword">var</span> <span class="variable-name"><span class="js2-warning">$elem</span></span> = $( <span class="string">"#example-anchor"</span> );
assert($.Functor(compose(a, b)) == $.compose($.Functor(a), $.Functor(b)));

<span class="keyword">var</span> <span class="variable-name">aAndB</span> = compose(a, b);
<span class="js2-external-variable">$</span>.fn.fstAB = $.Functor(aAndB);                       <span class="comment">// function() { this.map(aAndB); }
</span>$elem.fstAB().attr(<span class="string">"foo"</span>);                           <span class="comment">// "bar"
</span>$elem.attr(<span class="string">"baz"</span>);                                   <span class="comment">// "bak"
</span>
$elem = $( <span class="string">"#second-example-anchor"</span> );
$.Functor(a);                                        <span class="comment">// function() { this.map(a) };
</span>$.Functor(b);                                        <span class="comment">// function() { this.map(b) };
</span><span class="js2-external-variable">$</span>.fn.sndAB = $.compose( $.Functor(a), $.Functor(b) );
$elem.sndAB().attr(<span class="string">"foo"</span>);                           <span class="comment">// "bar"
</span>$elem.attr(<span class="string">"baz"</span>);                                   <span class="comment">// "bak"
</span></pre>

This means that composing the functions and then applying the Functor should create a function that behaves identically to one created by composing two functions that have had the Functor applied already. Essentially, for all input values the output will be the same. We'll see in a second why that distinction is important.

The assertion at the top will fail of course because the functions are not the same object. More importantly it would fail even if the functions were compared as strings, because they are using different internal mechanisms. Ultimately though the functionality is the same and that's what we care about. In each case both <code>a</code> and <code>b</code> will be allowed to alter each element in the jQuery object's set and apply the attribute values <code>foo</code> and <code>baz</code> respectively.

While they have the same outcome, the underlying machinery is very different. <code>$.fn.fstAB</code> is <em>one</em> iteration over the set of HTMLElements in the jQuery object and <code>$.fn.sndAB</code> is <em>two</em>. That is <code>$.fn.sndAB</code> is applying two seperate <code>$.fn</code> methods which is equivelant to <code>$("foo").a().b()</code>, and <code>$.fn.fstAB</code> is calling <code>$.fn.map</code> only once and piping each element through two composed functions that operate on HTMLElements -- <code>$("foo").map(aAndB)</code>.<sup>4</sup> They get the same results but <code>$.fn.sndAB</code> requires twice as many iterations over the jQuery set!

You might recognize the optimization as <a href="http://en.wikipedia.org/wiki/Loop_fusion">loop fusion</a>. By ensuring that the functor satisfies the requsite laws we've stumbled upon an interesting relationship. That is, any time we use n > 1 iterative <code>$.fn</code> methods that exist in <strong>Jqry</strong> it's possible to extract the pure HTMLElement-altering functions that <em>might</em> underly them, compose those functions, and save n-1 full iterations in the process.

<h2>Loop Fusing Hipster</h2>

It's clear that someone using <code>$("foo").a().b()</code> could, entirely indepdendent of this rigmarole, arrive at the same conclusion that the loops underlying <code>a</code> and <code>b</code> could be unified to speed up execution and subsequently point out they've been fusing loops since before it was cool. What's not clear is how to know in other cases when it's possible to extract the underlying functions from the <code>$.fn</code> methods for composition. Because of the Functor laws we've unambiguously defined a specific subset of functions -- the set of <strong>Html</strong> morphisms with <code>$.fn.map</code> applied -- that we <em>know</em> can be fused and will produce the same thing. Put differently:

As long as the <em>n</em> functions being mapped over the jQuery object's contents individually are all from HTMLElements to HTMLElements, we can compose them, map the composed function over the jQuery object set <em>once</em>, and be assured the final jQuery object will be the same.

<h2>Package it up</h2>

Now that we know which functions can be composed to save some execution time it would be nice to know how this can be used to improve jQuery plugins. One way is to get jQuery plugin authors to provide the underlying DOM manipulation functions as attributes on the plugin methods. This would allow users to do the fusing when it makes sense. Lets use our two composition examples from the <strong>Jqry</strong> category to see what this might look like.

Plugin one:

<pre>
<span class="keyword">function</span> <span class="function-name">setFoo</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"foo"</span>, <span class="string">"bar"</span> );
  <span class="keyword">return</span> elem;
}

<span class="js2-external-variable">$</span>.fn.<span class="function-name">a</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>.map(setFoo);
};

<span class="js2-external-variable">$</span>.fn.a.pure = setFoo;
</pre>

Plugin two:

<pre>
<span class="keyword">function</span> <span class="function-name">setBaz</span>( <span class="js2-function-param">elem</span> ){
  elem.setAttribute( <span class="string">"baz"</span>, <span class="string">"bak"</span> );
  <span class="keyword">return</span> elem;
}

<span class="js2-external-variable">$</span>.fn.<span class="function-name">b</span> = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="builtin">this</span>.map(setBaz);
};

<span class="js2-external-variable">$</span>.fn.b.pure = setBaz;
</pre>

Now both the function from <strong>Html</strong> and the function from <strong>Jqry</strong> are available to the end user. Should they end up using them in serial it's trivial to fuse the two loops:

<pre>
<span class="comment">// two full iterations
</span>$(<span class="string">"foo"</span>).a().b();

<span class="comment">// one full iteration
</span>$(<span class="string">"foo"</span>).map(compose($.fn.a.pure, $.fn.b.pure));
</pre>

Obviously these two examples are tiny and could easily be consolidated by hand, but two plugins with more complex DOM manipulations would be much harder to classify as "fusable". By puting the onus on the plugin developer it gives the end user a better guarantee that it's safe.

<h2>Did you make it?</h2>

And there you have it. After defining a mathematical framework in which to view DOM alterations with jQuery and JavaScript we identified an important set of characteristics to use for speeding up our client side code. Maybe this isn't enough to get you interested, but for me it's an affirmation that, even this far from its ivory towers, math has a role to play.

<h2>Footnotes</h2>

<ol>
<li>Thanks again to edwardk and xplat from #haskell-blah and ciaranm from ##categorytheory for reviewing my categories and providing feedback. I'd also like to thank <a href="http://twitter.com/keyist">Tim Goh</a> for taking the time to enhance my terrible writting.</li>
<li>Function composition is always associative, even for impure "functions". You'll have to google around a bit for a proof but this appears to be a <a href="http://en.wikipedia.org/wiki/Function_composition">generally accepted truth</a>.</li>
<li>If you're interested in digging a bit further into this topic <strong>Jqry</strong> appears to be a monoid so the plural "objects" may not be accurate. Credit to both edwardk and xplat in #haskell-blah for pointing this out. As far as I can tell, product is the <code>$.fn.add</code> method because takes two jQuery objecst to another jQuery object and the unit element is <code>[]</code> as using it with <code>$()</code> -- the unit morphism -- yields an empty jQuery object. Thanks to both Dan Peebles and Tom Switzer for clarifying in the comments.</li>
<li>Haskellers will recognize this, and the ultimate conclusion that the rest of the post draws as a degenerate version of <code>(fmap a) . (fmap b) == fmap (a . b)</code></li>
</ol>

    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="//johnbender.github.com/writing/2012/02/22/leveraging-your-insecurities" title="Leveraging Your Insecurities">&larr; Previous</a></li>
      
        <li><a href="//johnbender.github.com/writing/archive.html">Archive</a></li>
      
        <li class="next"><a href="//johnbender.github.com/writing/2012/03/22/a-natural-transformation-in-javascript" title="A Natural Transformation in JavaScript">Next &rarr;</a></li>
      
      </ul>
    </div>
    <hr>
    
  </div>

  <div id="info" class="span3">
    <h4>Published</h4>
    <div class="date"><span>29 February 2012</span></div>

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="//johnbender.github.com/writing/tags.html#javascript-ref">javascript <span>8</span></a></li>
     
    	<li><a href="//johnbender.github.com/writing/tags.html#jquery-ref">jquery <span>9</span></a></li>
     
    	<li><a href="//johnbender.github.com/writing/tags.html#maths-ref">maths <span>3</span></a></li>
     
    	<li><a href="//johnbender.github.com/writing/tags.html#programming-ref">programming <span>28</span></a></li>
    
  



    </ul>
  
  </div>
</div>


      </div>

      <footer>
        <p>&copy; John Bender 2012
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

